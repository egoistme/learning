# 闭包 (Closure)

## 📖 什么是闭包？

**闭包**是编程中的一个重要概念，特别在函数式编程语言中广泛存在。简单来说：

> **闭包是指一个函数能够访问其外部作用域中的变量，即使在其外部函数已经返回之后。**

### 🤔 思考一下
在日常生活中，想象一个人离开了房间，但仍然记得房间里的东西。闭包就像这样 —— 函数"记住"了它被创建时的环境。

---

## 🔍 闭包的形成条件

闭包的形成需要满足三个基本条件：

1. **嵌套函数**：内部函数访问外部函数的变量
2. **变量引用**：内部函数引用了外部函数的变量
3. **函数返回**：内部函数被返回或以某种方式暴露到外部

### 基础示例

```javascript
function outerFunction(x) {
    // 外部函数的变量
    let outerVariable = x;
    
    // 内部函数（闭包）
    function innerFunction(y) {
        // 访问外部函数的变量
        return outerVariable + y;
    }
    
    // 返回内部函数
    return innerFunction;
}

// 创建闭包
const closure = outerFunction(10);

// 使用闭包，此时 outerFunction 已经执行完毕
// 但 innerFunction 仍然可以访问 outerVariable
console.log(closure(5)); // 输出：15
```

---

## ⚙️ JavaScript 中的闭包机制

### 词法作用域 (Lexical Scope)

JavaScript 使用词法作用域，这意味着函数的作用域在函数定义时就确定了，而不是在调用时。

```javascript
let globalVar = "我是全局变量";

function outerFunc() {
    let outerVar = "我是外部变量";
    
    function innerFunc() {
        let innerVar = "我是内部变量";
        console.log(globalVar); // 可以访问全局变量
        console.log(outerVar);  // 可以访问外部变量
        console.log(innerVar);  // 可以访问自己的变量
    }
    
    return innerFunc;
}

const myFunc = outerFunc();
myFunc(); // 即使 outerFunc 执行完毕，innerFunc 仍能访问 outerVar
```

### 执行上下文和作用域链

```javascript
function createCounter() {
    let count = 0; // 这个变量被"封闭"在闭包中
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1.increment()); // 1
console.log(counter1.increment()); // 2
console.log(counter2.increment()); // 1 (独立的闭包环境)

// 无法直接访问 count 变量
console.log(counter1.count); // undefined
```

---

## 💡 闭包的实际应用

### 1. 数据私有化和封装

闭包可以创建私有变量，实现数据封装：

```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        // 公开方法
        deposit: function(amount) {
            if (amount > 0) {
                balance += amount;
                return `存款成功，余额：${balance}`;
            }
            return "存款金额必须大于0";
        },
        
        withdraw: function(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                return `取款成功，余额：${balance}`;
            }
            return "取款失败：金额无效或余额不足";
        },
        
        getBalance: function() {
            return balance;
        }
    };
}

const myAccount = createBankAccount(1000);
console.log(myAccount.deposit(500));  // 存款成功，余额：1500
console.log(myAccount.withdraw(200)); // 取款成功，余额：1300
console.log(myAccount.getBalance());  // 1300

// balance 变量无法直接访问，实现了数据私有化
console.log(myAccount.balance); // undefined
```

### 2. 函数工厂模式

```javascript
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

// 创建不同的乘法器
const double = createMultiplier(2);
const triple = createMultiplier(3);
const tenTimes = createMultiplier(10);

console.log(double(5));   // 10
console.log(triple(4));   // 12
console.log(tenTimes(3)); // 30
```

### 3. 模块模式 (Module Pattern)

```javascript
const Calculator = (function() {
    // 私有变量和方法
    let result = 0;
    
    function validateNumber(num) {
        return typeof num === 'number' && !isNaN(num);
    }
    
    // 返回公共接口
    return {
        add: function(num) {
            if (validateNumber(num)) {
                result += num;
            }
            return this; // 链式调用
        },
        
        subtract: function(num) {
            if (validateNumber(num)) {
                result -= num;
            }
            return this;
        },
        
        multiply: function(num) {
            if (validateNumber(num)) {
                result *= num;
            }
            return this;
        },
        
        divide: function(num) {
            if (validateNumber(num) && num !== 0) {
                result /= num;
            }
            return this;
        },
        
        getResult: function() {
            return result;
        },
        
        reset: function() {
            result = 0;
            return this;
        }
    };
})();

// 使用模块
Calculator.add(10).multiply(2).subtract(5);
console.log(Calculator.getResult()); // 15
```

### 4. 事件处理和回调函数

```javascript
function setupButton(name) {
    let clickCount = 0;
    
    return function handleClick() {
        clickCount++;
        console.log(`${name} 按钮被点击了 ${clickCount} 次`);
    };
}

// 创建不同按钮的处理器
const button1Handler = setupButton("登录");
const button2Handler = setupButton("注册");

// 模拟点击事件
button1Handler(); // 登录 按钮被点击了 1 次
button1Handler(); // 登录 按钮被点击了 2 次
button2Handler(); // 注册 按钮被点击了 1 次
```

### 5. 防抖和节流实现

```javascript
// 防抖函数
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        // 清除之前的定时器
        clearTimeout(timeoutId);
        
        // 设置新的定时器
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// 节流函数
function throttle(func, delay) {
    let lastCallTime = 0;
    
    return function(...args) {
        const now = Date.now();
        
        if (now - lastCallTime >= delay) {
            lastCallTime = now;
            func.apply(this, args);
        }
    };
}

// 使用示例
const debouncedSearch = debounce(function(query) {
    console.log(`搜索：${query}`);
}, 300);

const throttledScroll = throttle(function() {
    console.log('滚动事件触发');
}, 100);
```

### 6. 记忆化 (Memoization)

```javascript
function createMemoizedFunction(fn) {
    const cache = {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache[key]) {
            console.log('从缓存返回结果');
            return cache[key];
        }
        
        console.log('计算新结果');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// 创建一个计算斐波那契数列的记忆化函数
const memoizedFib = createMemoizedFunction(function(n) {
    if (n <= 1) return n;
    return memoizedFib(n - 1) + memoizedFib(n - 2);
});

console.log(memoizedFib(40)); // 第一次计算
console.log(memoizedFib(40)); // 从缓存返回，速度很快
```

---

## ⚠️ 常见的闭包陷阱

### 1. 循环中的闭包问题

❌ **错误的做法：**
```javascript
function createFunctions() {
    const functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions[i] = function() {
            console.log(i); // 所有函数都会输出 3
        };
    }
    
    return functions;
}

const funcs = createFunctions();
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3
```

✅ **正确的解决方案：**

方案一：使用 `let` 代替 `var`
```javascript
function createFunctions() {
    const functions = [];
    
    for (let i = 0; i < 3; i++) { // 使用 let
        functions[i] = function() {
            console.log(i); // 每个函数都有自己的 i
        };
    }
    
    return functions;
}
```

方案二：使用立即执行函数 (IIFE)
```javascript
function createFunctions() {
    const functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions[i] = (function(index) {
            return function() {
                console.log(index);
            };
        })(i);
    }
    
    return functions;
}
```

### 2. 内存泄漏风险

```javascript
function attachListeners() {
    const element = document.getElementById('myButton');
    const data = new Array(1000000).fill('some data'); // 大量数据
    
    element.onclick = function() {
        // 即使不使用 data，闭包也会持有它的引用
        console.log('按钮被点击');
    };
    
    // 正确的做法：显式清理
    return function cleanup() {
        element.onclick = null;
        // data 会被垃圾回收
    };
}
```

---

## 🎯 学习要点总结

### 核心概念
1. **闭包 = 函数 + 词法环境**
2. **闭包可以访问外部函数的变量**
3. **每个闭包都有独立的变量环境**

### 实用价值
- ✅ 数据私有化和封装
- ✅ 模块模式实现
- ✅ 函数式编程范式
- ✅ 事件处理和异步编程
- ✅ 性能优化（记忆化、防抖节流）

### 注意事项
- ⚠️ 避免循环中的闭包陷阱
- ⚠️ 注意内存泄漏风险
- ⚠️ 理解执行上下文和作用域链

---

## 🚀 进阶学习建议

1. **实践练习**：尝试实现自己的模块模式
2. **源码阅读**：研究知名库（如 jQuery、Lodash）中闭包的使用
3. **性能分析**：使用开发者工具分析闭包的内存使用
4. **异步编程**：结合 Promise 和 async/await 理解闭包在异步场景的应用

记住：**理解闭包不仅是掌握一个语法特性，更是理解 JavaScript 函数式编程思维的关键！** 🎉