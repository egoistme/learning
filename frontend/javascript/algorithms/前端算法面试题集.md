# 🎯 前端算法面试题集

> **学习目标**: 系统掌握前端开发中最常考的算法题型，培养算法思维能力

## 📚 目录

- [数组类算法](#-数组类算法) - 最高频，必须掌握
- [字符串算法](#-字符串算法) - 常考类型
- [链表算法](#-链表算法) - 数据结构基础
- [树算法](#-树算法) - 递归思维训练
- [动态规划](#-动态规划) - 优化算法思维
- [搜索与回溯](#-搜索与回溯) - 解空间探索
- [面试技巧](#-面试技巧)

## 🚀 学习建议

### 📖 学习方法
1. **理解题意**: 仔细阅读题目，明确输入输出
2. **分析思路**: 寻找规律，选择合适的算法策略
3. **编码实现**: 先写主要逻辑，再处理边界条件
4. **测试验证**: 用多个测试用例验证正确性
5. **复杂度分析**: 分析时间和空间复杂度
6. **优化改进**: 思考是否还有更优解法

### 🎯 前端特色
前端算法题通常关注：
- **数据处理**: 数组操作、对象转换
- **性能优化**: 时间复杂度、空间复杂度
- **实际应用**: 与业务场景结合
- **JavaScript特性**: 利用语言特性简化实现

---

## 📊 数组类算法

> **重要程度**: ⭐⭐⭐⭐⭐ | **出现频率**: 90%+

### 1. 两数之和 (Two Sum)

**🎯 题目描述**:
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

**📝 示例**:
```javascript
输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: nums[0] + nums[1] = 2 + 7 = 9
```

**💡 解法一: 哈希表优化**
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function twoSum(nums, target) {
    // 创建哈希表存储值和索引的映射
    const map = new Map();

    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];

        // 检查补数是否已存在
        if (map.has(complement)) {
            return [map.get(complement), i];
        }

        // 存储当前数字和索引
        map.set(nums[i], i);
    }

    return []; // 没有找到结果
}

// 测试用例
console.log(twoSum([2, 7, 11, 15], 9)); // [0, 1]
console.log(twoSum([3, 2, 4], 6));      // [1, 2]
console.log(twoSum([3, 3], 6));         // [0, 1]
```

**⚡ 复杂度分析**:
- 时间复杂度: O(n) - 只需遍历一次数组
- 空间复杂度: O(n) - 哈希表存储最多n个元素

**🔍 思路解析**:
1. 使用哈希表记录已遍历的数字及其索引
2. 对于当前数字，计算需要的补数 (target - 当前数字)
3. 如果补数已在哈希表中，则找到答案
4. 否则将当前数字存入哈希表继续遍历

**🎯 变体题目**:
- 三数之和 (3Sum)
- 四数之和 (4Sum)
- 两数之和 II - 输入有序数组

---

### 2. 数组去重

**🎯 题目描述**:
给定一个数组，返回去除重复元素后的数组。要求考虑多种数据类型，包括基本类型和引用类型。

**📝 示例**:
```javascript
输入: [1, 1, '1', 2, true, true, false, false, 'hello', 'hello', null, null, undefined, undefined]
输出: [1, '1', 2, true, false, 'hello', null, undefined]
```

**💡 解法一: Set去重(基本类型)**
```javascript
/**
 * 基本类型数组去重
 * @param {Array} arr
 * @return {Array}
 */
function removeDuplicatesBasic(arr) {
    return [...new Set(arr)];
}

// 测试
console.log(removeDuplicatesBasic([1, 1, 2, 2, 3])); // [1, 2, 3]
```

**💡 解法二: 通用去重(包含对象)**
```javascript
/**
 * 通用数组去重，支持对象
 * @param {Array} arr
 * @return {Array}
 */
function removeDuplicatesAdvanced(arr) {
    const result = [];
    const seen = new Set();

    for (const item of arr) {
        // 基本类型直接比较
        if (typeof item !== 'object' || item === null) {
            if (!seen.has(item)) {
                seen.add(item);
                result.push(item);
            }
        } else {
            // 对象类型通过JSON字符串比较
            const key = JSON.stringify(item);
            if (!seen.has(key)) {
                seen.add(key);
                result.push(item);
            }
        }
    }

    return result;
}

// 测试
const testArray = [
    1, 1, '1',
    { name: 'John', age: 25 },
    { name: 'John', age: 25 },
    { name: 'Jane', age: 23 }
];
console.log(removeDuplicatesAdvanced(testArray));
// [1, '1', { name: 'John', age: 25 }, { name: 'Jane', age: 23 }]
```

**💡 解法三: 自定义比较函数**
```javascript
/**
 * 使用自定义比较函数去重
 * @param {Array} arr
 * @param {Function} compareFn - 比较函数
 * @return {Array}
 */
function removeDuplicatesCustom(arr, compareFn) {
    const result = [];

    for (const item of arr) {
        const isDuplicate = result.some(existing => compareFn(item, existing));
        if (!isDuplicate) {
            result.push(item);
        }
    }

    return result;
}

// 按照对象的id字段去重
const objects = [
    { id: 1, name: 'A' },
    { id: 2, name: 'B' },
    { id: 1, name: 'A' },
    { id: 3, name: 'C' }
];

const unique = removeDuplicatesCustom(objects, (a, b) => a.id === b.id);
console.log(unique); // [{ id: 1, name: 'A' }, { id: 2, name: 'B' }, { id: 3, name: 'C' }]
```

**⚡ 复杂度分析**:
- Set方法: O(n) 时间，O(n) 空间
- 通用方法: O(n) 时间，O(n) 空间
- 自定义方法: O(n²) 时间，O(n) 空间

---

### 3. 数组扁平化 (Flatten Array)

**🎯 题目描述**:
将多维数组转换为一维数组，支持指定扁平化深度。

**📝 示例**:
```javascript
输入: [1, [2, 3], [4, [5, 6]], 7]
输出: [1, 2, 3, 4, 5, 6, 7]
```

**💡 解法一: 递归实现**
```javascript
/**
 * 递归扁平化数组
 * @param {Array} arr
 * @param {number} depth - 扁平化深度，默认为无限深
 * @return {Array}
 */
function flattenArray(arr, depth = Infinity) {
    const result = [];

    for (const item of arr) {
        if (Array.isArray(item) && depth > 0) {
            // 递归处理嵌套数组
            result.push(...flattenArray(item, depth - 1));
        } else {
            result.push(item);
        }
    }

    return result;
}

// 测试用例
console.log(flattenArray([1, [2, 3], [4, [5, 6]], 7]));
// [1, 2, 3, 4, 5, 6, 7]

console.log(flattenArray([1, [2, [3, [4]]]], 2));
// [1, 2, 3, [4]]
```

**💡 解法二: 迭代实现**
```javascript
/**
 * 迭代方式扁平化数组
 * @param {Array} arr
 * @return {Array}
 */
function flattenIterative(arr) {
    const result = [];
    const stack = [...arr];

    while (stack.length > 0) {
        const next = stack.pop();

        if (Array.isArray(next)) {
            // 将数组元素重新压入栈中
            stack.push(...next);
        } else {
            result.push(next);
        }
    }

    // 因为是用栈实现，需要反转结果
    return result.reverse();
}

// 测试
console.log(flattenIterative([1, [2, 3], [4, [5, 6]], 7]));
// [1, 2, 3, 4, 5, 6, 7]
```

**💡 解法三: 使用原生方法**
```javascript
/**
 * 使用ES2019的flat方法
 * @param {Array} arr
 * @param {number} depth
 * @return {Array}
 */
function flattenNative(arr, depth = Infinity) {
    return arr.flat(depth);
}

// reduce方法实现
function flattenReduce(arr) {
    return arr.reduce((acc, val) =>
        Array.isArray(val) ? acc.concat(flattenReduce(val)) : acc.concat(val), []
    );
}

// 测试
console.log(flattenNative([1, [2, [3, [4]]]], 2)); // [1, 2, 3, [4]]
console.log(flattenReduce([1, [2, 3], [4, [5, 6]], 7])); // [1, 2, 3, 4, 5, 6, 7]
```

**⚡ 复杂度分析**:
- 递归方法: O(n) 时间，O(d) 空间 (d为最大深度)
- 迭代方法: O(n) 时间，O(n) 空间
- 原生方法: O(n) 时间，O(n) 空间

---

### 4. 最大子数组和 (Maximum Subarray)

**🎯 题目描述**:
给定一个整数数组，找到一个具有最大和的连续子数组，返回其最大和。

**📝 示例**:
```javascript
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6
```

**💡 解法一: 动态规划(Kadane算法)**
```javascript
/**
 * Kadane算法求最大子数组和
 * @param {number[]} nums
 * @return {number}
 */
function maxSubArray(nums) {
    if (nums.length === 0) return 0;

    let maxSoFar = nums[0]; // 全局最大值
    let maxEndingHere = nums[0]; // 以当前位置结尾的最大值

    for (let i = 1; i < nums.length; i++) {
        // 选择：继续之前的子数组 或 从当前位置重新开始
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// 测试用例
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); // 6
console.log(maxSubArray([1])); // 1
console.log(maxSubArray([5,4,-1,7,8])); // 23
```

**💡 解法二: 返回子数组位置**
```javascript
/**
 * 返回最大子数组和及其位置
 * @param {number[]} nums
 * @return {Object}
 */
function maxSubArrayWithPosition(nums) {
    if (nums.length === 0) return { sum: 0, start: -1, end: -1 };

    let maxSum = nums[0];
    let currentSum = nums[0];
    let start = 0, end = 0, tempStart = 0;

    for (let i = 1; i < nums.length; i++) {
        if (currentSum < 0) {
            // 重新开始
            currentSum = nums[i];
            tempStart = i;
        } else {
            // 继续累加
            currentSum += nums[i];
        }

        if (currentSum > maxSum) {
            maxSum = currentSum;
            start = tempStart;
            end = i;
        }
    }

    return {
        sum: maxSum,
        start: start,
        end: end,
        subarray: nums.slice(start, end + 1)
    };
}

// 测试
console.log(maxSubArrayWithPosition([-2,1,-3,4,-1,2,1,-5,4]));
// { sum: 6, start: 3, end: 6, subarray: [4, -1, 2, 1] }
```

**⚡ 复杂度分析**:
- 时间复杂度: O(n) - 只需一次遍历
- 空间复杂度: O(1) - 只使用常数额外空间

**🔍 算法思路**:
Kadane算法的核心思想是在每个位置做出最优选择：
1. 继续之前的子数组(加上当前元素)
2. 从当前位置重新开始一个新的子数组

---

## 🔤 字符串算法

> **重要程度**: ⭐⭐⭐⭐ | **出现频率**: 70%+

### 1. 回文字符串判断

**🎯 题目描述**:
判断给定字符串是否为回文字符串。回文字符串是指正着读和倒着读都一样的字符串。

**📝 示例**:
```javascript
输入: "A man a plan a canal Panama"
输出: true (忽略空格和大小写)
```

**💡 解法一: 双指针法**
```javascript
/**
 * 判断字符串是否为回文
 * @param {string} s
 * @return {boolean}
 */
function isPalindrome(s) {
    // 预处理：转小写，只保留字母和数字
    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');

    let left = 0;
    let right = cleaned.length - 1;

    while (left < right) {
        if (cleaned[left] !== cleaned[right]) {
            return false;
        }
        left++;
        right--;
    }

    return true;
}

// 测试用例
console.log(isPalindrome("A man a plan a canal Panama")); // true
console.log(isPalindrome("race a car")); // false
console.log(isPalindrome("Was it a car or a cat I saw?")); // true
```

**💡 解法二: 不预处理的优化版本**
```javascript
/**
 * 不预处理字符串的回文判断
 * @param {string} s
 * @return {boolean}
 */
function isPalindromeOptimized(s) {
    let left = 0;
    let right = s.length - 1;

    while (left < right) {
        // 跳过非字母数字字符
        while (left < right && !isAlphaNumeric(s[left])) {
            left++;
        }
        while (left < right && !isAlphaNumeric(s[right])) {
            right--;
        }

        // 比较字符（忽略大小写）
        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}

function isAlphaNumeric(char) {
    return /[a-zA-Z0-9]/.test(char);
}

// 测试
console.log(isPalindromeOptimized("A man a plan a canal Panama")); // true
```

**💡 解法三: 最长回文子串**
```javascript
/**
 * 找到字符串中最长的回文子串
 * @param {string} s
 * @return {string}
 */
function longestPalindrome(s) {
    if (s.length < 2) return s;

    let start = 0;
    let maxLen = 1;

    // 中心扩展法
    function expandAroundCenter(left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            const currentLen = right - left + 1;
            if (currentLen > maxLen) {
                start = left;
                maxLen = currentLen;
            }
            left--;
            right++;
        }
    }

    for (let i = 0; i < s.length; i++) {
        // 检查奇数长度的回文（以i为中心）
        expandAroundCenter(i, i);
        // 检查偶数长度的回文（以i和i+1为中心）
        expandAroundCenter(i, i + 1);
    }

    return s.substring(start, start + maxLen);
}

// 测试
console.log(longestPalindrome("babad")); // "bab" 或 "aba"
console.log(longestPalindrome("cbbd")); // "bb"
```

**⚡ 复杂度分析**:
- 双指针判断: O(n) 时间，O(1) 空间
- 最长回文子串: O(n²) 时间，O(1) 空间

---

### 2. 有效的括号 (Valid Parentheses)

**🎯 题目描述**:
给定一个只包含 `'('`、`')'`、`'{'`、`'}'`、`'['`、`']'` 的字符串，判断字符串是否有效。

**📝 示例**:
```javascript
输入: "()[]{}"
输出: true

输入: "([)]"
输出: false
```

**💡 解法: 栈匹配**
```javascript
/**
 * 判断括号字符串是否有效
 * @param {string} s
 * @return {boolean}
 */
function isValidParentheses(s) {
    const stack = [];
    const mapping = {
        ')': '(',
        '}': '{',
        ']': '['
    };

    for (const char of s) {
        if (char === '(' || char === '{' || char === '[') {
            // 左括号入栈
            stack.push(char);
        } else if (char === ')' || char === '}' || char === ']') {
            // 右括号检查匹配
            if (stack.length === 0 || stack.pop() !== mapping[char]) {
                return false;
            }
        }
    }

    // 栈为空说明所有括号都匹配
    return stack.length === 0;
}

// 测试用例
console.log(isValidParentheses("()")); // true
console.log(isValidParentheses("()[]{}")); // true
console.log(isValidParentheses("(]")); // false
console.log(isValidParentheses("([)]")); // false
console.log(isValidParentheses("{[]}")); // true
```

**💡 扩展: 括号序列补全**
```javascript
/**
 * 计算使括号序列有效需要添加的最少括号数
 * @param {string} s
 * @return {number}
 */
function minAddToMakeValid(s) {
    let left = 0; // 需要右括号的数量
    let right = 0; // 需要左括号的数量

    for (const char of s) {
        if (char === '(') {
            left++;
        } else if (char === ')') {
            if (left > 0) {
                left--; // 匹配了一个左括号
            } else {
                right++; // 需要一个左括号来匹配
            }
        }
    }

    return left + right;
}

// 测试
console.log(minAddToMakeValid("())")); // 1
console.log(minAddToMakeValid("(((")); // 3
console.log(minAddToMakeValid("())")); // 1
```

**⚡ 复杂度分析**:
- 时间复杂度: O(n) - 需要遍历整个字符串
- 空间复杂度: O(n) - 最坏情况下栈存储所有左括号

---

## 🔗 链表算法

> **重要程度**: ⭐⭐⭐⭐ | **出现频率**: 60%+

### 1. 反转链表 (Reverse Linked List)

**🎯 题目描述**:
反转一个单链表。

**📝 示例**:
```javascript
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**💡 链表节点定义**:
```javascript
/**
 * 链表节点定义
 */
class ListNode {
    constructor(val, next) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}
```

**💡 解法一: 迭代法**
```javascript
/**
 * 迭代方式反转链表
 * @param {ListNode} head
 * @return {ListNode}
 */
function reverseListIterative(head) {
    let prev = null;
    let current = head;

    while (current !== null) {
        // 保存下一个节点
        const nextTemp = current.next;
        // 反转当前节点的指针
        current.next = prev;
        // 移动指针
        prev = current;
        current = nextTemp;
    }

    return prev; // prev成为新的头节点
}
```

**💡 解法二: 递归法**
```javascript
/**
 * 递归方式反转链表
 * @param {ListNode} head
 * @return {ListNode}
 */
function reverseListRecursive(head) {
    // 基础情况
    if (head === null || head.next === null) {
        return head;
    }

    // 递归反转后面的链表
    const reversedHead = reverseListRecursive(head.next);

    // 反转当前连接
    head.next.next = head;
    head.next = null;

    return reversedHead;
}
```

**💡 解法三: 反转部分链表**
```javascript
/**
 * 反转链表的第left到right部分
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
function reverseBetween(head, left, right) {
    if (left === right) return head;

    // 创建虚拟头节点
    const dummy = new ListNode(0);
    dummy.next = head;

    // 找到反转起始位置的前一个节点
    let pre = dummy;
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 反转从left到right的部分
    let start = pre.next;
    let then = start.next;

    for (let i = 0; i < right - left; i++) {
        start.next = then.next;
        then.next = pre.next;
        pre.next = then;
        then = start.next;
    }

    return dummy.next;
}
```

**🧪 测试代码**:
```javascript
// 创建测试链表: 1->2->3->4->5
function createLinkedList(arr) {
    const dummy = new ListNode(0);
    let current = dummy;
    for (const val of arr) {
        current.next = new ListNode(val);
        current = current.next;
    }
    return dummy.next;
}

// 打印链表
function printLinkedList(head) {
    const result = [];
    let current = head;
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    return result.join('->');
}

// 测试
const list = createLinkedList([1, 2, 3, 4, 5]);
console.log("原链表:", printLinkedList(list)); // 1->2->3->4->5

const reversed = reverseListIterative(list);
console.log("反转后:", printLinkedList(reversed)); // 5->4->3->2->1
```

**⚡ 复杂度分析**:
- 迭代法: O(n) 时间，O(1) 空间
- 递归法: O(n) 时间，O(n) 空间

---

### 2. 合并两个有序链表

**🎯 题目描述**:
将两个升序链表合并为一个新的升序链表并返回。

**📝 示例**:
```javascript
输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
```

**💡 解法一: 迭代法**
```javascript
/**
 * 合并两个有序链表
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function mergeTwoLists(list1, list2) {
    // 创建虚拟头节点
    const dummy = new ListNode(0);
    let current = dummy;

    // 比较两个链表的节点值
    while (list1 !== null && list2 !== null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }

    // 连接剩余的节点
    current.next = list1 || list2;

    return dummy.next;
}
```

**💡 解法二: 递归法**
```javascript
/**
 * 递归合并两个有序链表
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function mergeTwoListsRecursive(list1, list2) {
    // 基础情况
    if (list1 === null) return list2;
    if (list2 === null) return list1;

    // 递归选择较小的节点
    if (list1.val <= list2.val) {
        list1.next = mergeTwoListsRecursive(list1.next, list2);
        return list1;
    } else {
        list2.next = mergeTwoListsRecursive(list1, list2.next);
        return list2;
    }
}
```

**💡 扩展: 合并K个有序链表**
```javascript
/**
 * 合并K个有序链表
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
function mergeKLists(lists) {
    if (lists.length === 0) return null;

    // 分治法合并
    while (lists.length > 1) {
        const mergedLists = [];

        for (let i = 0; i < lists.length; i += 2) {
            const l1 = lists[i];
            const l2 = i + 1 < lists.length ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(l1, l2));
        }

        lists = mergedLists;
    }

    return lists[0];
}
```

**⚡ 复杂度分析**:
- 合并两个链表: O(m + n) 时间，O(1) 空间
- 合并K个链表: O(n log k) 时间，O(1) 空间

---

## 🌳 树算法

> **重要程度**: ⭐⭐⭐⭐ | **出现频率**: 65%+

### 1. 二叉树遍历

**🎯 题目描述**:
实现二叉树的前序、中序、后序遍历，包括递归和迭代两种方式。

**💡 二叉树节点定义**:
```javascript
/**
 * 二叉树节点定义
 */
class TreeNode {
    constructor(val, left, right) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}
```

**💡 前序遍历 (根-左-右)**
```javascript
/**
 * 前序遍历 - 递归
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversalRecursive(root) {
    const result = [];

    function preorder(node) {
        if (node === null) return;

        result.push(node.val); // 根
        preorder(node.left);   // 左
        preorder(node.right);  // 右
    }

    preorder(root);
    return result;
}

/**
 * 前序遍历 - 迭代
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversalIterative(root) {
    if (root === null) return [];

    const result = [];
    const stack = [root];

    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);

        // 先压右子树，再压左子树（栈的特性）
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }

    return result;
}
```

**💡 中序遍历 (左-根-右)**
```javascript
/**
 * 中序遍历 - 递归
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversalRecursive(root) {
    const result = [];

    function inorder(node) {
        if (node === null) return;

        inorder(node.left);    // 左
        result.push(node.val); // 根
        inorder(node.right);   // 右
    }

    inorder(root);
    return result;
}

/**
 * 中序遍历 - 迭代
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversalIterative(root) {
    const result = [];
    const stack = [];
    let current = root;

    while (current !== null || stack.length > 0) {
        // 一直走到最左边
        while (current !== null) {
            stack.push(current);
            current = current.left;
        }

        // 处理当前节点
        current = stack.pop();
        result.push(current.val);

        // 转向右子树
        current = current.right;
    }

    return result;
}
```

**💡 后序遍历 (左-右-根)**
```javascript
/**
 * 后序遍历 - 递归
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversalRecursive(root) {
    const result = [];

    function postorder(node) {
        if (node === null) return;

        postorder(node.left);  // 左
        postorder(node.right); // 右
        result.push(node.val); // 根
    }

    postorder(root);
    return result;
}

/**
 * 后序遍历 - 迭代
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversalIterative(root) {
    if (root === null) return [];

    const result = [];
    const stack = [root];

    while (stack.length > 0) {
        const node = stack.pop();
        result.unshift(node.val); // 插入到结果数组开头

        // 先压左子树，再压右子树
        if (node.left) stack.push(node.left);
        if (node.right) stack.push(node.right);
    }

    return result;
}
```

**💡 层序遍历 (广度优先)**
```javascript
/**
 * 层序遍历
 * @param {TreeNode} root
 * @return {number[][]}
 */
function levelOrder(root) {
    if (root === null) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }

        result.push(currentLevel);
    }

    return result;
}
```

**🧪 测试代码**:
```javascript
// 创建测试树:     1
//               / \
//              2   3
//             / \
//            4   5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log("前序遍历:", preorderTraversalRecursive(root)); // [1, 2, 4, 5, 3]
console.log("中序遍历:", inorderTraversalRecursive(root));  // [4, 2, 5, 1, 3]
console.log("后序遍历:", postorderTraversalRecursive(root)); // [4, 5, 2, 3, 1]
console.log("层序遍历:", levelOrder(root)); // [[1], [2, 3], [4, 5]]
```

---

### 2. 二叉树最大深度

**🎯 题目描述**:
给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**💡 解法一: 递归**
```javascript
/**
 * 计算二叉树最大深度 - 递归
 * @param {TreeNode} root
 * @return {number}
 */
function maxDepth(root) {
    if (root === null) return 0;

    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);

    return Math.max(leftDepth, rightDepth) + 1;
}
```

**💡 解法二: 迭代(层序遍历)**
```javascript
/**
 * 计算二叉树最大深度 - 迭代
 * @param {TreeNode} root
 * @return {number}
 */
function maxDepthIterative(root) {
    if (root === null) return 0;

    const queue = [root];
    let depth = 0;

    while (queue.length > 0) {
        const levelSize = queue.length;
        depth++;

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
    }

    return depth;
}
```

**💡 相关题目: 最小深度**
```javascript
/**
 * 计算二叉树最小深度
 * @param {TreeNode} root
 * @return {number}
 */
function minDepth(root) {
    if (root === null) return 0;

    // 如果只有一个子树，返回非空子树的深度+1
    if (root.left === null) return minDepth(root.right) + 1;
    if (root.right === null) return minDepth(root.left) + 1;

    // 两个子树都存在，返回较小深度+1
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

**⚡ 复杂度分析**:
- 递归方法: O(n) 时间，O(h) 空间 (h为树的高度)
- 迭代方法: O(n) 时间，O(w) 空间 (w为树的最大宽度)

---

## 🔄 动态规划

> **重要程度**: ⭐⭐⭐⭐ | **出现频率**: 50%+

### 1. 爬楼梯 (Climbing Stairs)

**🎯 题目描述**:
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**📝 示例**:
```javascript
输入: n = 3
输出: 3
解释: 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**💡 解法一: 动态规划**
```javascript
/**
 * 爬楼梯 - 动态规划
 * @param {number} n
 * @return {number}
 */
function climbStairs(n) {
    if (n <= 2) return n;

    // dp[i] 表示爬到第i层的方法数
    const dp = new Array(n + 1);
    dp[1] = 1; // 爬到第1层只有1种方法
    dp[2] = 2; // 爬到第2层有2种方法

    for (let i = 3; i <= n; i++) {
        // 状态转移方程: dp[i] = dp[i-1] + dp[i-2]
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

**💡 解法二: 空间优化**
```javascript
/**
 * 爬楼梯 - 空间优化版本
 * @param {number} n
 * @return {number}
 */
function climbStairsOptimized(n) {
    if (n <= 2) return n;

    let prev2 = 1; // dp[i-2]
    let prev1 = 2; // dp[i-1]
    let current;

    for (let i = 3; i <= n; i++) {
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }

    return current;
}
```

**💡 解法三: 斐波那契数列公式**
```javascript
/**
 * 爬楼梯 - 数学公式法（黄金分割比）
 * @param {number} n
 * @return {number}
 */
function climbStairsMath(n) {
    const sqrt5 = Math.sqrt(5);
    const phi = (1 + sqrt5) / 2;
    const psi = (1 - sqrt5) / 2;

    return Math.round((Math.pow(phi, n + 1) - Math.pow(psi, n + 1)) / sqrt5);
}
```

**💡 扩展: 每次可以爬1、2、3个台阶**
```javascript
/**
 * 每次可以爬1、2、3个台阶
 * @param {number} n
 * @return {number}
 */
function climbStairsThreeSteps(n) {
    if (n === 0) return 1;
    if (n === 1) return 1;
    if (n === 2) return 2;

    const dp = new Array(n + 1);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;

    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}
```

**🧪 测试代码**:
```javascript
// 测试用例
console.log(climbStairs(1)); // 1
console.log(climbStairs(2)); // 2
console.log(climbStairs(3)); // 3
console.log(climbStairs(4)); // 5
console.log(climbStairs(5)); // 8

// 性能对比
console.time('DP');
console.log(climbStairs(45));
console.timeEnd('DP');

console.time('Optimized');
console.log(climbStairsOptimized(45));
console.timeEnd('Optimized');
```

**⚡ 复杂度分析**:
- 动态规划: O(n) 时间，O(n) 空间
- 空间优化: O(n) 时间，O(1) 空间
- 数学公式: O(1) 时间，O(1) 空间

---

### 2. 打家劫舍 (House Robber)

**🎯 题目描述**:
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

**📝 示例**:
```javascript
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**💡 解法一: 动态规划**
```javascript
/**
 * 打家劫舍 - 动态规划
 * @param {number[]} nums
 * @return {number}
 */
function rob(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];

    const dp = new Array(nums.length);
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (let i = 2; i < nums.length; i++) {
        // 选择偷或不偷当前房屋的最大值
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    return dp[nums.length - 1];
}
```

**💡 解法二: 空间优化**
```javascript
/**
 * 打家劫舍 - 空间优化
 * @param {number[]} nums
 * @return {number}
 */
function robOptimized(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];

    let prev2 = nums[0];              // dp[i-2]
    let prev1 = Math.max(nums[0], nums[1]); // dp[i-1]

    for (let i = 2; i < nums.length; i++) {
        const current = Math.max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}
```

**💡 解法三: 更简洁的写法**
```javascript
/**
 * 打家劫舍 - 简洁版本
 * @param {number[]} nums
 * @return {number}
 */
function robSimple(nums) {
    let rob = 0;    // 偷当前房子的最大收益
    let notRob = 0; // 不偷当前房子的最大收益

    for (const num of nums) {
        const temp = rob;
        rob = notRob + num;     // 偷当前房子：之前不偷的收益 + 当前房子
        notRob = Math.max(temp, notRob); // 不偷当前房子：之前偷和不偷的最大值
    }

    return Math.max(rob, notRob);
}
```

**💡 扩展: 打家劫舍II (环形排列)**
```javascript
/**
 * 打家劫舍II - 房屋排成环形
 * @param {number[]} nums
 * @return {number}
 */
function robCircular(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];
    if (nums.length === 2) return Math.max(nums[0], nums[1]);

    // 分为两种情况：偷第一个房子和不偷第一个房子
    function robLinear(arr) {
        let prev2 = 0, prev1 = 0;
        for (const num of arr) {
            const temp = prev1;
            prev1 = Math.max(prev1, prev2 + num);
            prev2 = temp;
        }
        return prev1;
    }

    // 情况1：偷第一个房子，不能偷最后一个房子
    const case1 = robLinear(nums.slice(0, nums.length - 1));

    // 情况2：不偷第一个房子，可以偷最后一个房子
    const case2 = robLinear(nums.slice(1));

    return Math.max(case1, case2);
}
```

**🧪 测试代码**:
```javascript
// 测试用例
console.log(rob([1, 2, 3, 1])); // 4
console.log(rob([2, 7, 9, 3, 1])); // 12
console.log(rob([2, 1, 1, 2])); // 4

// 环形测试
console.log(robCircular([2, 3, 2])); // 3
console.log(robCircular([1, 2, 3, 1])); // 4
```

**⚡ 复杂度分析**:
- 时间复杂度: O(n) - 需要遍历所有房屋
- 空间复杂度: O(1) - 只使用常数额外空间

---

## 🔍 搜索与回溯

> **重要程度**: ⭐⭐⭐ | **出现频率**: 40%+

### 1. 二分查找及变体

**🎯 题目描述**:
在排序数组中查找目标值，返回其索引。如果目标值不存在于数组中，返回 -1。

**💡 基础二分查找**
```javascript
/**
 * 二分查找基础版本
 * @param {number[]} nums - 有序数组
 * @param {number} target - 目标值
 * @return {number} - 目标值的索引，不存在返回-1
 */
function binarySearch(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```

**💡 查找第一个和最后一个位置**
```javascript
/**
 * 在排序数组中查找元素的第一个和最后一个位置
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function searchRange(nums, target) {
    // 查找左边界
    function findLeft(nums, target) {
        let left = 0, right = nums.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (nums[mid] === target) {
                result = mid;
                right = mid - 1; // 继续向左查找
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    // 查找右边界
    function findRight(nums, target) {
        let left = 0, right = nums.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (nums[mid] === target) {
                result = mid;
                left = mid + 1; // 继续向右查找
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    const leftBound = findLeft(nums, target);
    const rightBound = findRight(nums, target);

    return [leftBound, rightBound];
}

// 测试
console.log(searchRange([5,7,7,8,8,10], 8)); // [3, 4]
console.log(searchRange([5,7,7,8,8,10], 6)); // [-1, -1]
```

**💡 搜索旋转排序数组**
```javascript
/**
 * 搜索旋转排序数组
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
function searchRotated(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }

        // 判断哪一半是有序的
        if (nums[left] <= nums[mid]) {
            // 左半部分有序
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // 右半部分有序
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// 测试
console.log(searchRotated([4,5,6,7,0,1,2], 0)); // 4
console.log(searchRotated([4,5,6,7,0,1,2], 3)); // -1
```

---

### 2. 全排列 (Permutations)

**🎯 题目描述**:
给定一个不含重复数字的数组，返回其所有可能的全排列。

**📝 示例**:
```javascript
输入: [1,2,3]
输出: [
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**💡 解法一: 回溯算法**
```javascript
/**
 * 全排列 - 回溯算法
 * @param {number[]} nums
 * @return {number[][]}
 */
function permute(nums) {
    const result = [];
    const path = [];
    const used = new Array(nums.length).fill(false);

    function backtrack() {
        // 终止条件：路径长度等于数组长度
        if (path.length === nums.length) {
            result.push([...path]); // 拷贝当前路径
            return;
        }

        // 选择列表：所有未使用的数字
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue; // 跳过已使用的数字

            // 做选择
            path.push(nums[i]);
            used[i] = true;

            // 递归
            backtrack();

            // 撤销选择
            path.pop();
            used[i] = false;
        }
    }

    backtrack();
    return result;
}
```

**💡 解法二: 交换法**
```javascript
/**
 * 全排列 - 交换法
 * @param {number[]} nums
 * @return {number[][]}
 */
function permuteSwap(nums) {
    const result = [];

    function backtrack(start) {
        // 终止条件
        if (start === nums.length) {
            result.push([...nums]);
            return;
        }

        for (let i = start; i < nums.length; i++) {
            // 交换
            [nums[start], nums[i]] = [nums[i], nums[start]];

            // 递归
            backtrack(start + 1);

            // 撤销交换
            [nums[start], nums[i]] = [nums[i], nums[start]];
        }
    }

    backtrack(0);
    return result;
}
```

**💡 扩展: 包含重复数字的全排列**
```javascript
/**
 * 全排列 II - 包含重复数字
 * @param {number[]} nums
 * @return {number[][]}
 */
function permuteUnique(nums) {
    const result = [];
    const path = [];
    const used = new Array(nums.length).fill(false);

    // 排序以便处理重复元素
    nums.sort((a, b) => a - b);

    function backtrack() {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;

            // 跳过重复元素：如果当前元素与前一个元素相同，且前一个元素未使用
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
                continue;
            }

            path.push(nums[i]);
            used[i] = true;

            backtrack();

            path.pop();
            used[i] = false;
        }
    }

    backtrack();
    return result;
}
```

**🧪 测试代码**:
```javascript
// 测试全排列
console.log(permute([1, 2, 3]));
// [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

// 测试包含重复数字的全排列
console.log(permuteUnique([1, 1, 2]));
// [[1,1,2],[1,2,1],[2,1,1]]
```

**⚡ 复杂度分析**:
- 时间复杂度: O(n! × n) - n!种排列，每种需要O(n)时间复制
- 空间复杂度: O(n) - 递归调用栈的深度

---

## 🎯 面试技巧

### 📝 答题框架

**标准答题流程**:
1. **理解题意** (30秒)
   - 复述题目要求
   - 确认输入输出格式
   - 询问边界条件

2. **分析思路** (1-2分钟)
   - 从暴力解法开始思考
   - 分析时间空间复杂度
   - 寻找优化方案

3. **编码实现** (5-10分钟)
   - 先写主要逻辑
   - 处理边界情况
   - 添加必要注释

4. **测试验证** (1-2分钟)
   - 走查关键测试用例
   - 检查边界情况
   - 分析复杂度

### 🎯 常见考察点

**算法思维**:
- 时间复杂度优化意识
- 空间复杂度权衡
- 边界条件处理
- 代码健壮性

**工程能力**:
- 代码可读性
- 变量命名规范
- 逻辑结构清晰
- 错误处理

**JavaScript特色**:
- 数组方法的熟练运用
- 对象和Map的使用场景
- 递归vs迭代的选择
- 内存管理意识

### 💡 优化技巧

**常见优化方向**:
1. **哈希表优化查找**: O(n) → O(1)
2. **双指针减少空间**: O(n) → O(1)
3. **动态规划避免重复计算**: O(2^n) → O(n)
4. **分治法降低复杂度**: O(n²) → O(n log n)

**JavaScript优化技巧**:
```javascript
// 使用Map而非对象做哈希表
const map = new Map(); // 优于 const obj = {};

// 利用数组解构交换变量
[a, b] = [b, a]; // 优于 temp = a; a = b; b = temp;

// 使用展开运算符复制数组
const copy = [...arr]; // 优于 const copy = arr.slice();

// 使用短路运算符处理默认值
const result = input || defaultValue;
```

### 🚨 常见陷阱

**面试中要避免的错误**:
1. **直接写代码**: 不分析直接coding
2. **忽略边界条件**: 空数组、单元素等
3. **变量命名混乱**: i、j、k满天飞
4. **复杂度分析错误**: 估算不准确
5. **测试用例不全**: 只考虑正常情况

---

## 🎓 总结

这份算法面试题集涵盖了前端开发中最常考的算法类型。通过系统学习和练习，你将能够：

### 🎯 核心收获
1. **算法思维**: 培养分析问题和设计解决方案的能力
2. **编码技巧**: 掌握JavaScript中常用的算法实现模式
3. **优化意识**: 理解时间空间复杂度的权衡
4. **面试技能**: 掌握标准的算法题解答流程

### 📈 学习建议
1. **循序渐进**: 从简单题目开始，逐步提高难度
2. **动手实践**: 每道题都要亲自实现一遍
3. **举一反三**: 思考题目的变形和扩展
4. **定期复习**: 算法需要反复练习才能熟练

### 🚀 进阶方向
- **高级数据结构**: 堆、图、字典树等
- **高级算法**: 贪心、分治、图算法等
- **系统设计**: 大规模数据处理、分布式算法
- **实际应用**: 将算法思维运用到实际项目中

记住，算法学习不仅是为了面试，更重要的是培养**逻辑思维能力**和**问题解决能力**。这些技能将在你的整个编程生涯中发挥重要作用！

继续努力，祝你在算法学习的路上越走越远！🎯