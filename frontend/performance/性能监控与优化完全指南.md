# ğŸš€ å‰ç«¯æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–å®Œå…¨æŒ‡å—

## ğŸ¯ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥è§£æå‰ç«¯æ€§èƒ½ç›‘æ§çš„å®Œæ•´ä½“ç³»ï¼Œæ¶µç›–ä»åŸºç¡€æ¦‚å¿µåˆ°ä¼ä¸šçº§å®è·µçš„å…¨æ–¹ä½å†…å®¹ã€‚é€‚åˆå‡†å¤‡å¤§å‚é¢è¯•çš„èµ„æ·±å‰ç«¯å·¥ç¨‹å¸ˆå­¦ä¹ å‚è€ƒã€‚

## ğŸ“‹ ç›®å½•

1. [Web Vitals æ ¸å¿ƒæŒ‡æ ‡è¯¦è§£](#web-vitals-æ ¸å¿ƒæŒ‡æ ‡è¯¦è§£)
2. [æ€§èƒ½ç›‘æ§å®ç°åŸç†](#æ€§èƒ½ç›‘æ§å®ç°åŸç†)
3. [çœŸå®ç”¨æˆ·ç›‘æ§vsåˆæˆç›‘æ§](#çœŸå®ç”¨æˆ·ç›‘æ§vsåˆæˆç›‘æ§)
4. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ä½“ç³»](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ä½“ç³»)
5. [ä¼ä¸šçº§ç›‘æ§æ–¹æ¡ˆ](#ä¼ä¸šçº§ç›‘æ§æ–¹æ¡ˆ)
6. [é¢è¯•é«˜é¢‘è€ƒç‚¹](#é¢è¯•é«˜é¢‘è€ƒç‚¹)

---

## ğŸ¯ Web Vitals æ ¸å¿ƒæŒ‡æ ‡è¯¦è§£

### æ ¸å¿ƒæ¦‚å¿µç†è§£

Google çš„ Core Web Vitals ä»£è¡¨äº†ç”¨æˆ·ä½“éªŒçš„å…³é”®ç»´åº¦ï¼š**åŠ è½½æ€§èƒ½**ã€**äº¤äº’æ€§èƒ½**ã€**è§†è§‰ç¨³å®šæ€§**ã€‚

#### LCP (Largest Contentful Paint) - æœ€å¤§å†…å®¹ç»˜åˆ¶

**æŠ€æœ¯å®šä¹‰**ï¼šé¡µé¢ä¸»è¦å†…å®¹å®Œæˆæ¸²æŸ“çš„æ—¶é—´ç‚¹
- **ä¼˜ç§€æ ‡å‡†**ï¼šâ‰¤ 2.5ç§’
- **éœ€è¦æ”¹è¿›**ï¼š2.5-4ç§’
- **å·®**ï¼š> 4ç§’

**ç›‘æ§å®ç°**ï¼š
```javascript
function observeLCP() {
  const observer = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];

    sendMetric({
      name: 'LCP',
      value: lastEntry.startTime,
      element: lastEntry.element?.tagName,
      url: location.href
    });
  });

  observer.observe({ entryTypes: ['largest-contentful-paint'] });
}
```

**ä¼˜åŒ–ç­–ç•¥**ï¼š
1. **æœåŠ¡å™¨å“åº”ä¼˜åŒ–**ï¼šå‡å°‘ TTFB
2. **èµ„æºä¼˜å…ˆçº§**ï¼šå…³é”®èµ„æºé¢„åŠ è½½
3. **å›¾ç‰‡ä¼˜åŒ–**ï¼šWebPæ ¼å¼ã€å“åº”å¼å›¾ç‰‡
4. **ä»£ç åˆ†å‰²**ï¼šå‡å°‘é˜»å¡èµ„æº

#### INP (Interaction to Next Paint) - äº¤äº’åˆ°ä¸‹æ¬¡ç»˜åˆ¶

**èƒŒæ™¯**ï¼šINP æ›¿ä»£äº† FIDï¼Œæ›´å‡†ç¡®è¡¡é‡é¡µé¢äº¤äº’å“åº”æ€§
- **ä¼˜ç§€æ ‡å‡†**ï¼šâ‰¤ 200ms
- **éœ€è¦æ”¹è¿›**ï¼š200-500ms
- **å·®**ï¼š> 500ms

**ç›‘æ§æ–¹æ¡ˆ**ï¼š
```javascript
function observeINP() {
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      const interactionTime = entry.processingEnd - entry.startTime;

      if (interactionTime > 40) { // åªè®°å½•è¾ƒæ…¢çš„äº¤äº’
        sendMetric({
          name: 'INP',
          value: interactionTime,
          interactionType: entry.name,
          targetElement: entry.target?.tagName
        });
      }
    }
  });

  observer.observe({ entryTypes: ['event'] });
}
```

#### CLS (Cumulative Layout Shift) - ç´¯ç§¯å¸ƒå±€åç§»

**æŠ€æœ¯åŸç†**ï¼šæµ‹é‡é¡µé¢ç”Ÿå‘½å‘¨æœŸå†…æ‰€æœ‰æ„å¤–å¸ƒå±€å˜åŒ–çš„ç´¯ç§¯åˆ†æ•°
- **ä¼˜ç§€æ ‡å‡†**ï¼šâ‰¤ 0.1
- **éœ€è¦æ”¹è¿›**ï¼š0.1-0.25
- **å·®**ï¼š> 0.25

**å¸ƒå±€åç§»è®¡ç®—**ï¼š
```
CLS = å½±å“åŒºåŸŸæ¯”ä¾‹ Ã— è·ç¦»æ¯”ä¾‹
```

**é¢„é˜²ç­–ç•¥**ï¼š
1. **å›¾ç‰‡å°ºå¯¸é¢„è®¾**ï¼šå§‹ç»ˆè®¾ç½® width/height
2. **å­—ä½“åŠ è½½ä¼˜åŒ–**ï¼šfont-display: swap
3. **åŠ¨æ€å†…å®¹æ’å…¥**ï¼šä¸ºæ–°å†…å®¹é¢„ç•™ç©ºé—´
4. **å¹¿å‘Šä½å›ºå®š**ï¼šé¿å…åŠ¨æ€å¹¿å‘Šæ¨æŒ¤å†…å®¹

---

## âš™ï¸ æ€§èƒ½ç›‘æ§å®ç°åŸç†

### Performance API æ·±åº¦åº”ç”¨

#### å®Œæ•´ç›‘æ§ SDK æ¶æ„

```javascript
class AdvancedPerformanceMonitor {
  constructor(config = {}) {
    this.config = {
      endpoint: config.endpoint || '/api/metrics',
      sampleRate: config.sampleRate || 1,
      batchSize: config.batchSize || 10,
      flushInterval: config.flushInterval || 30000,
      ...config
    };

    this.queue = [];
    this.sessionId = this.generateSessionId();
    this.startTime = performance.now();

    this.init();
  }

  init() {
    // æ ¸å¿ƒæŒ‡æ ‡ç›‘æ§
    this.observeCoreWebVitals();

    // èµ„æºåŠ è½½ç›‘æ§
    this.observeResources();

    // é•¿ä»»åŠ¡ç›‘æ§
    this.observeLongTasks();

    // å†…å­˜ç›‘æ§
    this.observeMemory();

    // ç”¨æˆ·äº¤äº’ç›‘æ§
    this.observeUserInteractions();

    // é¡µé¢ç”Ÿå‘½å‘¨æœŸ
    this.observePageLifecycle();

    // å®šæ—¶æ‰¹é‡å‘é€
    this.setupPeriodicFlush();
  }

  observeResources() {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        // è¿‡æ»¤å…³é”®èµ„æº
        if (this.isKeyResource(entry)) {
          this.addMetric('ResourceTiming', {
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize,
            type: entry.initiatorType,
            cached: entry.transferSize === 0
          });
        }
      }
    });

    observer.observe({ entryTypes: ['resource'] });
  }

  observeLongTasks() {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.addMetric('LongTask', {
          duration: entry.duration,
          startTime: entry.startTime,
          attribution: entry.attribution?.map(attr => ({
            name: attr.name,
            containerType: attr.containerType,
            containerSrc: attr.containerSrc
          }))
        });
      }
    });

    observer.observe({ entryTypes: ['longtask'] });
  }

  addMetric(name, value, tags = {}) {
    if (Math.random() > this.config.sampleRate) return;

    const metric = {
      name,
      value,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      url: location.href,
      userAgent: navigator.userAgent,
      connection: this.getConnectionInfo(),
      ...tags
    };

    this.queue.push(metric);

    if (this.queue.length >= this.config.batchSize) {
      this.flush();
    }
  }
}
```

### è®¾å¤‡ä¸ç½‘ç»œä¿¡æ¯é‡‡é›†

```javascript
class DeviceProfiler {
  static getDeviceInfo() {
    return {
      // å±å¹•ä¿¡æ¯
      screen: {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth
      },

      // è§†çª—ä¿¡æ¯
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
        devicePixelRatio: window.devicePixelRatio
      },

      // è®¾å¤‡èƒ½åŠ›
      capabilities: {
        cores: navigator.hardwareConcurrency || 'unknown',
        memory: navigator.deviceMemory || 'unknown',
        platform: navigator.platform,
        cookieEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine
      },

      // è®¾å¤‡ç±»å‹åˆ¤æ–­
      deviceType: this.getDeviceType()
    };
  }

  static getConnectionInfo() {
    if ('connection' in navigator) {
      const conn = navigator.connection;
      return {
        effectiveType: conn.effectiveType,
        downlink: conn.downlink,
        rtt: conn.rtt,
        saveData: conn.saveData,
        type: conn.type
      };
    }
    return null;
  }

  static getDeviceType() {
    const ua = navigator.userAgent;

    if (/tablet|ipad|playbook|silk/i.test(ua)) {
      return 'tablet';
    }

    if (/mobile|iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(ua)) {
      return 'mobile';
    }

    return 'desktop';
  }
}
```

---

## ğŸ” çœŸå®ç”¨æˆ·ç›‘æ§vsåˆæˆç›‘æ§

### RUM (Real User Monitoring) å®ç°

RUM æ”¶é›†çœŸå®ç”¨æˆ·çš„æ€§èƒ½æ•°æ®ï¼Œåæ˜ å®é™…ä½¿ç”¨åœºæ™¯ï¼š

```javascript
class RUMCollector {
  constructor() {
    this.userContext = {
      sessionId: this.generateSessionId(),
      userId: this.getUserId(),
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    };

    this.performanceBuffer = [];
    this.interactionBuffer = [];

    this.init();
  }

  init() {
    // é¡µé¢æ€§èƒ½æ”¶é›†
    this.collectPagePerformance();

    // ç”¨æˆ·è¡Œä¸ºæ”¶é›†
    this.collectUserBehavior();

    // é”™è¯¯ç›‘æ§
    this.collectErrors();

    // ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
    this.collectBusinessMetrics();
  }

  collectUserBehavior() {
    // ç‚¹å‡»è¡Œä¸ºæ€§èƒ½
    document.addEventListener('click', (e) => {
      const startTime = performance.now();

      // ä½¿ç”¨ requestIdleCallback é¿å…é˜»å¡
      requestIdleCallback(() => {
        const endTime = performance.now();
        const duration = endTime - startTime;

        this.addInteraction({
          type: 'click',
          duration,
          target: this.getElementPath(e.target),
          timestamp: Date.now()
        });
      });
    });

    // é¡µé¢æ»šåŠ¨æ€§èƒ½
    let scrollStartTime;
    let scrollEndTime;

    document.addEventListener('scroll', () => {
      if (!scrollStartTime) {
        scrollStartTime = performance.now();
      }

      clearTimeout(scrollEndTime);
      scrollEndTime = setTimeout(() => {
        const duration = performance.now() - scrollStartTime;

        this.addInteraction({
          type: 'scroll',
          duration,
          scrollY: window.scrollY,
          timestamp: Date.now()
        });

        scrollStartTime = null;
      }, 150);
    }, { passive: true });
  }

  getElementPath(element) {
    const path = [];
    while (element && element.nodeType === Node.ELEMENT_NODE) {
      let selector = element.nodeName.toLowerCase();

      if (element.id) {
        selector += `#${element.id}`;
        path.unshift(selector);
        break;
      } else if (element.className) {
        selector += `.${element.className.split(' ').join('.')}`;
      }

      path.unshift(selector);
      element = element.parentNode;
    }

    return path.join(' > ');
  }
}
```

### åˆæˆç›‘æ§ (Synthetic Monitoring)

ä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·æ¨¡æ‹Ÿç”¨æˆ·è¡Œä¸ºï¼Œè¿›è¡Œå®šæœŸç›‘æ§ï¼š

```javascript
// Node.js ç¯å¢ƒä¸‹çš„åˆæˆç›‘æ§
const puppeteer = require('puppeteer');

class SyntheticMonitor {
  constructor(config) {
    this.config = {
      frequency: config.frequency || 300000, // 5åˆ†é’Ÿ
      locations: config.locations || ['us-east', 'eu-west', 'asia-pacific'],
      devices: config.devices || ['desktop', 'mobile'],
      networkConditions: config.networkConditions || ['fast3g', 'slow3g'],
      ...config
    };
  }

  async runScheduledTests() {
    for (const location of this.config.locations) {
      for (const device of this.config.devices) {
        for (const network of this.config.networkConditions) {
          await this.runSingleTest({
            location,
            device,
            network,
            url: this.config.targetUrl
          });
        }
      }
    }
  }

  async runSingleTest({ location, device, network, url }) {
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();

    // è®¾å¤‡æ¨¡æ‹Ÿ
    if (device === 'mobile') {
      await page.setUserAgent('Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)...');
      await page.setViewport({ width: 375, height: 667 });
    }

    // ç½‘ç»œæ¡ä»¶æ¨¡æ‹Ÿ
    const networkConditions = {
      'fast3g': { downloadThroughput: 1.5 * 1024 * 1024 / 8, uploadThroughput: 750 * 1024 / 8, latency: 40 },
      'slow3g': { downloadThroughput: 500 * 1024 / 8, uploadThroughput: 500 * 1024 / 8, latency: 400 }
    };

    if (networkConditions[network]) {
      await page.emulateNetworkConditions(networkConditions[network]);
    }

    // æ€§èƒ½æ•°æ®æ”¶é›†
    await page.evaluateOnNewDocument(() => {
      window.syntheticMetrics = {};

      // Web Vitals æ”¶é›†
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          window.syntheticMetrics[entry.entryType] = entry;
        }
      }).observe({ entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'] });
    });

    const startTime = Date.now();
    const response = await page.goto(url, {
      waitUntil: 'networkidle0',
      timeout: 30000
    });

    // ç­‰å¾…é¡µé¢ç¨³å®š
    await page.waitForTimeout(3000);

    const metrics = await this.collectMetrics(page);

    await browser.close();

    // å‘é€ç›‘æ§æ•°æ®
    await this.reportSyntheticMetrics({
      ...metrics,
      location,
      device,
      network,
      timestamp: Date.now(),
      testDuration: Date.now() - startTime
    });
  }

  async collectMetrics(page) {
    return await page.evaluate(() => {
      const nav = performance.getEntriesByType('navigation')[0];
      const paint = performance.getEntriesByType('paint');

      return {
        // å¯¼èˆªæ—¶åº
        navigationTiming: {
          DNS: nav.domainLookupEnd - nav.domainLookupStart,
          TCP: nav.connectEnd - nav.connectStart,
          SSL: nav.connectEnd - nav.secureConnectionStart,
          TTFB: nav.responseStart - nav.requestStart,
          DOMContentLoaded: nav.domContentLoadedEventEnd - nav.navigationStart,
          Load: nav.loadEventEnd - nav.navigationStart
        },

        // ç»˜åˆ¶æ—¶åº
        paintTiming: {
          FCP: paint.find(p => p.name === 'first-contentful-paint')?.startTime,
          LCP: window.syntheticMetrics['largest-contentful-paint']?.startTime
        },

        // èµ„æºç»Ÿè®¡
        resourceStats: {
          totalResources: performance.getEntriesByType('resource').length,
          totalSize: performance.getEntriesByType('resource')
            .reduce((total, resource) => total + (resource.transferSize || 0), 0),
          cacheHitRate: this.calculateCacheHitRate()
        }
      };
    });
  }
}
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ä½“ç³»

### åŠ è½½æ€§èƒ½ä¼˜åŒ–

#### å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–

```javascript
// èµ„æºä¼˜å…ˆçº§æ§åˆ¶
class ResourcePriorityManager {
  constructor() {
    this.criticalResources = new Set();
    this.deferredResources = new Set();
  }

  // é¢„åŠ è½½å…³é”®èµ„æº
  preloadCriticalResources(resources) {
    resources.forEach(resource => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = resource.url;
      link.as = resource.type;

      if (resource.type === 'font') {
        link.crossOrigin = 'anonymous';
      }

      document.head.appendChild(link);
      this.criticalResources.add(resource.url);
    });
  }

  // å»¶è¿ŸåŠ è½½éå…³é”®èµ„æº
  deferNonCriticalResources() {
    // å»¶è¿ŸåŠ è½½å›¾ç‰‡
    this.implementLazyLoading();

    // å»¶è¿ŸåŠ è½½ç¬¬ä¸‰æ–¹è„šæœ¬
    this.deferThirdPartyScripts();
  }

  implementLazyLoading() {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.remove('lazy');
          observer.unobserve(img);
        }
      });
    });

    document.querySelectorAll('img[data-src]').forEach(img => {
      imageObserver.observe(img);
    });
  }
}
```

#### ä»£ç åˆ†å‰²ä¸æŒ‰éœ€åŠ è½½

```javascript
// åŸºäºè·¯ç”±çš„ä»£ç åˆ†å‰²
class RouteBasedSplitting {
  constructor() {
    this.routes = new Map();
    this.loadedChunks = new Set();
  }

  registerRoute(path, loader) {
    this.routes.set(path, {
      loader,
      preloaded: false,
      component: null
    });
  }

  async loadRoute(path) {
    const route = this.routes.get(path);
    if (!route) return null;

    if (!route.component) {
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      this.showLoadingState();

      try {
        route.component = await route.loader();
        this.loadedChunks.add(path);
      } catch (error) {
        console.error(`Failed to load route ${path}:`, error);
        return null;
      } finally {
        this.hideLoadingState();
      }
    }

    return route.component;
  }

  // æ™ºèƒ½é¢„åŠ è½½
  preloadRoute(path) {
    const route = this.routes.get(path);
    if (route && !route.preloaded && !this.loadedChunks.has(path)) {
      // åœ¨ç©ºé—²æ—¶é—´é¢„åŠ è½½
      requestIdleCallback(() => {
        route.loader().then(component => {
          route.component = component;
          route.preloaded = true;
        });
      });
    }
  }
}
```

### è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

#### é•¿ä»»åŠ¡ä¼˜åŒ–ç­–ç•¥

```javascript
class TaskScheduler {
  constructor() {
    this.taskQueue = [];
    this.isProcessing = false;
    this.frameDeadline = 16.67; // 60fps
  }

  // ä»»åŠ¡åˆ†ç‰‡æ‰§è¡Œ
  scheduleTask(task, priority = 'normal') {
    this.taskQueue.push({
      task,
      priority,
      timestamp: performance.now()
    });

    if (!this.isProcessing) {
      this.processQueue();
    }
  }

  processQueue() {
    this.isProcessing = true;

    const processChunk = (deadline) => {
      // æŒ‰ä¼˜å…ˆçº§æ’åº
      this.taskQueue.sort((a, b) => {
        const priorityOrder = { high: 0, normal: 1, low: 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      });

      while (this.taskQueue.length > 0 && deadline.timeRemaining() > 0) {
        const { task } = this.taskQueue.shift();

        try {
          task();
        } catch (error) {
          console.error('Task execution error:', error);
        }
      }

      if (this.taskQueue.length > 0) {
        requestIdleCallback(processChunk);
      } else {
        this.isProcessing = false;
      }
    };

    requestIdleCallback(processChunk);
  }

  // å¤§æ•°æ®å¤„ç†åˆ†ç‰‡
  processLargeDataset(data, processor, chunkSize = 1000) {
    return new Promise((resolve) => {
      const results = [];
      let index = 0;

      const processChunk = () => {
        const endIndex = Math.min(index + chunkSize, data.length);
        const chunk = data.slice(index, endIndex);

        const chunkResults = processor(chunk);
        results.push(...chunkResults);

        index = endIndex;

        if (index < data.length) {
          // è®©å‡ºä¸»çº¿ç¨‹
          setTimeout(processChunk, 0);
        } else {
          resolve(results);
        }
      };

      processChunk();
    });
  }
}
```

---

## ğŸ¢ ä¼ä¸šçº§ç›‘æ§æ–¹æ¡ˆ

### æ€§èƒ½é¢„ç®—ç®¡ç†

```javascript
// æ€§èƒ½é¢„ç®—é…ç½®
const performanceBudget = {
  // èµ„æºå¤§å°é¢„ç®—
  resourceSizes: {
    'script': { max: 500, warning: 400 }, // KB
    'stylesheet': { max: 100, warning: 80 },
    'image': { max: 1000, warning: 800 },
    'font': { max: 200, warning: 150 }
  },

  // æ€§èƒ½æŒ‡æ ‡é¢„ç®—
  metrics: {
    'LCP': { max: 2500, warning: 2000 }, // ms
    'FID': { max: 100, warning: 80 },
    'CLS': { max: 0.1, warning: 0.08 },
    'TTFB': { max: 800, warning: 600 }
  },

  // èµ„æºæ•°é‡é¢„ç®—
  resourceCounts: {
    'script': { max: 10, warning: 8 },
    'stylesheet': { max: 5, warning: 4 },
    'image': { max: 50, warning: 40 }
  }
};

class PerformanceBudgetMonitor {
  constructor(budget) {
    this.budget = budget;
    this.violations = [];
  }

  checkBudget() {
    // æ£€æŸ¥èµ„æºå¤§å°
    this.checkResourceSizes();

    // æ£€æŸ¥æ€§èƒ½æŒ‡æ ‡
    this.checkMetrics();

    // æ£€æŸ¥èµ„æºæ•°é‡
    this.checkResourceCounts();

    return this.violations;
  }

  checkResourceSizes() {
    const resources = performance.getEntriesByType('resource');
    const resourceStats = {};

    resources.forEach(resource => {
      const type = this.getResourceType(resource);
      if (!resourceStats[type]) {
        resourceStats[type] = { totalSize: 0, count: 0 };
      }

      resourceStats[type].totalSize += resource.transferSize || 0;
      resourceStats[type].count++;
    });

    Object.entries(resourceStats).forEach(([type, stats]) => {
      const budget = this.budget.resourceSizes[type];
      if (budget && stats.totalSize > budget.max * 1024) {
        this.violations.push({
          type: 'resource-size',
          resourceType: type,
          actual: stats.totalSize,
          budget: budget.max * 1024,
          severity: 'error'
        });
      }
    });
  }

  generateReport() {
    return {
      timestamp: Date.now(),
      url: location.href,
      violations: this.violations,
      summary: {
        total: this.violations.length,
        errors: this.violations.filter(v => v.severity === 'error').length,
        warnings: this.violations.filter(v => v.severity === 'warning').length
      }
    };
  }
}
```

### CI/CD é›†æˆæ–¹æ¡ˆ

```yaml
# .github/workflows/performance-monitoring.yml
name: Performance Monitoring

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  performance-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.12.x
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      - name: Bundle Analysis
        run: |
          npx webpack-bundle-analyzer dist/stats.json --mode json > bundle-report.json

      - name: Performance Budget Check
        run: node scripts/check-performance-budget.js

      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('performance-report.json', 'utf8'));

            const comment = `
            ## ğŸ“Š Performance Report

            **Lighthouse Scores:**
            - Performance: ${report.lighthouse.performance}
            - Accessibility: ${report.lighthouse.accessibility}
            - Best Practices: ${report.lighthouse.bestPractices}
            - SEO: ${report.lighthouse.seo}

            **Bundle Size:**
            - Total: ${report.bundleSize.total}
            - JavaScript: ${report.bundleSize.javascript}
            - CSS: ${report.bundleSize.css}

            **Performance Budget:** ${report.budgetViolations.length === 0 ? 'âœ… Passed' : 'âŒ Failed'}
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

---

## ğŸ“ é¢è¯•é«˜é¢‘è€ƒç‚¹

### 1. Web Vitals æ·±åº¦ç†è§£

**Q: è§£é‡Š LCPã€FID/INPã€CLS çš„æŠ€æœ¯åŸç†å’Œä¼˜åŒ–æ–¹æ³•**

**A: æŠ€æœ¯è¦ç‚¹**
- **LCP**: ç›‘å¬ `largest-contentful-paint` äº‹ä»¶ï¼Œæ ‡è¯†ä¸»è¦å†…å®¹åŠ è½½å®Œæˆæ—¶é—´
- **INP**: å–ä»£ FIDï¼Œè¡¡é‡ä»ç”¨æˆ·äº¤äº’åˆ°ä¸‹æ¬¡ç»˜åˆ¶çš„å»¶è¿Ÿ
- **CLS**: é€šè¿‡ `layout-shift` äº‹ä»¶è®¡ç®—å¸ƒå±€ç¨³å®šæ€§

**ä¼˜åŒ–ç­–ç•¥**ï¼š
- LCP: TTFB ä¼˜åŒ–ã€å…³é”®èµ„æºé¢„åŠ è½½ã€å›¾ç‰‡ä¼˜åŒ–
- INP: å‡å°‘é•¿ä»»åŠ¡ã€ä¼˜åŒ–äº‹ä»¶å¤„ç†å™¨ã€ä½¿ç”¨ Web Workers
- CLS: é¢„è®¾å…ƒç´ å°ºå¯¸ã€é¿å…åŠ¨æ€å†…å®¹æ’å…¥

### 2. æ€§èƒ½ç›‘æ§å®ç°åŸç†

**Q: å¦‚ä½•è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„å‰ç«¯æ€§èƒ½ç›‘æ§ç³»ç»Ÿï¼Ÿ**

**A: æ¶æ„è®¾è®¡**
```
æ•°æ®é‡‡é›†å±‚ â†’ æ•°æ®å¤„ç†å±‚ â†’ å­˜å‚¨å±‚ â†’ åˆ†æå±•ç¤ºå±‚
     â†“           â†“        â†“        â†“
Performance API â†’ æ•°æ®æ¸…æ´— â†’ æ—¶åºæ•°æ®åº“ â†’ ç›‘æ§ä»ªè¡¨æ¿
ç”¨æˆ·è¡Œä¸ºè¿½è¸ª   â†’ å¼‚å¸¸æ£€æµ‹ â†’ æ—¥å¿—å­˜å‚¨   â†’ æŠ¥è­¦ç³»ç»Ÿ
```

**å…³é”®æŠ€æœ¯**ï¼š
- Performance Observer API è¿›è¡Œæ•°æ®é‡‡é›†
- é‡‡æ ·ç­–ç•¥æ§åˆ¶æ•°æ®é‡
- æ‰¹é‡ä¸ŠæŠ¥å‡å°‘ç½‘ç»œå¼€é”€
- ç¦»çº¿ç¼“å­˜ä¿è¯æ•°æ®å®Œæ•´æ€§

### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**Q: å¤§å‹åº”ç”¨çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥æœ‰å“ªäº›ï¼Ÿ**

**A: åˆ†å±‚ä¼˜åŒ–**
- **åŠ è½½ä¼˜åŒ–**: ä»£ç åˆ†å‰²ã€æ‡’åŠ è½½ã€é¢„åŠ è½½
- **æ¸²æŸ“ä¼˜åŒ–**: è™šæ‹Ÿæ»šåŠ¨ã€é˜²æŠ–èŠ‚æµã€é¿å…é‡æ’é‡ç»˜
- **ç½‘ç»œä¼˜åŒ–**: CDNã€HTTP/2ã€èµ„æºå‹ç¼©
- **è¿è¡Œæ—¶ä¼˜åŒ–**: Web Workersã€ä»»åŠ¡è°ƒåº¦ã€å†…å­˜ç®¡ç†

### 4. ç›‘æ§æ•°æ®åˆ†æ

**Q: å¦‚ä½•åˆ†æå’Œè§£è¯»æ€§èƒ½ç›‘æ§æ•°æ®ï¼Ÿ**

**A: åˆ†æç»´åº¦**
- **æ—¶é—´ç»´åº¦**: è¶‹åŠ¿åˆ†æã€å¼‚å¸¸æ£€æµ‹
- **ç”¨æˆ·ç»´åº¦**: è®¾å¤‡ç±»å‹ã€ç½‘ç»œæ¡ä»¶ã€åœ°ç†ä½ç½®
- **åŠŸèƒ½ç»´åº¦**: é¡µé¢ç±»å‹ã€ç”¨æˆ·è·¯å¾„ã€ä¸šåŠ¡æµç¨‹
- **æŠ€æœ¯ç»´åº¦**: èµ„æºç±»å‹ã€ä»£ç æ¨¡å—ã€ç¬¬ä¸‰æ–¹æœåŠ¡

---

## ğŸ¯ å­¦ä¹ å»ºè®®

### å®è·µé¡¹ç›®æ¨è

1. **æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿**
   - å®æ—¶ç›‘æ§ Web Vitals
   - å†å²æ•°æ®åˆ†æ
   - æ€§èƒ½æŠ¥è­¦ç³»ç»Ÿ

2. **æ€§èƒ½ä¼˜åŒ–å·¥å…·**
   - è‡ªåŠ¨åŒ–æ€§èƒ½å®¡è®¡
   - æ€§èƒ½é¢„ç®—æ£€æŸ¥
   - ä¼˜åŒ–å»ºè®®ç”Ÿæˆ

3. **A/B æµ‹è¯•å¹³å°**
   - æ€§èƒ½å½±å“åˆ†æ
   - åŠŸèƒ½å¼€å…³æ§åˆ¶
   - æ•°æ®å¯¹æ¯”åˆ†æ

### å­¦ä¹ è·¯å¾„

1. **åŸºç¡€é˜¶æ®µ**: æŒæ¡ Performance API å’Œ Web Vitals
2. **è¿›é˜¶é˜¶æ®µ**: å®ç°å®Œæ•´ç›‘æ§ç³»ç»Ÿ
3. **é«˜çº§é˜¶æ®µ**: ä¼ä¸šçº§ç›‘æ§æ–¹æ¡ˆè®¾è®¡
4. **ä¸“å®¶é˜¶æ®µ**: æ€§èƒ½ä¼˜åŒ–å·¥ç¨‹åŒ–å®è·µ

é€šè¿‡ç³»ç»Ÿæ€§å­¦ä¹ å’Œå®è·µï¼Œä½ å°†å…·å¤‡å¤§å‚èµ„æ·±å‰ç«¯å·¥ç¨‹å¸ˆçš„æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–èƒ½åŠ›ï¼ğŸš€