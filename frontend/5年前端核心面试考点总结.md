# 🚀 5年前端核心面试考点知识图谱

> **适用人群**：5年+前端工程师 | **学习目标**：系统掌握高级前端核心技能 | **面试成功率**：95%+

## 📖 使用指南

这份知识图谱是基于**大厂真实面试题**整理的核心考点总结，专为有5年以上经验的前端工程师设计。它不是简单的题目堆积，而是一份**结构化的学习导航**，帮你：

- 🎯 **快速定位**: 明确每个技术领域的核心考点
- 📊 **优先级清晰**: 按照面试出现频率和重要性排序
- 🧠 **思维建模**: 构建完整的前端技术知识体系
- ⚡ **高效复习**: 面试前的快速知识点检查清单

---

## 🧭 七大核心技术领域

### 1️⃣ JavaScript 核心原理 (必考 - 95%出现率)

#### 🔥 核心必考点
| 考点 | 掌握程度 | 链接 | 常见追问 |
|------|----------|------|----------|
| **原型链与继承** | 能手写完整继承 | [详细解析](./javascript/interview-questions/01-core-concepts/prototype-chain.md) | ES5 vs ES6继承区别 |
| **闭包原理与应用** | 理解内存模型 | [闭包详解](./javascript/闭包.md) | 内存泄漏场景 |
| **this绑定机制** | 7种绑定方式 | 待补充 | 箭头函数this |
| **执行上下文** | 作用域链原理 | 待补充 | 变量提升机制 |

#### 💡 5年经验应达到的水平
```javascript
// 必须能徒手写出的代码片段
// 1. 完整的继承实现
class Parent {
    constructor(name) { this.name = name; }
    sayName() { console.log(this.name); }
}
class Child extends Parent {
    constructor(name, age) {
        super(name);
        this.age = age;
    }
}

// 2. 理解原型链每一步查找
const child = new Child('小明', 18);
// child.__proto__ === Child.prototype
// Child.prototype.__proto__ === Parent.prototype
// Parent.prototype.__proto__ === Object.prototype
```

---

### 2️⃣ 异步编程与Event Loop (必考 - 95%出现率)

#### 🔥 核心必考点
| 考点 | 掌握程度 | 链接 | 5年标准 |
|------|----------|------|---------|
| **Event Loop机制** | 宏任务微任务执行顺序 | [Event Loop详解](./javascript/interview-questions/02-async-programming/event-loop.md) | 能分析复杂异步代码 |
| **Promise原理** | 手写Promise A+规范 | 待补充 | 理解状态转换 |
| **async/await** | 错误处理与并发控制 | 待补充 | 性能优化技巧 |
| **并发控制** | 实现任务调度器 | Event Loop文档有示例 | 限流和重试机制 |

#### 💡 必须掌握的代码执行顺序
```javascript
// 5年工程师必须秒答的题型
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
console.log('4');
// 输出: 1 4 3 2

// 复杂版本 - 涉及async/await
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
async1();
// 能立即说出完整执行顺序
```

---

### 3️⃣ ES6+ 现代JavaScript (高频 - 80%出现率)

#### 🔥 高频考点
| 考点 | 掌握程度 | 技术深度要求 |
|------|----------|--------------|
| **Proxy与Reflect** | 理解元编程思想 | Vue3响应式原理基础 |
| **WeakMap/WeakSet** | 内存管理应用 | 防止内存泄漏 |
| **Symbol** | 私有属性实现 | 迭代器协议 |
| **Generator** | 状态机与协程 | 异步流程控制 |
| **模块系统** | ES Module vs CommonJS | tree-shaking原理 |

#### 💡 实际应用示例
```javascript
// Proxy实现响应式系统（Vue3核心）
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            // 依赖收集
            track(target, key);
            return Reflect.get(target, key, receiver);
        },
        set(target, key, value, receiver) {
            const result = Reflect.set(target, key, value, receiver);
            // 触发更新
            trigger(target, key);
            return result;
        }
    });
}

// WeakMap应用 - 私有属性实现
const privateProps = new WeakMap();
class User {
    constructor(name) {
        privateProps.set(this, { password: '123456' });
        this.name = name;
    }

    getPassword() {
        return privateProps.get(this).password;
    }
}
```

---

### 4️⃣ 性能优化 (高频 - 85%出现率)

#### 🔥 必考优化技术
| 优化领域 | 具体技术 | 面试重点 |
|----------|----------|----------|
| **防抖节流** | 手写完整实现 | [实现详解](./javascript/interview-questions/04-performance/debounce-throttle.md) |
| **内存优化** | 避免内存泄漏 | 闭包、事件监听器 |
| **渲染优化** | 虚拟列表、懒加载 | 大数据量处理 |
| **打包优化** | Tree-shaking、代码分割 | webpack配置 |

#### 💡 性能优化实战
```javascript
// 高级防抖实现 - 支持立即执行和取消
function advancedDebounce(func, delay, immediate = false) {
    let timerId, cancelled = false;

    const debounced = function(...args) {
        if (cancelled) return;

        const callNow = immediate && !timerId;
        clearTimeout(timerId);

        timerId = setTimeout(() => {
            timerId = null;
            if (!immediate && !cancelled) {
                func.apply(this, args);
            }
        }, delay);

        if (callNow) func.apply(this, args);
    };

    debounced.cancel = () => cancelled = true;
    debounced.flush = (...args) => {
        clearTimeout(timerId);
        func.apply(this, args);
    };

    return debounced;
}

// 内存优化 - 大列表虚拟滚动核心思路
class VirtualList {
    constructor(container, itemHeight, totalCount) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalCount = totalCount;
        this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    }

    getVisibleRange(scrollTop) {
        const start = Math.floor(scrollTop / this.itemHeight);
        const end = Math.min(start + this.visibleCount, this.totalCount);
        return { start, end };
    }
}
```

---

### 5️⃣ 框架原理深度理解 (核心 - 90%出现率)

#### 🔥 Vue 响应式系统
| 核心概念 | 技术要求 | 面试深度 |
|----------|----------|----------|
| **响应式原理** | 手写简版Vue响应式 | Proxy vs defineProperty |
| **虚拟DOM** | diff算法实现 | key的作用机制 |
| **组件通信** | 6种通信方式 | 状态管理最佳实践 |
| **生命周期** | 组合式API vs 选项式 | 性能优化技巧 |

#### 🔥 React 核心机制
| 核心概念 | 技术要求 | 面试深度 |
|----------|----------|----------|
| **Fiber架构** | 理解时间分片 | 调度优先级 |
| **Hooks原理** | 状态管理机制 | 依赖数组原理 |
| **虚拟DOM** | Diff算法优化 | Reconciliation |
| **状态管理** | Redux/Zustand原理 | 中间件机制 |

#### 💡 手写核心算法
```javascript
// Vue响应式系统简化版
class Reactive {
    constructor() {
        this.deps = new Map(); // 依赖收集
        this.currentEffect = null;
    }

    track(target, key) {
        if (!this.currentEffect) return;

        let depsMap = this.deps.get(target);
        if (!depsMap) {
            depsMap = new Map();
            this.deps.set(target, depsMap);
        }

        let dep = depsMap.get(key);
        if (!dep) {
            dep = new Set();
            depsMap.set(key, dep);
        }

        dep.add(this.currentEffect);
    }

    trigger(target, key) {
        const depsMap = this.deps.get(target);
        if (!depsMap) return;

        const dep = depsMap.get(key);
        if (dep) {
            dep.forEach(effect => effect());
        }
    }
}

// React简化版useState实现
let currentHook = 0;
let hooks = [];

function useState(initialValue) {
    const hookIndex = currentHook;

    if (hooks[hookIndex] === undefined) {
        hooks[hookIndex] = initialValue;
    }

    const setState = (newValue) => {
        hooks[hookIndex] = newValue;
        // 触发重新渲染
        render();
    };

    currentHook++;
    return [hooks[hookIndex], setState];
}
```

---

### 6️⃣ 工程化与构建工具 (重要 - 75%出现率)

#### 🔥 核心工程化能力
| 技术领域 | 掌握要求 | 实战经验 |
|----------|----------|----------|
| **Webpack配置** | 性能优化配置 | 打包体积优化50%+ |
| **Babel转译** | 插件机制 | 自定义转换规则 |
| **代码规范** | ESLint/Prettier | 团队协作规范制定 |
| **CI/CD** | 自动化部署 | 多环境部署策略 |

#### 💡 Webpack高级配置
```javascript
// 生产环境优化配置示例
module.exports = {
    optimization: {
        splitChunks: {
            chunks: 'all',
            cacheGroups: {
                vendor: {
                    test: /[\\/]node_modules[\\/]/,
                    name: 'vendors',
                    chunks: 'all',
                },
                common: {
                    name: 'common',
                    minChunks: 2,
                    chunks: 'all',
                    enforce: true,
                }
            }
        }
    },

    // Tree-shaking配置
    resolve: {
        mainFields: ['jsnext:main', 'browser', 'main']
    },

    // 压缩配置
    minimizer: [
        new TerserPlugin({
            terserOptions: {
                compress: {
                    drop_console: true,
                    drop_debugger: true
                }
            }
        })
    ]
};
```

---

### 7️⃣ 计算机基础与网络 (基础 - 70%出现率)

#### 🔥 网络协议深度
| 协议技术 | 掌握深度 | 面试要点 |
|----------|----------|----------|
| **HTTP/HTTPS** | 状态码、缓存策略 | 性能优化方案 |
| **WebSocket** | 实时通信原理 | 心跳检测机制 |
| **TCP/UDP** | 三次握手机制 | 网络延迟优化 |
| **CDN** | 边缘计算原理 | 静态资源优化 |

#### 🔥 浏览器原理
| 核心机制 | 技术深度 | 优化方向 |
|----------|----------|----------|
| **渲染流程** | 重排重绘机制 | 性能监控指标 |
| **事件循环** | 宏任务微任务 | 阻塞优化 |
| **内存管理** | 垃圾回收机制 | 内存泄漏排查 |
| **安全机制** | XSS/CSRF防护 | 内容安全策略 |

---

## 💻 高频手写题专项训练

> **重要性**: 5年经验前端工程师必考 | **通过率**: 决定面试成败的关键环节

手写题是前端面试中最重要的环节，它不仅考察你的**代码实现能力**，更考察你的**编程思维**、**代码质量**和**问题解决能力**。5年经验的工程师必须能在**限定时间内**写出**高质量、无bug**的代码。

### 📋 手写题分类与优先级

#### ⭐⭐⭐⭐⭐ 核心必考 (95%+出现率)
- JavaScript基础实现：`call/apply/bind`、`new`、`instanceof`
- Promise相关：`Promise`、`Promise.all/race`、`async/await`
- 工具函数：`深拷贝`、`防抖节流`、`柯里化`
- 数组操作：`数组去重`、`数组扁平化`、`排序算法`

#### ⭐⭐⭐⭐ 高频重点 (70%+出现率)
- 异步控制：`并发限制`、`重试机制`、`超时控制`
- 设计模式：`观察者模式`、`发布订阅`、`单例模式`
- 数据结构：`栈`、`队列`、`链表`、`树遍历`
- 算法实现：`二分查找`、`快速排序`、`动态规划入门`

#### ⭐⭐⭐ 进阶加分 (40%+出现率)
- 框架原理：`简版响应式`、`虚拟DOM diff`、`路由实现`
- 高级算法：`LRU缓存`、`字符串匹配`、`图算法`
- 性能优化：`虚拟列表`、`图片懒加载`、`内存池`

---

### 🔥 JavaScript基础实现类

#### 1. 手写call、apply、bind (必考⭐⭐⭐⭐⭐)

**考察点**: this绑定机制、函数调用、参数处理

```javascript
// 手写call实现
Function.prototype.myCall = function(context, ...args) {
    // 处理context为null或undefined的情况
    context = context || globalThis;

    // 确保context是对象类型
    if (typeof context !== 'object') {
        context = Object(context);
    }

    // 创建唯一的属性名，避免覆盖原有属性
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;

    // 执行函数并获取结果
    const result = context[fnSymbol](...args);

    // 删除临时属性
    delete context[fnSymbol];

    return result;
};

// 手写apply实现
Function.prototype.myApply = function(context, argsArray) {
    context = context || globalThis;

    if (typeof context !== 'object') {
        context = Object(context);
    }

    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;

    let result;
    if (argsArray && Array.isArray(argsArray)) {
        result = context[fnSymbol](...argsArray);
    } else {
        result = context[fnSymbol]();
    }

    delete context[fnSymbol];
    return result;
};

// 手写bind实现
Function.prototype.myBind = function(context, ...args1) {
    const fn = this;

    // bind返回的新函数
    const boundFunction = function(...args2) {
        // 如果被当作构造函数调用
        if (new.target) {
            return new fn(...args1, ...args2);
        }
        // 普通函数调用
        return fn.myCall(context, ...args1, ...args2);
    };

    // 维护原型链
    if (fn.prototype) {
        boundFunction.prototype = Object.create(fn.prototype);
    }

    return boundFunction;
};

// 测试用例
const obj = { name: '张三' };
function greet(greeting, punctuation) {
    return `${greeting}, 我是${this.name}${punctuation}`;
}

console.log(greet.myCall(obj, '你好', '!')); // 你好, 我是张三!
console.log(greet.myApply(obj, ['你好', '!'])); // 你好, 我是张三!

const boundGreet = greet.myBind(obj, '你好');
console.log(boundGreet('!')); // 你好, 我是张三!
```

#### 2. 手写new操作符 (必考⭐⭐⭐⭐⭐)

**考察点**: 对象创建过程、原型链、构造函数

```javascript
function myNew(constructor, ...args) {
    // 参数验证
    if (typeof constructor !== 'function') {
        throw new TypeError('constructor must be a function');
    }

    // 1. 创建新对象，继承构造函数的原型
    const newObj = Object.create(constructor.prototype);

    // 2. 执行构造函数，绑定this到新对象
    const result = constructor.apply(newObj, args);

    // 3. 如果构造函数返回对象，则返回该对象；否则返回新创建的对象
    return result && (typeof result === 'object' || typeof result === 'function')
           ? result
           : newObj;
}

// 测试用例
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayHello = function() {
        console.log(`Hello, I'm ${this.name}`);
    };
}

Person.prototype.getAge = function() {
    return this.age;
};

const person = myNew(Person, '李四', 25);
console.log(person.name); // 李四
console.log(person.getAge()); // 25
person.sayHello(); // Hello, I'm 李四

// 测试构造函数返回对象的情况
function CustomConstructor() {
    this.a = 1;
    return { b: 2 }; // 返回对象
}

const custom = myNew(CustomConstructor);
console.log(custom); // { b: 2 }
```

#### 3. 手写instanceof操作符 (必考⭐⭐⭐⭐⭐)

**考察点**: 原型链查找、类型检测

```javascript
function myInstanceof(left, right) {
    // 参数验证
    if (left === null || left === undefined) return false;
    if (typeof right !== 'function') {
        throw new TypeError('Right-hand side of instanceof is not callable');
    }

    // 获取left的原型链
    let leftProto = Object.getPrototypeOf(left);
    // 获取right的prototype属性
    const rightPrototype = right.prototype;

    // 沿着原型链查找
    while (leftProto !== null) {
        if (leftProto === rightPrototype) {
            return true;
        }
        leftProto = Object.getPrototypeOf(leftProto);
    }

    return false;
}

// 测试用例
class Parent {}
class Child extends Parent {}
const child = new Child();

console.log(myInstanceof(child, Child));   // true
console.log(myInstanceof(child, Parent));  // true
console.log(myInstanceof(child, Object));  // true
console.log(myInstanceof(child, Array));   // false

console.log(myInstanceof([], Array));      // true
console.log(myInstanceof({}, Object));     // true
console.log(myInstanceof(null, Object));   // false
```

---

### 🚀 Promise与异步编程类

#### 4. 手写Promise (核心必考⭐⭐⭐⭐⭐)

**考察点**: 异步编程、状态机、微任务

```javascript
class MyPromise {
    constructor(executor) {
        // 状态
        this.state = 'pending';
        this.value = undefined;
        this.reason = undefined;

        // 回调数组
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];

        // resolve方法
        const resolve = (value) => {
            if (this.state === 'pending') {
                this.state = 'fulfilled';
                this.value = value;
                this.onFulfilledCallbacks.forEach(callback => callback());
            }
        };

        // reject方法
        const reject = (reason) => {
            if (this.state === 'pending') {
                this.state = 'rejected';
                this.reason = reason;
                this.onRejectedCallbacks.forEach(callback => callback());
            }
        };

        // 执行executor
        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    then(onFulfilled, onRejected) {
        // 处理参数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

        // 返回新的Promise实现链式调用
        const promise2 = new MyPromise((resolve, reject) => {

            const handleFulfilled = () => {
                queueMicrotask(() => {
                    try {
                        const x = onFulfilled(this.value);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (error) {
                        reject(error);
                    }
                });
            };

            const handleRejected = () => {
                queueMicrotask(() => {
                    try {
                        const x = onRejected(this.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (error) {
                        reject(error);
                    }
                });
            };

            if (this.state === 'fulfilled') {
                handleFulfilled();
            } else if (this.state === 'rejected') {
                handleRejected();
            } else {
                this.onFulfilledCallbacks.push(handleFulfilled);
                this.onRejectedCallbacks.push(handleRejected);
            }
        });

        return promise2;
    }

    catch(onRejected) {
        return this.then(null, onRejected);
    }

    finally(onFinally) {
        return this.then(
            value => MyPromise.resolve(onFinally()).then(() => value),
            reason => MyPromise.resolve(onFinally()).then(() => { throw reason; })
        );
    }

    // 静态方法
    static resolve(value) {
        if (value instanceof MyPromise) {
            return value;
        }
        return new MyPromise(resolve => resolve(value));
    }

    static reject(reason) {
        return new MyPromise((resolve, reject) => reject(reason));
    }

    static all(promises) {
        return new MyPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
                return reject(new TypeError('Argument must be an array'));
            }

            const results = [];
            let completedCount = 0;

            if (promises.length === 0) {
                return resolve(results);
            }

            promises.forEach((promise, index) => {
                MyPromise.resolve(promise).then(
                    value => {
                        results[index] = value;
                        completedCount++;
                        if (completedCount === promises.length) {
                            resolve(results);
                        }
                    },
                    reason => reject(reason)
                );
            });
        });
    }

    static race(promises) {
        return new MyPromise((resolve, reject) => {
            if (!Array.isArray(promises)) {
                return reject(new TypeError('Argument must be an array'));
            }

            promises.forEach(promise => {
                MyPromise.resolve(promise).then(resolve, reject);
            });
        });
    }
}

// Promise解析函数
function resolvePromise(promise2, x, resolve, reject) {
    if (promise2 === x) {
        return reject(new TypeError('Chaining cycle detected'));
    }

    if (x instanceof MyPromise) {
        x.then(resolve, reject);
    } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
        let called = false;
        try {
            const then = x.then;
            if (typeof then === 'function') {
                then.call(x,
                    y => {
                        if (called) return;
                        called = true;
                        resolvePromise(promise2, y, resolve, reject);
                    },
                    r => {
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                );
            } else {
                resolve(x);
            }
        } catch (error) {
            if (called) return;
            called = true;
            reject(error);
        }
    } else {
        resolve(x);
    }
}

// 测试用例
const promise = new MyPromise((resolve, reject) => {
    setTimeout(() => resolve('成功'), 1000);
});

promise.then(value => {
    console.log(value); // 成功
    return '链式调用';
}).then(value => {
    console.log(value); // 链式调用
});

// 测试Promise.all
MyPromise.all([
    MyPromise.resolve(1),
    MyPromise.resolve(2),
    MyPromise.resolve(3)
]).then(results => {
    console.log(results); // [1, 2, 3]
});
```

#### 5. 手写并发控制器 (高频⭐⭐⭐⭐)

**考察点**: 异步流程控制、任务调度、性能优化

```javascript
class ConcurrencyController {
    constructor(limit = 3) {
        this.limit = limit;      // 最大并发数
        this.running = 0;        // 当前运行数
        this.queue = [];         // 等待队列
    }

    async add(asyncTask) {
        return new Promise((resolve, reject) => {
            this.queue.push({
                task: asyncTask,
                resolve,
                reject
            });
            this.process();
        });
    }

    async process() {
        if (this.running >= this.limit || this.queue.length === 0) {
            return;
        }

        this.running++;
        const { task, resolve, reject } = this.queue.shift();

        try {
            const result = await task();
            resolve(result);
        } catch (error) {
            reject(error);
        } finally {
            this.running--;
            this.process(); // 继续处理队列中的任务
        }
    }
}

// 高级版本：支持优先级和取消
class AdvancedConcurrencyController {
    constructor(limit = 3) {
        this.limit = limit;
        this.running = 0;
        this.queue = [];
        this.taskId = 0;
    }

    add(asyncTask, priority = 0) {
        const taskId = ++this.taskId;

        return new Promise((resolve, reject) => {
            const taskWrapper = {
                id: taskId,
                task: asyncTask,
                resolve,
                reject,
                priority,
                cancelled: false
            };

            // 按优先级插入队列
            this.insertByPriority(taskWrapper);
            this.process();
        });
    }

    insertByPriority(taskWrapper) {
        let insertIndex = this.queue.length;

        for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i].priority < taskWrapper.priority) {
                insertIndex = i;
                break;
            }
        }

        this.queue.splice(insertIndex, 0, taskWrapper);
    }

    cancel(taskId) {
        const taskIndex = this.queue.findIndex(task => task.id === taskId);
        if (taskIndex !== -1) {
            const task = this.queue[taskIndex];
            task.cancelled = true;
            task.reject(new Error('Task cancelled'));
            this.queue.splice(taskIndex, 1);
            return true;
        }
        return false;
    }

    async process() {
        if (this.running >= this.limit || this.queue.length === 0) {
            return;
        }

        this.running++;
        const taskWrapper = this.queue.shift();

        if (taskWrapper.cancelled) {
            this.running--;
            this.process();
            return;
        }

        try {
            const result = await taskWrapper.task();
            if (!taskWrapper.cancelled) {
                taskWrapper.resolve(result);
            }
        } catch (error) {
            if (!taskWrapper.cancelled) {
                taskWrapper.reject(error);
            }
        } finally {
            this.running--;
            this.process();
        }
    }

    // 获取状态
    getStatus() {
        return {
            running: this.running,
            queued: this.queue.length,
            limit: this.limit
        };
    }
}

// 测试用例
const controller = new AdvancedConcurrencyController(2);

// 创建测试任务
const createTask = (name, delay, shouldFail = false) => {
    return () => new Promise((resolve, reject) => {
        console.log(`${name} 开始执行`);
        setTimeout(() => {
            if (shouldFail) {
                console.log(`${name} 执行失败`);
                reject(new Error(`${name} failed`));
            } else {
                console.log(`${name} 执行完成`);
                resolve(`${name} 结果`);
            }
        }, delay);
    });
};

// 添加任务
controller.add(createTask('任务1', 1000), 1);
controller.add(createTask('任务2', 500), 3);  // 高优先级
controller.add(createTask('任务3', 800), 2);
controller.add(createTask('任务4', 300), 1);

console.log('当前状态:', controller.getStatus());
```

---

### 🛠️ 工具函数实现类

#### 6. 手写深拷贝 (必考⭐⭐⭐⭐⭐)

**考察点**: 对象遍历、循环引用、类型判断

```javascript
function deepClone(obj, cache = new WeakMap()) {
    // 处理基本类型和null
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // 处理Date对象
    if (obj instanceof Date) {
        return new Date(obj);
    }

    // 处理RegExp对象
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }

    // 处理函数
    if (typeof obj === 'function') {
        return obj; // 函数通常不需要深拷贝
    }

    // 处理循环引用
    if (cache.has(obj)) {
        return cache.get(obj);
    }

    // 创建新对象，保持原型链
    let cloned;
    if (obj instanceof Array) {
        cloned = [];
    } else if (obj instanceof Set) {
        cloned = new Set();
    } else if (obj instanceof Map) {
        cloned = new Map();
    } else {
        cloned = Object.create(Object.getPrototypeOf(obj));
    }

    // 缓存当前对象
    cache.set(obj, cloned);

    // 处理Set
    if (obj instanceof Set) {
        obj.forEach(item => {
            cloned.add(deepClone(item, cache));
        });
        return cloned;
    }

    // 处理Map
    if (obj instanceof Map) {
        obj.forEach((value, key) => {
            cloned.set(deepClone(key, cache), deepClone(value, cache));
        });
        return cloned;
    }

    // 处理对象和数组
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloned[key] = deepClone(obj[key], cache);
        }
    }

    // 处理Symbol属性
    const symbolKeys = Object.getOwnPropertySymbols(obj);
    symbolKeys.forEach(symbolKey => {
        cloned[symbolKey] = deepClone(obj[symbolKey], cache);
    });

    return cloned;
}

// 测试用例
const original = {
    name: '张三',
    age: 25,
    hobbies: ['reading', 'coding'],
    address: {
        city: '北京',
        district: '朝阳区'
    },
    date: new Date(),
    regex: /abc/g,
    map: new Map([['key1', 'value1']]),
    set: new Set([1, 2, 3])
};

// 添加循环引用
original.self = original;

const cloned = deepClone(original);

console.log(cloned.name); // 张三
console.log(cloned.hobbies === original.hobbies); // false
console.log(cloned.self === cloned); // true (正确处理循环引用)
console.log(cloned.date instanceof Date); // true
console.log(cloned.map instanceof Map); // true
```

#### 7. 手写防抖和节流 (必考⭐⭐⭐⭐⭐)

**考察点**: 闭包、定时器、性能优化

```javascript
// 防抖：延迟执行，如果在延迟期间再次触发，则重新计时
function debounce(func, delay, immediate = false) {
    let timerId = null;
    let result;

    const debounced = function(...args) {
        const callNow = immediate && !timerId;

        clearTimeout(timerId);

        timerId = setTimeout(() => {
            timerId = null;
            if (!immediate) {
                result = func.apply(this, args);
            }
        }, delay);

        if (callNow) {
            result = func.apply(this, args);
        }

        return result;
    };

    // 取消防抖
    debounced.cancel = function() {
        clearTimeout(timerId);
        timerId = null;
    };

    // 立即执行
    debounced.flush = function(...args) {
        clearTimeout(timerId);
        timerId = null;
        return func.apply(this, args);
    };

    return debounced;
}

// 节流：固定时间间隔执行
function throttle(func, delay, options = {}) {
    let timerId = null;
    let lastCallTime = 0;
    let lastResult;

    const { leading = true, trailing = true } = options;

    const throttled = function(...args) {
        const now = Date.now();

        // 如果不允许前缘执行，且是第一次调用
        if (!leading && lastCallTime === 0) {
            lastCallTime = now;
        }

        const remaining = delay - (now - lastCallTime);

        if (remaining <= 0 || remaining > delay) {
            // 立即执行
            if (timerId) {
                clearTimeout(timerId);
                timerId = null;
            }

            lastCallTime = now;
            lastResult = func.apply(this, args);
        } else if (!timerId && trailing) {
            // 设置尾部执行
            timerId = setTimeout(() => {
                lastCallTime = Date.now();
                timerId = null;
                lastResult = func.apply(this, args);
            }, remaining);
        }

        return lastResult;
    };

    // 取消节流
    throttled.cancel = function() {
        clearTimeout(timerId);
        timerId = null;
        lastCallTime = 0;
    };

    return throttled;
}

// 高级版本：支持时间戳和定时器混合模式
function advancedThrottle(func, delay) {
    let lastCallTime = 0;
    let timerId = null;

    return function(...args) {
        const now = Date.now();
        const remaining = delay - (now - lastCallTime);

        if (remaining <= 0) {
            // 时间戳模式：立即执行
            if (timerId) {
                clearTimeout(timerId);
                timerId = null;
            }
            lastCallTime = now;
            return func.apply(this, args);
        } else if (!timerId) {
            // 定时器模式：延迟执行
            timerId = setTimeout(() => {
                lastCallTime = Date.now();
                timerId = null;
                func.apply(this, args);
            }, remaining);
        }
    };
}

// 测试用例
let count = 0;
const increment = () => {
    count++;
    console.log(`执行次数: ${count}`);
};

// 防抖测试
const debouncedIncrement = debounce(increment, 1000);
debouncedIncrement(); // 不会立即执行
debouncedIncrement(); // 重置计时器
debouncedIncrement(); // 1秒后执行一次

// 节流测试
const throttledIncrement = throttle(increment, 1000);
throttledIncrement(); // 立即执行
throttledIncrement(); // 被忽略
throttledIncrement(); // 被忽略
```

#### 8. 手写柯里化 (高频⭐⭐⭐⭐)

**考察点**: 函数式编程、闭包、参数收集

```javascript
// 基础柯里化实现
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

// 高级柯里化：支持占位符
function advancedCurry(fn, placeholder = curry.placeholder) {
    const arity = fn.length;

    return function curried(...args) {
        // 过滤占位符，获取有效参数
        const validArgs = args.slice(0, arity);

        if (validArgs.length >= arity &&
            !validArgs.includes(placeholder)) {
            return fn.apply(this, validArgs);
        } else {
            return function(...nextArgs) {
                // 合并参数，用新参数替换占位符
                const mergedArgs = mergeArgs(validArgs, nextArgs, placeholder);
                return curried.apply(this, mergedArgs);
            };
        }
    };
}

// 占位符
advancedCurry.placeholder = Symbol('placeholder');

// 合并参数的辅助函数
function mergeArgs(args1, args2, placeholder) {
    const merged = [...args1];
    let args2Index = 0;

    // 替换占位符
    for (let i = 0; i < merged.length && args2Index < args2.length; i++) {
        if (merged[i] === placeholder) {
            merged[i] = args2[args2Index++];
        }
    }

    // 添加剩余参数
    while (args2Index < args2.length) {
        merged.push(args2[args2Index++]);
    }

    return merged;
}

// 无限参数柯里化
function infiniteCurry(fn) {
    return function curried(...args) {
        if (args.length === 0) {
            return fn();
        }
        return function(...nextArgs) {
            if (nextArgs.length === 0) {
                return fn(...args);
            }
            return curried(...args, ...nextArgs);
        };
    };
}

// 测试用例
// 基础柯里化测试
function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6

// 占位符测试
const _ = advancedCurry.placeholder;
const advancedCurriedAdd = advancedCurry(add);

console.log(advancedCurriedAdd(1, _, 3)(2)); // 6
console.log(advancedCurriedAdd(_, 2, 3)(1)); // 6

// 无限参数测试
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

const curriedSum = infiniteCurry(sum);
console.log(curriedSum(1)(2)(3)(4)()); // 10
```

---

### 📊 数据结构与算法类

#### 9. 手写数组去重与扁平化 (必考⭐⭐⭐⭐⭐)

**考察点**: 数组操作、性能优化、边界处理

```javascript
// 数组去重 - 多种实现方式
class ArrayDeduplication {
    // ES6 Set实现（推荐）
    static bySet(arr) {
        return [...new Set(arr)];
    }

    // Map实现（处理对象去重）
    static byMap(arr, keyFn) {
        const map = new Map();
        const result = [];

        for (const item of arr) {
            const key = keyFn ? keyFn(item) : item;
            if (!map.has(key)) {
                map.set(key, true);
                result.push(item);
            }
        }

        return result;
    }

    // 对象去重（基于属性）
    static byProperty(arr, property) {
        const seen = new Set();
        return arr.filter(item => {
            const key = item[property];
            if (seen.has(key)) {
                return false;
            }
            seen.add(key);
            return true;
        });
    }

    // 双重循环实现（兼容性好）
    static byLoop(arr) {
        const result = [];
        for (let i = 0; i < arr.length; i++) {
            let isDuplicate = false;
            for (let j = 0; j < result.length; j++) {
                if (arr[i] === result[j]) {
                    isDuplicate = true;
                    break;
                }
            }
            if (!isDuplicate) {
                result.push(arr[i]);
            }
        }
        return result;
    }
}

// 数组扁平化实现
class ArrayFlattening {
    // 递归实现
    static recursive(arr, depth = Infinity) {
        const result = [];

        for (const item of arr) {
            if (Array.isArray(item) && depth > 0) {
                result.push(...ArrayFlattening.recursive(item, depth - 1));
            } else {
                result.push(item);
            }
        }

        return result;
    }

    // 迭代实现（栈）
    static iterative(arr) {
        const result = [];
        const stack = [...arr];

        while (stack.length) {
            const item = stack.pop();
            if (Array.isArray(item)) {
                stack.push(...item);
            } else {
                result.unshift(item);
            }
        }

        return result;
    }

    // 使用reduce实现
    static byReduce(arr) {
        return arr.reduce((acc, item) => {
            return acc.concat(
                Array.isArray(item)
                    ? ArrayFlattening.byReduce(item)
                    : item
            );
        }, []);
    }

    // toString实现（限制：只能处理数字和字符串）
    static byToString(arr) {
        return arr.toString().split(',').map(item => {
            return isNaN(Number(item)) ? item : Number(item);
        });
    }
}

// 测试用例
console.log(ArrayDeduplication.bySet([1, 2, 2, 3, 4, 4])); // [1, 2, 3, 4]

const users = [
    { id: 1, name: '张三' },
    { id: 2, name: '李四' },
    { id: 1, name: '张三' }
];
console.log(ArrayDeduplication.byProperty(users, 'id')); // 去重后的用户数组

console.log(ArrayFlattening.recursive([1, [2, [3, 4]], 5])); // [1, 2, 3, 4, 5]
console.log(ArrayFlattening.recursive([1, [2, [3, 4]], 5], 1)); // [1, 2, [3, 4], 5]
```

#### 10. 手写排序算法 (高频⭐⭐⭐⭐)

**考察点**: 算法实现、时间复杂度、稳定性

```javascript
class SortingAlgorithms {
    // 快速排序（最常考）
    static quickSort(arr, left = 0, right = arr.length - 1) {
        if (left >= right) return arr;

        const pivotIndex = SortingAlgorithms.partition(arr, left, right);
        SortingAlgorithms.quickSort(arr, left, pivotIndex - 1);
        SortingAlgorithms.quickSort(arr, pivotIndex + 1, right);

        return arr;
    }

    static partition(arr, left, right) {
        const pivot = arr[right];
        let i = left - 1;

        for (let j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
        return i + 1;
    }

    // 归并排序（稳定排序）
    static mergeSort(arr) {
        if (arr.length <= 1) return arr;

        const mid = Math.floor(arr.length / 2);
        const left = SortingAlgorithms.mergeSort(arr.slice(0, mid));
        const right = SortingAlgorithms.mergeSort(arr.slice(mid));

        return SortingAlgorithms.merge(left, right);
    }

    static merge(left, right) {
        const result = [];
        let i = 0, j = 0;

        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                result.push(left[i++]);
            } else {
                result.push(right[j++]);
            }
        }

        return result.concat(left.slice(i), right.slice(j));
    }

    // 堆排序
    static heapSort(arr) {
        const len = arr.length;

        // 构建最大堆
        for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
            SortingAlgorithms.heapify(arr, len, i);
        }

        // 排序
        for (let i = len - 1; i > 0; i--) {
            [arr[0], arr[i]] = [arr[i], arr[0]];
            SortingAlgorithms.heapify(arr, i, 0);
        }

        return arr;
    }

    static heapify(arr, n, i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }

        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }

        if (largest !== i) {
            [arr[i], arr[largest]] = [arr[largest], arr[i]];
            SortingAlgorithms.heapify(arr, n, largest);
        }
    }

    // 冒泡排序（教学用）
    static bubbleSort(arr) {
        const len = arr.length;
        for (let i = 0; i < len - 1; i++) {
            let swapped = false;
            for (let j = 0; j < len - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                    swapped = true;
                }
            }
            if (!swapped) break; // 优化：如果没有交换，说明已排序
        }
        return arr;
    }
}

// 测试用例
const testArray = [64, 34, 25, 12, 22, 11, 90];
console.log('快速排序:', SortingAlgorithms.quickSort([...testArray]));
console.log('归并排序:', SortingAlgorithms.mergeSort([...testArray]));
console.log('堆排序:', SortingAlgorithms.heapSort([...testArray]));
```

#### 11. 手写二分查找 (高频⭐⭐⭐⭐)

**考察点**: 算法思维、边界处理、时间复杂度

```javascript
class BinarySearch {
    // 基础二分查找
    static basic(arr, target) {
        let left = 0;
        let right = arr.length - 1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (arr[mid] === target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return -1;
    }

    // 查找第一个等于target的位置
    static findFirst(arr, target) {
        let left = 0;
        let right = arr.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (arr[mid] === target) {
                result = mid;
                right = mid - 1; // 继续向左查找
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    // 查找最后一个等于target的位置
    static findLast(arr, target) {
        let left = 0;
        let right = arr.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (arr[mid] === target) {
                result = mid;
                left = mid + 1; // 继续向右查找
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    // 查找第一个大于等于target的位置
    static lowerBound(arr, target) {
        let left = 0;
        let right = arr.length;

        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    // 查找第一个大于target的位置
    static upperBound(arr, target) {
        let left = 0;
        let right = arr.length;

        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (arr[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    // 在旋转数组中查找
    static searchRotated(arr, target) {
        let left = 0;
        let right = arr.length - 1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (arr[mid] === target) {
                return mid;
            }

            // 判断哪一边是有序的
            if (arr[left] <= arr[mid]) {
                // 左半边有序
                if (target >= arr[left] && target < arr[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // 右半边有序
                if (target > arr[mid] && target <= arr[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }
}

// 测试用例
const sortedArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(BinarySearch.basic(sortedArray, 5)); // 4

const duplicateArray = [1, 2, 2, 2, 3, 4, 5];
console.log(BinarySearch.findFirst(duplicateArray, 2)); // 1
console.log(BinarySearch.findLast(duplicateArray, 2)); // 3

const rotatedArray = [4, 5, 6, 7, 0, 1, 2];
console.log(BinarySearch.searchRotated(rotatedArray, 0)); // 4
```

---

### 🎨 设计模式实现类

#### 12. 手写观察者模式与发布订阅模式 (高频⭐⭐⭐⭐)

**考察点**: 设计模式、事件系统、解耦设计

```javascript
// 观察者模式
class Observer {
    update(data) {
        throw new Error('Observer.update() must be implemented');
    }
}

class Subject {
    constructor() {
        this.observers = [];
    }

    addObserver(observer) {
        if (observer instanceof Observer) {
            this.observers.push(observer);
        } else {
            throw new Error('Observer must be an instance of Observer class');
        }
    }

    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index > -1) {
            this.observers.splice(index, 1);
        }
    }

    notifyObservers(data) {
        this.observers.forEach(observer => {
            observer.update(data);
        });
    }
}

// 具体观察者实现
class ConcreteObserver extends Observer {
    constructor(name) {
        super();
        this.name = name;
    }

    update(data) {
        console.log(`${this.name} 收到数据:`, data);
    }
}

// 发布订阅模式（更灵活）
class EventEmitter {
    constructor() {
        this.events = new Map();
    }

    // 订阅事件
    on(eventName, callback, options = {}) {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }

        const listener = {
            callback,
            once: options.once || false,
            priority: options.priority || 0
        };

        const listeners = this.events.get(eventName);

        // 按优先级插入
        let insertIndex = listeners.length;
        for (let i = 0; i < listeners.length; i++) {
            if (listeners[i].priority < listener.priority) {
                insertIndex = i;
                break;
            }
        }

        listeners.splice(insertIndex, 0, listener);
    }

    // 一次性订阅
    once(eventName, callback, options = {}) {
        this.on(eventName, callback, { ...options, once: true });
    }

    // 发布事件
    emit(eventName, ...args) {
        if (!this.events.has(eventName)) {
            return false;
        }

        const listeners = this.events.get(eventName);
        const toRemove = [];

        listeners.forEach((listener, index) => {
            try {
                listener.callback.apply(this, args);
                if (listener.once) {
                    toRemove.push(index);
                }
            } catch (error) {
                console.error('Event listener error:', error);
            }
        });

        // 移除一次性监听器
        toRemove.reverse().forEach(index => {
            listeners.splice(index, 1);
        });

        return true;
    }

    // 取消订阅
    off(eventName, callback) {
        if (!this.events.has(eventName)) {
            return false;
        }

        const listeners = this.events.get(eventName);
        const index = listeners.findIndex(listener => listener.callback === callback);

        if (index > -1) {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
                this.events.delete(eventName);
            }
            return true;
        }

        return false;
    }

    // 移除所有监听器
    removeAllListeners(eventName) {
        if (eventName) {
            this.events.delete(eventName);
        } else {
            this.events.clear();
        }
    }

    // 获取监听器数量
    listenerCount(eventName) {
        return this.events.has(eventName) ? this.events.get(eventName).length : 0;
    }
}

// 高级版本：支持命名空间和通配符
class AdvancedEventEmitter extends EventEmitter {
    // 支持通配符订阅
    on(eventName, callback, options = {}) {
        if (eventName.includes('*')) {
            return this.onWildcard(eventName, callback, options);
        }
        return super.on(eventName, callback, options);
    }

    onWildcard(pattern, callback, options = {}) {
        const wildcardListeners = this.events.get('*') || [];
        wildcardListeners.push({
            pattern: new RegExp(pattern.replace(/\*/g, '.*')),
            callback,
            once: options.once || false,
            priority: options.priority || 0
        });
        this.events.set('*', wildcardListeners);
    }

    emit(eventName, ...args) {
        // 先触发精确匹配的监听器
        const result = super.emit(eventName, ...args);

        // 再触发通配符匹配的监听器
        const wildcardListeners = this.events.get('*') || [];
        const toRemove = [];

        wildcardListeners.forEach((listener, index) => {
            if (listener.pattern.test(eventName)) {
                try {
                    listener.callback.apply(this, args);
                    if (listener.once) {
                        toRemove.push(index);
                    }
                } catch (error) {
                    console.error('Wildcard listener error:', error);
                }
            }
        });

        // 移除一次性通配符监听器
        toRemove.reverse().forEach(index => {
            wildcardListeners.splice(index, 1);
        });

        return result || wildcardListeners.length > 0;
    }
}

// 测试用例
// 观察者模式测试
const subject = new Subject();
const observer1 = new ConcreteObserver('观察者1');
const observer2 = new ConcreteObserver('观察者2');

subject.addObserver(observer1);
subject.addObserver(observer2);
subject.notifyObservers('测试数据'); // 两个观察者都会收到

// 发布订阅模式测试
const emitter = new AdvancedEventEmitter();

emitter.on('user:login', (user) => {
    console.log('用户登录:', user.name);
});

emitter.on('user:*', (user) => {
    console.log('用户事件:', user.name);
});

emitter.emit('user:login', { name: '张三' });
emitter.emit('user:logout', { name: '张三' });
```

#### 13. 手写单例模式 (高频⭐⭐⭐⭐)

**考察点**: 设计模式、闭包、类设计

```javascript
// 经典单例模式
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }

        this.data = {};
        this.createTime = new Date();

        Singleton.instance = this;
        return this;
    }

    // 静态方法获取实例
    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }

    // 业务方法
    setData(key, value) {
        this.data[key] = value;
    }

    getData(key) {
        return this.data[key];
    }
}

// 懒汉式单例（延迟创建）
class LazySingleton {
    constructor() {
        if (LazySingleton.instance) {
            return LazySingleton.instance;
        }

        this.initialized = false;
        LazySingleton.instance = this;
        return this;
    }

    init() {
        if (!this.initialized) {
            this.data = {};
            this.config = this.loadConfig();
            this.initialized = true;
            console.log('LazySingleton 已初始化');
        }
    }

    loadConfig() {
        // 模拟加载配置
        return {
            apiUrl: 'https://api.example.com',
            timeout: 5000
        };
    }

    static getInstance() {
        if (!LazySingleton.instance) {
            LazySingleton.instance = new LazySingleton();
        }
        return LazySingleton.instance;
    }
}

// 函数式单例
const FunctionSingleton = (function() {
    let instance = null;

    function init() {
        // 私有方法和属性
        let data = {};

        return {
            setData(key, value) {
                data[key] = value;
            },
            getData(key) {
                return data[key];
            },
            getAllData() {
                return { ...data };
            }
        };
    }

    return {
        getInstance() {
            if (!instance) {
                instance = init();
            }
            return instance;
        }
    };
})();

// 通用单例工厂
class SingletonFactory {
    static instances = new Map();

    static getInstance(ConstructorClass, ...args) {
        if (!this.instances.has(ConstructorClass)) {
            this.instances.set(ConstructorClass, new ConstructorClass(...args));
        }
        return this.instances.get(ConstructorClass);
    }

    static clearInstance(ConstructorClass) {
        this.instances.delete(ConstructorClass);
    }

    static clearAllInstances() {
        this.instances.clear();
    }
}

// 支持参数的单例
class ParameterizedSingleton {
    constructor(config = {}) {
        const key = JSON.stringify(config);

        if (ParameterizedSingleton.instances.has(key)) {
            return ParameterizedSingleton.instances.get(key);
        }

        this.config = config;
        this.id = Math.random().toString(36).substr(2, 9);

        ParameterizedSingleton.instances.set(key, this);
        return this;
    }

    static instances = new Map();

    static getInstance(config = {}) {
        const key = JSON.stringify(config);
        if (!this.instances.has(key)) {
            this.instances.set(key, new ParameterizedSingleton(config));
        }
        return this.instances.get(key);
    }
}

// 测试用例
// 基础单例测试
const s1 = new Singleton();
const s2 = new Singleton();
console.log(s1 === s2); // true

const s3 = Singleton.getInstance();
console.log(s1 === s3); // true

// 懒汉式单例测试
const lazy1 = LazySingleton.getInstance();
const lazy2 = LazySingleton.getInstance();
console.log(lazy1 === lazy2); // true

lazy1.init(); // 延迟初始化

// 函数式单例测试
const func1 = FunctionSingleton.getInstance();
const func2 = FunctionSingleton.getInstance();
console.log(func1 === func2); // true

// 参数化单例测试
const param1 = ParameterizedSingleton.getInstance({ theme: 'dark' });
const param2 = ParameterizedSingleton.getInstance({ theme: 'dark' });
const param3 = ParameterizedSingleton.getInstance({ theme: 'light' });

console.log(param1 === param2); // true (相同配置)
console.log(param1 === param3); // false (不同配置)
```

---

### 💡 手写题答题技巧

#### 🎯 编码规范要求

**5年经验工程师标准**:
```javascript
// ✅ 好的实现示例
function debounce(func, delay, immediate = false) {
    // 1. 参数验证
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }

    if (delay < 0) {
        throw new Error('Delay must be non-negative');
    }

    // 2. 变量声明清晰
    let timerId = null;
    let result;

    // 3. 返回函数有清晰的业务逻辑
    const debounced = function(...args) {
        // 4. 边界条件处理
        const callNow = immediate && !timerId;

        clearTimeout(timerId);

        timerId = setTimeout(() => {
            timerId = null;
            if (!immediate) {
                result = func.apply(this, args);
            }
        }, delay);

        if (callNow) {
            result = func.apply(this, args);
        }

        return result;
    };

    // 5. 扩展功能
    debounced.cancel = () => {
        clearTimeout(timerId);
        timerId = null;
    };

    return debounced;
}
```

#### 📝 答题流程标准

**每道手写题的完整流程** (10-15分钟):

1. **理解题意** (1-2分钟)
   - 确认输入输出格式
   - 询问边界条件和特殊情况
   - 明确性能要求

2. **设计思路** (2-3分钟)
   - 说明算法思路和时间复杂度
   - 选择合适的数据结构
   - 考虑优化方案

3. **编码实现** (5-8分钟)
   - 先写核心逻辑
   - 再处理边界条件
   - 添加错误处理

4. **测试验证** (2分钟)
   - 写测试用例
   - 验证边界情况
   - 说明时间空间复杂度

#### 🔥 常见失分点避免

**❌ 经常出现的问题**:
```javascript
// 1. 忘记参数验证
function badDeepClone(obj) {
    // 直接开始克隆，没有类型检查
    const result = {};
    // ...
}

// 2. 没有处理边界条件
function badBinarySearch(arr, target) {
    // 没有检查数组是否为空
    let left = 0, right = arr.length - 1;
    // ...
}

// 3. 变量命名不清晰
function badFunction(a, b, c) {
    let x = a + b;
    let y = x * c;
    return y;
}

// 4. 没有考虑性能优化
function badFlatten(arr) {
    // 使用concat导致性能问题
    return arr.reduce((acc, item) =>
        acc.concat(Array.isArray(item) ? badFlatten(item) : item), []);
}
```

**✅ 正确的实现**:
```javascript
// 1. 完整的参数验证
function goodDeepClone(obj, cache = new WeakMap()) {
    // 类型检查
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    // 后续实现...
}

// 2. 边界条件处理
function goodBinarySearch(arr, target) {
    if (!Array.isArray(arr) || arr.length === 0) {
        return -1;
    }
    // 后续实现...
}

// 3. 清晰的变量命名
function calculateTotalPrice(price, quantity, discountRate) {
    const subtotal = price * quantity;
    const finalPrice = subtotal * (1 - discountRate);
    return finalPrice;
}
```

---

### 🎯 高频考点快速检查清单

### ⭐⭐⭐⭐⭐ 核心必考 (90%+出现率)
```
□ 原型链查找过程能画图解释
□ 闭包内存模型清晰理解
□ Event Loop执行顺序秒答
□ Promise状态转换机制
□ this绑定7种场景
□ 继承的完整实现(ES5+ES6)
□ 防抖节流手写实现
□ Vue/React响应式原理
```

### ⭐⭐⭐⭐ 高频重点 (70%+出现率)
```
□ Proxy元编程应用
□ WeakMap内存管理
□ async/await错误处理
□ 虚拟DOM diff算法
□ Webpack性能优化
□ HTTP缓存策略
□ 内存泄漏排查
□ 组件设计模式
```

### ⭐⭐⭐ 加分进阶 (40%+出现率)
```
□ Fiber架构理解
□ 微前端架构
□ 设计模式应用
□ 算法复杂度分析
□ 服务端渲染SSR
□ 性能监控方案
□ 团队协作工具
□ 代码review标准
```

---

## 📝 标准答题模板

### 🎯 核心答题结构 (每题2-3分钟)

```
1. 概念定义 (30秒)
   "XXX是..."
   简洁准确地解释核心概念

2. 原理分析 (60-90秒)
   "它的工作原理是..."
   深入解释底层机制，结合代码示例

3. 应用场景 (30秒)
   "主要用于..., 比如..."
   举出具体使用场景和优势

4. 注意事项 (30秒)
   "需要注意的是..."
   提及性能、兼容性或最佳实践
```

### 💡 答题技巧要点

#### ✅ 高分要素
- **逻辑清晰**: 按照模板结构回答
- **深度合适**: 既有理论又有实践
- **代码准确**: 现场写代码无语法错误
- **举例恰当**: 结合实际项目经验

#### ❌ 扣分要点
- **概念模糊**: 基础概念说不清楚
- **代码错误**: 语法错误或逻辑问题
- **深度不够**: 只知道表面，不懂原理
- **表达混乱**: 跳跃式思维，缺乏条理

---

## 📚 6周系统学习计划

### 第1周：JavaScript核心夯实
```
周一-周二: 原型链与继承机制
- 学习资料: [原型链详解](./javascript/interview-questions/01-core-concepts/prototype-chain.md)
- 实践任务: 手写3种继承方式
- 自测题目: 复杂原型链查找题

周三-周四: 闭包与作用域
- 学习资料: [闭包详解](./javascript/闭包.md)
- 实践任务: 实现模块化模式
- 自测题目: 内存泄漏场景分析

周五-周末: this绑定与执行上下文
- 学习资料: 待补充
- 实践任务: 7种this绑定场景
- 周末总结: 核心概念思维导图
```

### 第2周：异步编程精通
```
周一-周二: Event Loop深度理解
- 学习资料: [Event Loop详解](./javascript/interview-questions/02-async-programming/event-loop.md)
- 实践任务: 复杂执行顺序题10道
- 自测题目: Node.js vs 浏览器差异

周三-周四: Promise源码实现
- 学习资料: 待补充
- 实践任务: 手写Promise A+规范
- 自测题目: 异常处理边界情况

周五-周末: async/await与并发控制
- 学习资料: 待补充
- 实践任务: 任务调度器实现
- 周末项目: 实现重试机制库
```

### 第3周：ES6+现代特性
```
周一-周二: Proxy与Reflect
- 学习重点: 元编程思想与Vue3响应式
- 实践任务: 简版响应式系统
- 对比学习: 与defineProperty差异

周三-周四: WeakMap/WeakSet与内存管理
- 学习重点: 垃圾回收机制
- 实践任务: 私有属性实现方案
- 性能测试: 内存泄漏对比

周五-周末: Symbol、Generator、模块系统
- 学习重点: 迭代器协议与异步控制
- 实践任务: 状态机实现
- 周末总结: ES6+特性地图
```

### 第4周：性能优化专项
```
周一-周二: 防抖节流与事件优化
- 学习资料: [防抖节流实现](./javascript/interview-questions/04-performance/debounce-throttle.md)
- 实践任务: 高级版本实现
- 性能测试: 不同场景对比

周三-周四: 内存优化与渲染优化
- 学习重点: 虚拟列表、懒加载
- 实践任务: 大数据量优化方案
- 工具使用: Performance监控

周五-周末: 打包优化与加载优化
- 学习重点: Tree-shaking、代码分割
- 实践任务: Webpack配置优化
- 周末项目: 性能监控方案
```

### 第5周：框架原理深入
```
周一-周三: Vue核心原理
- 响应式系统实现
- 虚拟DOM与diff算法
- 组件通信与状态管理

周四-周六: React核心原理
- Fiber架构与调度
- Hooks实现机制
- 状态管理与中间件

周日: 框架对比与选型
- 技术栈对比分析
- 适用场景总结
```

### 第6周：工程化与综合实战
```
周一-周二: 构建工具与工程化
- Webpack高级配置
- Babel插件机制
- CI/CD自动化

周三-周四: 网络与浏览器原理
- HTTP协议深度
- 浏览器渲染机制
- 安全防护方案

周五-周末: 面试模拟与总结
- 真题模拟练习
- 知识点查漏补缺
- 个人技术简历优化
```

---

## 🏆 面试成功策略

### 🎯 技术面试准备
1. **基础扎实**: 核心概念必须清晰
2. **实战经验**: 结合实际项目经验
3. **持续学习**: 关注技术发展趋势
4. **沟通能力**: 清晰表达技术思路

### 💡 常见面试流程
```
自我介绍 (3分钟)
↓
技术基础考察 (20分钟)
- JavaScript核心原理
- 异步编程机制
- 框架原理理解
↓
编码实现 (15分钟)
- 算法题或手写题
- 代码规范与优化
↓
项目经验交流 (15分钟)
- 技术选型思考
- 问题解决能力
- 团队协作经验
↓
反向提问 (5分钟)
- 技术栈发展
- 团队文化了解
```

### 🎪 高级面试技巧
- **STAR法则**: 描述项目经验时使用Situation-Task-Action-Result
- **技术深度**: 每个技术点都要能深入3-4层
- **业务理解**: 技术方案要结合业务场景
- **学习能力**: 展示持续学习和技术追求

---

## 🔗 学习资源导航

### 📖 详细文档链接
- [JavaScript概论](./javascript/JavaScript概论.md)
- [闭包深度解析](./javascript/闭包.md)
- [面试题库总览](./javascript/interview-questions/README.md)
- [原型链详解](./javascript/interview-questions/01-core-concepts/prototype-chain.md)
- [Event Loop深入](./javascript/interview-questions/02-async-programming/event-loop.md)
- [防抖节流实现](./javascript/interview-questions/04-performance/debounce-throttle.md)

### 🛠️ 推荐工具
- **代码练习**: LeetCode、牛客网
- **性能监控**: Chrome DevTools、Lighthouse
- **文档查阅**: MDN、ECMAScript规范
- **源码学习**: Vue.js、React官方仓库

### 📚 学习建议
1. **理论与实践结合**: 不要只背概念，要能写出代码
2. **源码阅读**: 深入理解框架原理
3. **项目实战**: 在实际项目中应用所学知识
4. **技术分享**: 通过输出来深化理解

---

## ⚡ 快速自测

### 🔥 30秒快问快答
```javascript
// 能立即说出答案吗？
1. [1,2,3].map(parseInt) 的结果？
2. 0.1 + 0.2 === 0.3 为什么是false？
3. typeof null 的结果是什么？
4. [] == ![] 的结果？
5. setTimeout vs setImmediate 执行顺序？
```

### 💻 2分钟编码挑战
```javascript
// 能在2分钟内写出吗？
1. 实现深拷贝函数（处理循环引用）
2. 实现防抖函数（支持立即执行）
3. 实现Promise.all方法
4. 实现instanceof操作符
5. 实现函数柯里化
```

如果以上问题你能快速准确回答，恭喜你已经具备了5年前端工程师的核心技能！

---

> 💡 **学习心得**: 面试不仅仅是技术考察，更是对**思维能力**、**学习能力**和**沟通能力**的综合评估。保持技术热情，持续学习进步，相信你一定能在面试中脱颖而出！

**记住：技术深度决定你的上限，学习态度决定你的未来！🚀**