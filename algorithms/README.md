# 算法学习指南 🚀

欢迎来到算法学习项目！这个项目旨在通过JavaScript实现常见算法，帮助你系统性地学习数据结构与算法。

## 📚 学习路径

### 🎯 学习目标
- 理解算法的基本原理和思维方式
- 掌握常见数据结构的操作
- 学会分析时间和空间复杂度
- 培养解决问题的系统性思维

### 📋 学习建议
1. **理论先行**: 先理解算法原理，再看代码实现
2. **动手实践**: 亲自运行代码，观察执行过程
3. **举一反三**: 思考算法的变形和应用场景
4. **复杂度分析**: 每个算法都要分析时间和空间复杂度

## 📁 项目结构

```
algorithms/
├── README.md                 # 项目总览和学习指南
├── basic/                    # 基础算法
│   ├── 01-array/            # 数组相关算法
│   ├── 02-string/           # 字符串算法
│   ├── 03-sorting/          # 排序算法
│   └── 04-searching/        # 查找算法
├── intermediate/            # 中等难度算法
│   ├── 01-linked-list/     # 链表算法
│   ├── 02-tree/            # 树算法
│   ├── 03-dynamic-programming/ # 动态规划
│   └── 04-backtracking/    # 回溯算法
└── utils/                  # 工具函数
    └── test-helpers.js
```

## 🎓 基础算法（Basic）

### 📊 数组算法
**学习重点**: 双指针技巧、滑动窗口、原地操作

- **[两数之和](./basic/01-array/two-sum.js)**
  - 🎯 **目标**: 在数组中找到两个数字，使它们相加等于目标值
  - 💡 **核心思路**: 哈希表优化查找
  - ⏰ **复杂度**: O(n) 时间，O(n) 空间
  - 🔍 **关键点**: 用空间换时间的经典案例

- **[删除重复项](./basic/01-array/remove-duplicates.js)**
  - 🎯 **目标**: 原地删除排序数组中的重复元素
  - 💡 **核心思路**: 双指针法，快慢指针配合
  - ⏰ **复杂度**: O(n) 时间，O(1) 空间
  - 🔍 **关键点**: 原地算法的思维方式

### 🔤 字符串算法
**学习重点**: 双指针、回文判断、字符串处理

- **[反转字符串](./basic/02-string/reverse-string.js)**
  - 🎯 **目标**: 原地反转字符数组
  - 💡 **核心思路**: 首尾双指针交换
  - ⏰ **复杂度**: O(n) 时间，O(1) 空间
  - 🔍 **关键点**: 对称性问题的通用解法

- **[回文字符串](./basic/02-string/palindrome.js)**
  - 🎯 **目标**: 验证回文串、找最长回文子串
  - 💡 **核心思路**: 双指针验证、中心扩展算法
  - ⏰ **复杂度**: O(n) 验证，O(n²) 查找
  - 🔍 **关键点**: 中心扩展的巧妙应用

### 🔄 排序算法
**学习重点**: 比较排序、时间复杂度分析、稳定性

- **[冒泡排序](./basic/03-sorting/bubble-sort.js)**
  - 🎯 **目标**: 通过相邻元素比较实现排序
  - 💡 **核心思路**: 每轮冒泡出一个最值
  - ⏰ **复杂度**: O(n²) 时间，O(1) 空间
  - 🔍 **关键点**: 理解排序算法的基本思想

## 🚀 中等算法（Intermediate）

### 🔗 链表算法
**学习重点**: 指针操作、链表反转、双指针技巧

- **[反转链表](./intermediate/01-linked-list/reverse-linked-list.js)**
  - 🎯 **目标**: 反转单链表的指向
  - 💡 **核心思路**: 三指针迭代，递归思维
  - ⏰ **复杂度**: O(n) 时间，O(1)/O(n) 空间
  - 🔍 **关键点**: 指针操作的经典案例

### 🌟 动态规划
**学习重点**: 最优子结构、状态转移方程、记忆化

- **[斐波那契数列](./intermediate/03-dynamic-programming/fibonacci.js)**
  - 🎯 **目标**: 计算斐波那契数列第n项
  - 💡 **核心思路**: 状态转移，空间优化
  - ⏰ **复杂度**: 从O(2^n)优化到O(n)甚至O(log n)
  - 🔍 **关键点**: 动态规划的入门经典

## 🔧 如何运行代码

### 运行单个算法
```bash
# 进入算法目录
cd algorithms

# 运行具体算法文件
node basic/01-array/two-sum.js
node basic/02-string/palindrome.js
node intermediate/01-linked-list/reverse-linked-list.js
```

### 在Node.js中使用
```javascript
// 引入算法模块
const { twoSum } = require('./basic/01-array/two-sum.js');
const { isPalindrome } = require('./basic/02-string/palindrome.js');

// 使用算法
const nums = [2, 7, 11, 15];
const target = 9;
const result = twoSum(nums, target);
console.log(result); // [0, 1]
```

## 📊 复杂度分析指南

### 时间复杂度常见级别
- **O(1)** - 常数时间：哈希表查找
- **O(log n)** - 对数时间：二分查找、堆操作
- **O(n)** - 线性时间：遍历数组、链表
- **O(n log n)** - 线性对数：归并排序、堆排序
- **O(n²)** - 平方时间：冒泡排序、选择排序
- **O(2^n)** - 指数时间：递归斐波那契

### 空间复杂度分析要点
- **原地算法**: O(1) 额外空间
- **递归调用栈**: 通常为 O(递归深度)
- **辅助数据结构**: 如哈希表、数组的空间占用

## 💡 算法学习技巧

### 🤔 思考框架
1. **理解题意**: 明确输入输出，理解约束条件
2. **分析例子**: 手工模拟几个例子的执行过程
3. **寻找规律**: 发现问题的本质和规律性
4. **选择方法**: 根据数据规模选择合适算法
5. **编码实现**: 先写主逻辑，再处理边界情况
6. **测试验证**: 用多个测试用例验证正确性
7. **优化改进**: 分析复杂度，寻找优化空间

### 🎯 常见解题技巧
- **双指针**: 适用于数组、字符串、链表问题
- **滑动窗口**: 处理子数组/子字符串问题
- **哈希表**: 用空间换时间，快速查找
- **递归**: 将大问题分解为小问题
- **动态规划**: 记录子问题结果，避免重复计算
- **贪心算法**: 每步都做局部最优选择

## 🎪 实践建议

### 📅 学习计划
1. **第1周**: 数组和字符串基础算法
2. **第2周**: 排序和查找算法
3. **第3周**: 链表操作和指针技巧
4. **第4周**: 动态规划入门

### 🏃‍♂️ 练习方法
- **每日一题**: 每天至少学习一个算法
- **手写实现**: 不看答案自己实现一遍
- **复杂度分析**: 分析每个算法的时间空间复杂度
- **变式思考**: 考虑问题的变形和扩展

### 🔍 深入学习
- **可视化工具**: 使用算法可视化网站观察执行过程
- **性能测试**: 对比不同算法的实际运行效率
- **源码阅读**: 阅读经典算法库的实现源码
- **面试准备**: 练习手写代码和口述思路

## 🌟 进阶方向

### 高级数据结构
- 树（二叉树、平衡树、堆）
- 图（DFS、BFS、最短路径）
- 并查集、线段树、字典树

### 高级算法技巧
- 分治算法、回溯算法
- 动态规划进阶应用
- 图论算法、字符串算法

### 实际应用场景
- 系统设计中的算法应用
- 前端开发中的算法优化
- 数据处理和分析算法

## 🤝 参与贡献

如果你发现问题或有改进建议：
1. 提交Issue描述问题
2. Fork项目并进行修改
3. 提交Pull Request

记住：**算法学习是一个循序渐进的过程，坚持练习是成功的关键！** 🎯

---

**祝学习愉快！如果觉得这个项目对你有帮助，别忘了给个⭐️！**