# 🌐 计算机网络通信协议详解

欢迎进入网络通信协议的奇妙世界！这份文档将带你系统性地理解现代网络通信的核心机制。

## 📚 学习目标

掌握本文档后，你将能够：
- 🎯 深入理解网络协议的分层架构
- 💡 掌握主流通信协议的工作原理
- 🛠️ 具备网络问题的诊断和调试能力
- 🔐 理解网络安全协议的重要性
- ⚡ 优化应用的网络性能

---

## 🎯 协议基础概念

### 🤔 什么是网络通信协议？

**网络通信协议**就像是不同设备之间交流的"语言规则"。想象一下两个人要通信：
- 他们需要使用相同的语言（协议标准）
- 要遵循一定的对话规则（消息格式）
- 确保信息准确传达（错误检测与恢复）

```
发送方                    接收方
  📱  →  [网络协议]  →      🖥️
 "Hello"   按规则编码     解码显示
```

### 🏗️ 协议分层架构

计算机网络采用分层设计，每层只关心自己的职责，这样的设计让网络系统：
- ✅ **模块化**：各层独立开发和维护
- ✅ **可扩展**：新协议可以在特定层添加
- ✅ **易调试**：问题定位更加精确

#### OSI 七层模型 vs TCP/IP 四层模型

```
┌─────────────────┬──────────────────┬─────────────────────┐
│   OSI 七层模型    │   TCP/IP 四层     │    常见协议          │
├─────────────────┼──────────────────┼─────────────────────┤
│ 应用层(Application) │                  │ HTTP, HTTPS, FTP,   │
│ 表示层(Presentation)│   应用层          │ DNS, SMTP, SSH,     │
│ 会话层(Session)     │                  │ WebSocket, gRPC     │
├─────────────────┼──────────────────┼─────────────────────┤
│ 传输层(Transport)  │   传输层          │ TCP, UDP, QUIC      │
├─────────────────┼──────────────────┼─────────────────────┤
│ 网络层(Network)    │   网络层          │ IP, ICMP, ARP       │
├─────────────────┼──────────────────┼─────────────────────┤
│ 数据链路层(Data Link)│   网络接口层      │ Ethernet, WiFi      │
│ 物理层(Physical)   │                  │ 光纤, 双绞线         │
└─────────────────┴──────────────────┴─────────────────────┘
```

#### 🔄 协议栈工作流程

当你在浏览器输入 `https://www.example.com` 时：

```
浏览器发送请求：
┌─────────────────────────────────────────┐
│ 应用层: HTTP GET /                        │ ← 用户看到的
├─────────────────────────────────────────┤
│ 传输层: TCP 443端口，分片，错误检测        │ ← 可靠传输
├─────────────────────────────────────────┤
│ 网络层: IP 路由寻址，跨网络传输           │ ← 路径选择
├─────────────────────────────────────────┤
│ 链路层: 以太网帧，本地网络传输           │ ← 物理传输
└─────────────────────────────────────────┘
```

### 💭 理解协议设计哲学

每个协议都有其设计目标和权衡：

| 设计目标 | 优势 | 代价 | 典型协议 |
|---------|-----|-----|----------|
| **可靠性** | 数据完整准确 | 性能开销 | TCP |
| **速度** | 低延迟传输 | 可能丢失 | UDP |
| **安全性** | 数据加密保护 | 计算开销 | HTTPS, TLS |
| **简单性** | 易实现维护 | 功能限制 | HTTP/1.1 |
| **扩展性** | 功能丰富 | 复杂度高 | HTTP/2 |

---

## 📱 应用层协议详解

应用层协议直接为用户提供网络服务，是开发者最常接触的协议层。

### 🌐 HTTP/HTTPS - Web通信基石

HTTP(超文本传输协议)是互联网的基础，让我们深入理解它：

#### 🔍 HTTP 请求-响应模型

```
客户端                     服务器
   │                        │
   ├── HTTP Request ────────→│
   │   GET /api/users        │
   │   Host: api.example.com │
   │   Accept: application/json │
   │                        │
   │←─── HTTP Response ──────┤
   │   200 OK                │
   │   Content-Type: json    │
   │   {"users": [...]}      │
```

#### 📊 HTTP 版本演进

**HTTP/1.1** (1997年):
- ✅ 持久连接：一个TCP连接多个请求
- ✅ 管道化：并行发送请求
- ❌ 队头阻塞：前面请求阻塞后续请求

```javascript
// HTTP/1.1 的问题演示
async function http1Problem() {
  // 这些请求会按顺序执行，慢请求阻塞后续请求
  const responses = [];

  responses[0] = await fetch('/slow-api');      // 耗时2秒
  responses[1] = await fetch('/fast-api-1');   // 被阻塞
  responses[2] = await fetch('/fast-api-2');   // 被阻塞

  return responses;
}
```

**HTTP/2** (2015年):
- ✅ 多路复用：单连接并行多个请求
- ✅ 服务器推送：主动推送资源
- ✅ 头部压缩：减少重复头信息

```javascript
// HTTP/2 的优势
async function http2Advantage() {
  // 这些请求可以真正并行执行
  const responses = await Promise.all([
    fetch('/slow-api'),      // 2秒，不阻塞其他
    fetch('/fast-api-1'),   // 100ms，立即返回
    fetch('/fast-api-2')    // 100ms，立即返回
  ]);

  return responses; // 总耗时约2秒，不是2.2秒
}
```

**HTTP/3** (基于QUIC):
- ✅ 基于UDP：避免TCP的队头阻塞
- ✅ 0-RTT连接：更快的连接建立
- ✅ 连接迁移：网络切换无需重连

#### 🛠️ HTTP 实践代码

```javascript
// 现代 HTTP 客户端实现
class ModernHTTPClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'User-Agent': 'ModernClient/1.0',
      ...options.headers
    };
  }

  async request(method, url, options = {}) {
    const fullURL = new URL(url, this.baseURL);

    const config = {
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    };

    // 请求拦截器
    console.log(`🚀 ${method.toUpperCase()} ${fullURL}`);
    const startTime = Date.now();

    try {
      const response = await fetch(fullURL, config);
      const duration = Date.now() - startTime;

      // 响应拦截器
      console.log(`✅ ${response.status} (${duration}ms)`);

      if (!response.ok) {
        throw new HTTPError(response.status, response.statusText);
      }

      return this.parseResponse(response);
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`❌ 请求失败 (${duration}ms):`, error.message);
      throw error;
    }
  }

  async parseResponse(response) {
    const contentType = response.headers.get('content-type');

    if (contentType?.includes('application/json')) {
      return { data: await response.json(), headers: response.headers };
    } else if (contentType?.includes('text/')) {
      return { data: await response.text(), headers: response.headers };
    } else {
      return { data: await response.blob(), headers: response.headers };
    }
  }

  // 便捷方法
  get(url, options) { return this.request('GET', url, options); }
  post(url, data, options) {
    return this.request('POST', url, {
      ...options,
      body: JSON.stringify(data)
    });
  }
  put(url, data, options) {
    return this.request('PUT', url, {
      ...options,
      body: JSON.stringify(data)
    });
  }
  delete(url, options) { return this.request('DELETE', url, options); }
}

class HTTPError extends Error {
  constructor(status, statusText) {
    super(`HTTP ${status}: ${statusText}`);
    this.status = status;
    this.statusText = statusText;
  }
}

// 使用示例
const client = new ModernHTTPClient('https://api.github.com');

async function demonstrateHTTP() {
  try {
    // GET 请求
    const { data: user } = await client.get('/users/octocat');
    console.log('用户信息:', user.name);

    // POST 请求（示例）
    const { data: created } = await client.post('/user/repos', {
      name: 'test-repo',
      description: 'HTTP 协议学习项目'
    });

  } catch (error) {
    if (error instanceof HTTPError) {
      console.error('HTTP错误:', error.status, error.statusText);
    } else {
      console.error('网络错误:', error.message);
    }
  }
}
```

#### 🔐 HTTPS - 安全的HTTP

HTTPS = HTTP + TLS/SSL，让我们看看安全层如何工作：

```
HTTPS 握手过程：
客户端                          服务器
  │                             │
  ├─ 1. Client Hello ──────────→│ (支持的加密算法)
  │←─ 2. Server Hello ──────────┤ (选择的算法 + 证书)
  │←─ 3. Certificate ──────────│ (公钥证书)
  ├─ 4. Key Exchange ─────────→│ (加密的预主密钥)
  │←─ 5. Server Finished ──────┤
  ├─ 6. Client Finished ──────→│
  │                             │
  ├─── 加密的HTTP通信 ←─────────→│
```

```javascript
// TLS/SSL 证书验证工具
const https = require('https');
const tls = require('tls');

class CertificateChecker {
  async checkCertificate(hostname, port = 443) {
    return new Promise((resolve, reject) => {
      const socket = tls.connect(port, hostname, {
        servername: hostname // SNI support
      }, () => {
        const cert = socket.getPeerCertificate(true);
        const result = this.analyzeCertificate(cert);
        socket.end();
        resolve(result);
      });

      socket.on('error', reject);
    });
  }

  analyzeCertificate(cert) {
    const now = new Date();
    const validFrom = new Date(cert.valid_from);
    const validTo = new Date(cert.valid_to);

    return {
      subject: cert.subject.CN,
      issuer: cert.issuer.CN,
      valid_from: validFrom.toISOString(),
      valid_to: validTo.toISOString(),
      days_until_expiry: Math.ceil((validTo - now) / (1000 * 60 * 60 * 24)),
      fingerprint: cert.fingerprint,
      is_valid: now >= validFrom && now <= validTo,
      algorithm: cert.sigalg
    };
  }
}

// 使用示例
async function checkWebsiteSecurity() {
  const checker = new CertificateChecker();

  try {
    const cert = await checker.checkCertificate('github.com');

    console.log('🔒 证书信息:');
    console.log(`  域名: ${cert.subject}`);
    console.log(`  颁发者: ${cert.issuer}`);
    console.log(`  有效期: ${cert.valid_from} - ${cert.valid_to}`);
    console.log(`  剩余天数: ${cert.days_until_expiry}`);
    console.log(`  状态: ${cert.is_valid ? '✅ 有效' : '❌ 无效'}`);
    console.log(`  指纹: ${cert.fingerprint}`);

  } catch (error) {
    console.error('❌ 证书检查失败:', error.message);
  }
}
```

### 🔄 WebSocket - 全双工实时通信

WebSocket 协议解决了 HTTP 请求-响应模式的限制，实现真正的双向通信：

#### 📊 WebSocket vs HTTP 对比

```
HTTP 通信模式:
客户端 ──request──→ 服务器
      ←─response─┘

WebSocket 通信模式:
客户端 ←───────────→ 服务器
      双向实时通信
```

#### 🔍 WebSocket 握手过程

```
HTTP 升级握手:
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

#### 🛠️ WebSocket 实践实现

```javascript
// 高级 WebSocket 客户端
class AdvancedWebSocket extends EventTarget {
  constructor(url, options = {}) {
    super();
    this.url = url;
    this.options = {
      reconnectDelay: 1000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      ...options
    };

    this.reconnectAttempts = 0;
    this.isReconnecting = false;
    this.heartbeatTimer = null;

    this.connect();
  }

  connect() {
    console.log(`🔌 连接到 WebSocket: ${this.url}`);

    this.ws = new WebSocket(this.url);

    this.ws.onopen = (event) => {
      console.log('✅ WebSocket 连接建立');
      this.reconnectAttempts = 0;
      this.isReconnecting = false;
      this.startHeartbeat();
      this.dispatchEvent(new CustomEvent('connected', { detail: event }));
    };

    this.ws.onmessage = (event) => {
      const data = this.parseMessage(event.data);
      console.log('📨 收到消息:', data);
      this.dispatchEvent(new CustomEvent('message', { detail: data }));
    };

    this.ws.onclose = (event) => {
      console.log('🔌 WebSocket 连接关闭:', event.code, event.reason);
      this.stopHeartbeat();

      if (!event.wasClean && !this.isReconnecting) {
        this.attemptReconnect();
      }

      this.dispatchEvent(new CustomEvent('disconnected', { detail: event }));
    };

    this.ws.onerror = (event) => {
      console.error('❌ WebSocket 错误:', event);
      this.dispatchEvent(new CustomEvent('error', { detail: event }));
    };
  }

  parseMessage(data) {
    try {
      return JSON.parse(data);
    } catch {
      return data; // 返回原始数据
    }
  }

  send(data) {
    if (this.ws.readyState === WebSocket.OPEN) {
      const message = typeof data === 'object' ? JSON.stringify(data) : data;
      this.ws.send(message);
      console.log('📤 发送消息:', data);
    } else {
      console.warn('⚠️ WebSocket 未连接，消息未发送');
    }
  }

  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.send({ type: 'ping', timestamp: Date.now() });
      }
    }, this.options.heartbeatInterval);
  }

  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  attemptReconnect() {
    if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {
      console.error('❌ 重连次数超限，停止重连');
      return;
    }

    this.isReconnecting = true;
    this.reconnectAttempts++;

    console.log(`🔄 尝试重连 (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);

    setTimeout(() => {
      this.connect();
    }, this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)); // 指数退避
  }

  close() {
    this.isReconnecting = false;
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close();
    }
  }
}

// WebSocket 服务器端实现 (Node.js)
const WebSocket = require('ws');

class ChatServer {
  constructor(port = 8080) {
    this.wss = new WebSocket.Server({ port });
    this.rooms = new Map();
    this.clients = new Map();

    this.setupServer();
    console.log(`🚀 WebSocket 服务器启动在端口 ${port}`);
  }

  setupServer() {
    this.wss.on('connection', (ws, req) => {
      const clientId = this.generateClientId();
      console.log(`👤 客户端连接: ${clientId}`);

      // 存储客户端信息
      this.clients.set(ws, {
        id: clientId,
        ip: req.socket.remoteAddress,
        connectTime: new Date()
      });

      ws.on('message', (data) => {
        try {
          const message = JSON.parse(data);
          this.handleMessage(ws, message);
        } catch (error) {
          console.error('消息解析错误:', error);
          this.sendError(ws, '无效的消息格式');
        }
      });

      ws.on('close', () => {
        this.handleDisconnect(ws);
      });

      ws.on('error', (error) => {
        console.error('WebSocket 错误:', error);
      });

      // 发送欢迎消息
      this.send(ws, {
        type: 'welcome',
        clientId: clientId,
        timestamp: Date.now()
      });
    });
  }

  handleMessage(ws, message) {
    const { type, ...payload } = message;

    switch (type) {
      case 'ping':
        this.send(ws, { type: 'pong', timestamp: Date.now() });
        break;

      case 'join-room':
        this.joinRoom(ws, payload.roomId);
        break;

      case 'leave-room':
        this.leaveRoom(ws, payload.roomId);
        break;

      case 'chat-message':
        this.broadcastMessage(ws, payload);
        break;

      default:
        console.log('未知消息类型:', type);
    }
  }

  joinRoom(ws, roomId) {
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }

    const room = this.rooms.get(roomId);
    room.add(ws);

    const client = this.clients.get(ws);
    client.currentRoom = roomId;

    // 通知房间内其他人
    this.broadcastToRoom(roomId, {
      type: 'user-joined',
      clientId: client.id,
      roomId: roomId,
      timestamp: Date.now()
    }, ws);

    console.log(`📥 客户端 ${client.id} 加入房间 ${roomId}`);
  }

  broadcastMessage(ws, payload) {
    const client = this.clients.get(ws);
    const { currentRoom } = client;

    if (currentRoom) {
      this.broadcastToRoom(currentRoom, {
        type: 'chat-message',
        clientId: client.id,
        message: payload.message,
        timestamp: Date.now()
      });
    }
  }

  broadcastToRoom(roomId, data, excludeWs = null) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    room.forEach(ws => {
      if (ws !== excludeWs && ws.readyState === WebSocket.OPEN) {
        this.send(ws, data);
      }
    });
  }

  send(ws, data) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(data));
    }
  }

  sendError(ws, message) {
    this.send(ws, {
      type: 'error',
      message: message,
      timestamp: Date.now()
    });
  }

  generateClientId() {
    return Math.random().toString(36).substr(2, 9);
  }

  handleDisconnect(ws) {
    const client = this.clients.get(ws);
    if (client) {
      console.log(`👋 客户端断开: ${client.id}`);

      // 从房间移除
      if (client.currentRoom) {
        const room = this.rooms.get(client.currentRoom);
        if (room) {
          room.delete(ws);
          if (room.size === 0) {
            this.rooms.delete(client.currentRoom);
          }
        }
      }

      this.clients.delete(ws);
    }
  }
}

// 使用示例
const chatClient = new AdvancedWebSocket('ws://localhost:8080');

chatClient.addEventListener('connected', () => {
  console.log('🎉 连接成功!');

  // 加入聊天室
  chatClient.send({
    type: 'join-room',
    roomId: 'general'
  });
});

chatClient.addEventListener('message', (event) => {
  const { type, ...data } = event.detail;

  switch (type) {
    case 'welcome':
      console.log(`🎯 客户端ID: ${data.clientId}`);
      break;

    case 'chat-message':
      console.log(`💬 ${data.clientId}: ${data.message}`);
      break;

    case 'user-joined':
      console.log(`👤 ${data.clientId} 加入了房间`);
      break;
  }
});

// 发送消息示例
function sendMessage(text) {
  chatClient.send({
    type: 'chat-message',
    message: text
  });
}
```

### 🔍 DNS - 域名解析系统

DNS 是互联网的"电话簿"，将人类可读的域名转换为机器可理解的IP地址：

#### 🌐 DNS 查询过程

```
DNS 递归查询过程:
1. 浏览器 ──→ 本地DNS缓存
2. 本地DNS ──→ 根域名服务器 (.)
3. 根服务器 ──→ 顶级域服务器 (.com)
4. 顶级域服务器 ──→ 权威域名服务器 (example.com)
5. 权威服务器 ──→ 返回IP地址
6. 逐级返回 ──→ 浏览器获得IP

示例: www.github.com 查询
. (根) → .com → github.com → www.github.com → 140.82.112.4
```

#### 🛠️ DNS 工具实现

```javascript
// DNS 查询工具
const dns = require('dns').promises;

class DNSAnalyzer {
  constructor() {
    this.recordTypes = {
      A: '地址记录 (IPv4)',
      AAAA: '地址记录 (IPv6)',
      CNAME: '别名记录',
      MX: '邮件交换记录',
      NS: '域名服务器记录',
      TXT: '文本记录',
      SOA: '授权开始记录'
    };
  }

  async analyzeHost(hostname) {
    console.log(`🔍 分析域名: ${hostname}`);
    const results = {};

    // 查询各种DNS记录
    for (const [type, description] of Object.entries(this.recordTypes)) {
      try {
        const records = await this.queryRecord(hostname, type);
        if (records && records.length > 0) {
          results[type] = { description, records };
        }
      } catch (error) {
        // 某些记录类型可能不存在，这是正常的
        if (error.code !== 'ENOTFOUND' && error.code !== 'ENODATA') {
          console.warn(`${type} 查询警告:`, error.message);
        }
      }
    }

    // 测量解析时间
    results.performance = await this.measureResolutionTime(hostname);

    return results;
  }

  async queryRecord(hostname, type) {
    switch (type) {
      case 'A':
        return await dns.resolve4(hostname);
      case 'AAAA':
        return await dns.resolve6(hostname);
      case 'CNAME':
        return await dns.resolveCname(hostname);
      case 'MX':
        return await dns.resolveMx(hostname);
      case 'NS':
        return await dns.resolveNs(hostname);
      case 'TXT':
        return await dns.resolveTxt(hostname);
      case 'SOA':
        return await dns.resolveSoa(hostname);
      default:
        throw new Error(`不支持的记录类型: ${type}`);
    }
  }

  async measureResolutionTime(hostname, samples = 5) {
    const times = [];

    for (let i = 0; i < samples; i++) {
      const start = Date.now();
      try {
        await dns.resolve4(hostname);
        times.push(Date.now() - start);
      } catch (error) {
        // 解析失败时也记录时间
        times.push(Date.now() - start);
      }

      // 间隔100ms避免过于频繁
      if (i < samples - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);

    return { avgTime, minTime, maxTime, samples: times };
  }

  formatResults(hostname, results) {
    console.log(`\n📊 ${hostname} DNS分析报告:`);
    console.log('═'.repeat(50));

    // DNS记录
    for (const [type, data] of Object.entries(results)) {
      if (type === 'performance') continue;

      console.log(`\n${type} - ${data.description}:`);
      data.records.forEach((record, index) => {
        if (typeof record === 'object') {
          console.log(`  ${index + 1}. ${JSON.stringify(record)}`);
        } else {
          console.log(`  ${index + 1}. ${record}`);
        }
      });
    }

    // 性能数据
    if (results.performance) {
      const perf = results.performance;
      console.log(`\n⚡ 解析性能:`);
      console.log(`  平均时间: ${perf.avgTime.toFixed(2)}ms`);
      console.log(`  最快时间: ${perf.minTime}ms`);
      console.log(`  最慢时间: ${perf.maxTime}ms`);
    }
  }
}

// DNS缓存实现
class DNSCache {
  constructor(ttl = 300000) { // 5分钟TTL
    this.cache = new Map();
    this.defaultTTL = ttl;
  }

  set(hostname, result, ttl = this.defaultTTL) {
    this.cache.set(hostname, {
      result,
      expires: Date.now() + ttl
    });
  }

  get(hostname) {
    const cached = this.cache.get(hostname);

    if (!cached) return null;

    if (Date.now() > cached.expires) {
      this.cache.delete(hostname);
      return null;
    }

    return cached.result;
  }

  clear() {
    this.cache.clear();
  }

  size() {
    return this.cache.size;
  }
}

// 带缓存的DNS解析器
class CachedDNSResolver {
  constructor() {
    this.cache = new DNSCache();
    this.stats = {
      hits: 0,
      misses: 0,
      errors: 0
    };
  }

  async resolve(hostname) {
    // 检查缓存
    const cached = this.cache.get(hostname);
    if (cached) {
      this.stats.hits++;
      console.log(`💾 缓存命中: ${hostname}`);
      return cached;
    }

    // 缓存未命中，进行DNS查询
    this.stats.misses++;
    console.log(`🔍 DNS查询: ${hostname}`);

    try {
      const start = Date.now();
      const addresses = await dns.resolve4(hostname);
      const duration = Date.now() - start;

      const result = {
        hostname,
        addresses,
        queryTime: duration,
        timestamp: Date.now()
      };

      // 存入缓存
      this.cache.set(hostname, result);

      return result;

    } catch (error) {
      this.stats.errors++;
      console.error(`❌ DNS解析失败: ${hostname}`, error.message);
      throw error;
    }
  }

  getStats() {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? (this.stats.hits / total * 100).toFixed(2) : 0;

    return {
      ...this.stats,
      total,
      hitRate: `${hitRate}%`,
      cacheSize: this.cache.size()
    };
  }
}

// 使用示例
async function demonstrateDNS() {
  const analyzer = new DNSAnalyzer();
  const resolver = new CachedDNSResolver();

  // 分析域名的完整DNS记录
  try {
    const results = await analyzer.analyzeHost('github.com');
    analyzer.formatResults('github.com', results);
  } catch (error) {
    console.error('DNS分析失败:', error);
  }

  // 测试缓存解析器
  console.log('\n🧪 测试DNS缓存解析器:');
  const hosts = ['github.com', 'stackoverflow.com', 'github.com']; // github.com重复测试缓存

  for (const host of hosts) {
    try {
      const result = await resolver.resolve(host);
      console.log(`✅ ${host} → ${result.addresses[0]} (${result.queryTime}ms)`);
    } catch (error) {
      console.error(`❌ ${host} 解析失败`);
    }
  }

  console.log('\n📊 缓存统计:', resolver.getStats());
}

// 运行演示
if (require.main === module) {
  demonstrateDNS().catch(console.error);
}
```

---

## 🚀 传输层协议详解

传输层负责端到端的可靠数据传输，是网络通信的重要枢纽。

### 🔄 TCP - 传输控制协议

TCP 提供可靠的、面向连接的数据传输服务，是互联网最重要的协议之一。

#### 🤝 TCP 三次握手

```
建立连接的三次握手:
客户端                    服务器
   │                        │
   ├─ 1. SYN ──────────────→│ (请求连接, seq=x)
   │←─ 2. SYN-ACK ─────────┤ (确认连接, seq=y, ack=x+1)
   ├─ 3. ACK ──────────────→│ (确认建立, ack=y+1)
   │                        │
   ├──── 数据传输 ←─────────→│
```

为什么需要三次握手？
- ✅ **防止重复连接**：避免旧的连接请求突然到达
- ✅ **同步序列号**：确保双方的序列号正确初始化
- ✅ **确认双方能力**：验证双方的发送和接收能力

#### 👋 TCP 四次挥手

```
关闭连接的四次挥手:
客户端                    服务器
   │                        │
   ├─ 1. FIN ──────────────→│ (请求关闭, seq=x)
   │←─ 2. ACK ─────────────┤ (确认收到, ack=x+1)
   │←─ 3. FIN ─────────────┤ (服务器关闭, seq=y)
   ├─ 4. ACK ──────────────→│ (最终确认, ack=y+1)
   │                        │
  等待2MSL时间后完全关闭
```

为什么需要四次挥手？
- 📡 **半关闭状态**：TCP支持单向关闭
- ⏳ **数据处理时间**：服务器可能还有数据需要发送
- 🔒 **可靠关闭**：确保所有数据都已传输完成

#### 🛠️ TCP 实践实现

```javascript
// TCP 服务器实现
const net = require('net');

class TCPServer {
  constructor(port, host = 'localhost') {
    this.port = port;
    this.host = host;
    this.clients = new Map();
    this.server = null;

    this.messageHandlers = new Map();
    this.setupDefaultHandlers();
  }

  setupDefaultHandlers() {
    // 默认消息处理器
    this.onMessage('ping', (client, data) => {
      this.send(client, { type: 'pong', timestamp: Date.now() });
    });

    this.onMessage('echo', (client, data) => {
      this.send(client, { type: 'echo', data: data.message });
    });
  }

  start() {
    return new Promise((resolve, reject) => {
      this.server = net.createServer((socket) => {
        this.handleConnection(socket);
      });

      this.server.listen(this.port, this.host, () => {
        console.log(`🚀 TCP服务器启动在 ${this.host}:${this.port}`);
        resolve();
      });

      this.server.on('error', reject);
    });
  }

  handleConnection(socket) {
    const clientId = this.generateClientId();
    const clientInfo = {
      id: clientId,
      socket: socket,
      address: `${socket.remoteAddress}:${socket.remotePort}`,
      connectTime: new Date(),
      lastActivity: new Date()
    };

    this.clients.set(socket, clientInfo);
    console.log(`👤 客户端连接: ${clientId} (${clientInfo.address})`);

    // 发送欢迎消息
    this.send(socket, {
      type: 'welcome',
      clientId: clientId,
      message: '欢迎连接到TCP服务器'
    });

    // 设置socket选项
    socket.setKeepAlive(true, 60000); // 60秒心跳
    socket.setTimeout(300000); // 5分钟超时

    // 事件处理
    socket.on('data', (data) => this.handleData(socket, data));
    socket.on('close', () => this.handleDisconnect(socket));
    socket.on('error', (error) => this.handleError(socket, error));
    socket.on('timeout', () => this.handleTimeout(socket));
  }

  handleData(socket, data) {
    const client = this.clients.get(socket);
    if (!client) return;

    client.lastActivity = new Date();

    try {
      // 处理可能的多个JSON消息（TCP流的特性）
      const messages = this.parseMessages(data.toString());

      messages.forEach(message => {
        console.log(`📨 ${client.id} 发送:`, message);

        if (message.type && this.messageHandlers.has(message.type)) {
          this.messageHandlers.get(message.type)(client, message);
        } else {
          console.warn(`⚠️ 未知消息类型: ${message.type}`);
        }
      });

    } catch (error) {
      console.error('数据处理错误:', error);
      this.send(socket, {
        type: 'error',
        message: '消息格式无效'
      });
    }
  }

  parseMessages(data) {
    // 处理TCP流可能包含多个JSON对象的情况
    const messages = [];
    const lines = data.split('\n').filter(line => line.trim());

    for (const line of lines) {
      try {
        const message = JSON.parse(line);
        messages.push(message);
      } catch (error) {
        console.warn('JSON解析失败:', line);
      }
    }

    return messages;
  }

  send(socket, data) {
    if (socket.destroyed) return false;

    const message = JSON.stringify(data) + '\n';

    return new Promise((resolve) => {
      socket.write(message, (error) => {
        if (error) {
          console.error('发送失败:', error);
          resolve(false);
        } else {
          resolve(true);
        }
      });
    });
  }

  broadcast(data, excludeSocket = null) {
    let sent = 0;

    this.clients.forEach((client, socket) => {
      if (socket !== excludeSocket) {
        this.send(socket, data).then(success => {
          if (success) sent++;
        });
      }
    });

    console.log(`📡 广播消息给 ${sent} 个客户端`);
    return sent;
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  handleDisconnect(socket) {
    const client = this.clients.get(socket);
    if (client) {
      console.log(`👋 客户端断开: ${client.id}`);
      this.clients.delete(socket);
    }
  }

  handleError(socket, error) {
    const client = this.clients.get(socket);
    console.error(`❌ 客户端错误 ${client?.id}:`, error.message);
  }

  handleTimeout(socket) {
    const client = this.clients.get(socket);
    console.log(`⏰ 客户端超时: ${client?.id}`);
    socket.destroy();
  }

  generateClientId() {
    return Math.random().toString(36).substr(2, 9);
  }

  getStats() {
    return {
      totalClients: this.clients.size,
      clients: Array.from(this.clients.values()).map(client => ({
        id: client.id,
        address: client.address,
        connectTime: client.connectTime,
        lastActivity: client.lastActivity
      }))
    };
  }

  stop() {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          console.log('🛑 TCP服务器已关闭');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}

// TCP 客户端实现
class TCPClient {
  constructor() {
    this.socket = null;
    this.connected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;

    this.messageHandlers = new Map();
  }

  connect(host, port) {
    return new Promise((resolve, reject) => {
      this.socket = net.createConnection({ port, host });

      this.socket.on('connect', () => {
        console.log(`✅ 连接到服务器 ${host}:${port}`);
        this.connected = true;
        this.reconnectAttempts = 0;
        resolve();
      });

      this.socket.on('data', (data) => this.handleData(data));
      this.socket.on('close', () => this.handleDisconnect());
      this.socket.on('error', (error) => this.handleError(error, reject));

      this.socket.setTimeout(10000); // 10秒连接超时
    });
  }

  handleData(data) {
    try {
      const messages = this.parseMessages(data.toString());

      messages.forEach(message => {
        console.log('📨 服务器消息:', message);

        if (message.type && this.messageHandlers.has(message.type)) {
          this.messageHandlers.get(message.type)(message);
        }
      });

    } catch (error) {
      console.error('数据处理错误:', error);
    }
  }

  parseMessages(data) {
    const messages = [];
    const lines = data.split('\n').filter(line => line.trim());

    for (const line of lines) {
      try {
        const message = JSON.parse(line);
        messages.push(message);
      } catch (error) {
        console.warn('JSON解析失败:', line);
      }
    }

    return messages;
  }

  send(data) {
    if (!this.connected) {
      console.warn('⚠️ 未连接到服务器');
      return false;
    }

    const message = JSON.stringify(data) + '\n';

    return new Promise((resolve) => {
      this.socket.write(message, (error) => {
        if (error) {
          console.error('发送失败:', error);
          resolve(false);
        } else {
          console.log('📤 发送消息:', data);
          resolve(true);
        }
      });
    });
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  handleDisconnect() {
    console.log('🔌 与服务器断开连接');
    this.connected = false;
  }

  handleError(error, reject = null) {
    console.error('❌ 连接错误:', error.message);
    if (reject) reject(error);
  }

  disconnect() {
    if (this.socket) {
      this.socket.end();
      this.socket = null;
      this.connected = false;
    }
  }
}

// 使用示例
async function demonstrateTCP() {
  // 启动服务器
  const server = new TCPServer(8888);

  // 添加自定义消息处理器
  server.onMessage('chat', (client, data) => {
    console.log(`💬 ${client.id}: ${data.message}`);
    // 广播给其他客户端
    server.broadcast({
      type: 'chat',
      from: client.id,
      message: data.message,
      timestamp: Date.now()
    }, client.socket);
  });

  await server.start();

  // 创建客户端
  const client1 = new TCPClient();
  const client2 = new TCPClient();

  // 设置客户端消息处理
  client1.onMessage('welcome', (message) => {
    console.log(`🎉 客户端1收到欢迎: ${message.message}`);
  });

  client2.onMessage('chat', (message) => {
    console.log(`💬 客户端2收到聊天: ${message.from} 说 "${message.message}"`);
  });

  try {
    // 连接客户端
    await client1.connect('localhost', 8888);
    await client2.connect('localhost', 8888);

    // 发送消息
    await client1.send({
      type: 'chat',
      message: 'Hello from client 1!'
    });

    await client2.send({
      type: 'ping'
    });

    // 显示服务器统计
    setTimeout(() => {
      console.log('📊 服务器统计:', server.getStats());
    }, 1000);

    // 5秒后清理
    setTimeout(() => {
      client1.disconnect();
      client2.disconnect();
      server.stop();
    }, 5000);

  } catch (error) {
    console.error('演示失败:', error);
  }
}

// 运行演示
if (require.main === module) {
  demonstrateTCP();
}
```

### ⚡ UDP - 用户数据报协议

UDP 是无连接的传输协议，提供快速但不可靠的数据传输：

#### 📊 TCP vs UDP 对比

| 特性 | TCP | UDP |
|------|-----|-----|
| **连接性** | 面向连接 | 无连接 |
| **可靠性** | 可靠传输 | 不保证可靠 |
| **速度** | 相对较慢 | 快速 |
| **开销** | 较大 | 较小 |
| **流量控制** | 有 | 无 |
| **拥塞控制** | 有 | 无 |
| **适用场景** | Web、邮件、文件传输 | 视频流、游戏、DNS |

#### 🛠️ UDP 实践实现

```javascript
// UDP 服务器实现
const dgram = require('dgram');

class UDPServer {
  constructor(port, host = 'localhost') {
    this.port = port;
    this.host = host;
    this.socket = dgram.createSocket('udp4');
    this.clients = new Map(); // 跟踪客户端

    this.messageHandlers = new Map();
    this.setupDefaultHandlers();
    this.setupSocket();
  }

  setupDefaultHandlers() {
    this.onMessage('ping', (client, data) => {
      this.send(client.address, client.port, {
        type: 'pong',
        timestamp: Date.now(),
        originalTimestamp: data.timestamp
      });
    });

    this.onMessage('register', (client, data) => {
      client.username = data.username;
      console.log(`👤 客户端注册: ${data.username} (${client.address}:${client.port})`);
    });
  }

  setupSocket() {
    this.socket.on('message', (msg, rinfo) => {
      this.handleMessage(msg, rinfo);
    });

    this.socket.on('error', (err) => {
      console.error('❌ UDP服务器错误:', err);
    });

    this.socket.on('listening', () => {
      const address = this.socket.address();
      console.log(`🚀 UDP服务器启动在 ${address.address}:${address.port}`);
    });
  }

  start() {
    return new Promise((resolve, reject) => {
      this.socket.bind({
        port: this.port,
        address: this.host
      }, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  handleMessage(msg, rinfo) {
    const clientKey = `${rinfo.address}:${rinfo.port}`;

    // 更新客户端信息
    if (!this.clients.has(clientKey)) {
      this.clients.set(clientKey, {
        address: rinfo.address,
        port: rinfo.port,
        firstSeen: new Date(),
        messageCount: 0
      });
    }

    const client = this.clients.get(clientKey);
    client.lastSeen = new Date();
    client.messageCount++;

    try {
      const data = JSON.parse(msg.toString());
      console.log(`📨 收到消息 from ${clientKey}:`, data);

      if (data.type && this.messageHandlers.has(data.type)) {
        this.messageHandlers.get(data.type)(client, data);
      } else {
        console.warn(`⚠️ 未知消息类型: ${data.type}`);
      }

    } catch (error) {
      console.error('消息解析错误:', error);
      this.send(rinfo.address, rinfo.port, {
        type: 'error',
        message: '消息格式无效'
      });
    }
  }

  send(address, port, data) {
    const message = Buffer.from(JSON.stringify(data));

    return new Promise((resolve) => {
      this.socket.send(message, port, address, (error) => {
        if (error) {
          console.error(`发送失败 to ${address}:${port}:`, error);
          resolve(false);
        } else {
          console.log(`📤 发送消息 to ${address}:${port}:`, data);
          resolve(true);
        }
      });
    });
  }

  broadcast(data, excludeClient = null) {
    let sent = 0;

    this.clients.forEach((client, key) => {
      if (!excludeClient || key !== `${excludeClient.address}:${excludeClient.port}`) {
        this.send(client.address, client.port, data).then(success => {
          if (success) sent++;
        });
      }
    });

    console.log(`📡 广播消息给 ${sent} 个客户端`);
    return sent;
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  getStats() {
    return {
      totalClients: this.clients.size,
      clients: Array.from(this.clients.entries()).map(([key, client]) => ({
        address: key,
        username: client.username || 'unknown',
        firstSeen: client.firstSeen,
        lastSeen: client.lastSeen,
        messageCount: client.messageCount
      }))
    };
  }

  stop() {
    return new Promise((resolve) => {
      this.socket.close(() => {
        console.log('🛑 UDP服务器已关闭');
        resolve();
      });
    });
  }
}

// UDP 客户端实现
class UDPClient {
  constructor() {
    this.socket = dgram.createSocket('udp4');
    this.serverAddress = null;
    this.serverPort = null;
    this.connected = false;

    this.messageHandlers = new Map();
    this.setupSocket();
  }

  setupSocket() {
    this.socket.on('message', (msg, rinfo) => {
      this.handleMessage(msg, rinfo);
    });

    this.socket.on('error', (err) => {
      console.error('❌ UDP客户端错误:', err);
    });
  }

  connect(host, port) {
    this.serverAddress = host;
    this.serverPort = port;
    this.connected = true;

    console.log(`🔌 连接到UDP服务器 ${host}:${port}`);

    // UDP是无连接的，所以我们发送一个注册消息来"连接"
    return this.send({
      type: 'register',
      username: `client_${Date.now()}`,
      timestamp: Date.now()
    });
  }

  handleMessage(msg, rinfo) {
    try {
      const data = JSON.parse(msg.toString());
      console.log(`📨 服务器消息 from ${rinfo.address}:${rinfo.port}:`, data);

      if (data.type && this.messageHandlers.has(data.type)) {
        this.messageHandlers.get(data.type)(data, rinfo);
      }

    } catch (error) {
      console.error('消息解析错误:', error);
    }
  }

  send(data) {
    if (!this.connected) {
      console.warn('⚠️ 未连接到服务器');
      return Promise.resolve(false);
    }

    const message = Buffer.from(JSON.stringify(data));

    return new Promise((resolve) => {
      this.socket.send(message, this.serverPort, this.serverAddress, (error) => {
        if (error) {
          console.error('发送失败:', error);
          resolve(false);
        } else {
          console.log('📤 发送消息:', data);
          resolve(true);
        }
      });
    });
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  disconnect() {
    this.connected = false;
    this.socket.close();
    console.log('🔌 断开UDP连接');
  }
}

// UDP 性能测试工具
class UDPBenchmark {
  constructor(serverHost = 'localhost', serverPort = 9999) {
    this.serverHost = serverHost;
    this.serverPort = serverPort;
    this.results = [];
  }

  async measureLatency(samples = 100) {
    const client = new UDPClient();
    const latencies = [];

    client.onMessage('pong', (data) => {
      const latency = Date.now() - data.originalTimestamp;
      latencies.push(latency);
    });

    await client.connect(this.serverHost, this.serverPort);

    console.log(`🧪 开始延迟测试，样本数: ${samples}`);

    for (let i = 0; i < samples; i++) {
      await client.send({
        type: 'ping',
        timestamp: Date.now(),
        sequence: i
      });

      // 等待10ms避免过于频繁
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    // 等待所有响应
    await new Promise(resolve => setTimeout(resolve, 1000));
    client.disconnect();

    if (latencies.length > 0) {
      const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
      const min = Math.min(...latencies);
      const max = Math.max(...latencies);
      const median = latencies.sort((a, b) => a - b)[Math.floor(latencies.length / 2)];

      const result = {
        samples: latencies.length,
        average: avg.toFixed(2),
        median: median,
        min: min,
        max: max,
        lossRate: ((samples - latencies.length) / samples * 100).toFixed(2)
      };

      console.log('📊 延迟测试结果:');
      console.log(`  样本数: ${result.samples}/${samples}`);
      console.log(`  平均延迟: ${result.average}ms`);
      console.log(`  中位数延迟: ${result.median}ms`);
      console.log(`  最小延迟: ${result.min}ms`);
      console.log(`  最大延迟: ${result.max}ms`);
      console.log(`  丢包率: ${result.lossRate}%`);

      return result;
    } else {
      console.error('❌ 没有收到任何响应');
      return null;
    }
  }

  async measureThroughput(duration = 10000, packetSize = 1024) {
    const client = new UDPClient();
    let packetsSent = 0;
    let packetsReceived = 0;
    let bytesSent = 0;
    let bytesReceived = 0;

    client.onMessage('echo', (data) => {
      packetsReceived++;
      bytesReceived += JSON.stringify(data).length;
    });

    await client.connect(this.serverHost, this.serverPort);

    console.log(`🧪 开始吞吐量测试，持续时间: ${duration}ms，包大小: ${packetSize}字节`);

    const startTime = Date.now();
    const endTime = startTime + duration;

    // 生成测试数据
    const testData = 'x'.repeat(packetSize - 100); // 预留JSON格式空间

    while (Date.now() < endTime) {
      await client.send({
        type: 'echo',
        data: testData,
        timestamp: Date.now(),
        sequence: packetsSent
      });

      packetsSent++;
      bytesSent += JSON.stringify({ type: 'echo', data: testData }).length;

      // 控制发送频率，避免过载
      if (packetsSent % 100 === 0) {
        await new Promise(resolve => setTimeout(resolve, 1));
      }
    }

    // 等待剩余响应
    await new Promise(resolve => setTimeout(resolve, 1000));
    client.disconnect();

    const actualDuration = Date.now() - startTime;
    const sendThroughput = (bytesSent / 1024 / 1024) / (actualDuration / 1000); // MB/s
    const receiveThroughput = (bytesReceived / 1024 / 1024) / (actualDuration / 1000); // MB/s

    const result = {
      duration: actualDuration,
      packetsSent,
      packetsReceived,
      bytesSent,
      bytesReceived,
      sendThroughput: sendThroughput.toFixed(2),
      receiveThroughput: receiveThroughput.toFixed(2),
      lossRate: ((packetsSent - packetsReceived) / packetsSent * 100).toFixed(2)
    };

    console.log('📊 吞吐量测试结果:');
    console.log(`  测试时长: ${result.duration}ms`);
    console.log(`  发送包数: ${result.packetsSent}`);
    console.log(`  接收包数: ${result.packetsReceived}`);
    console.log(`  发送吞吐量: ${result.sendThroughput} MB/s`);
    console.log(`  接收吞吐量: ${result.receiveThroughput} MB/s`);
    console.log(`  丢包率: ${result.lossRate}%`);

    return result;
  }
}

// 使用示例
async function demonstrateUDP() {
  // 启动服务器
  const server = new UDPServer(9999);

  // 添加echo处理器用于性能测试
  server.onMessage('echo', (client, data) => {
    server.send(client.address, client.port, {
      type: 'echo',
      data: data.data,
      originalTimestamp: data.timestamp,
      serverTimestamp: Date.now()
    });
  });

  await server.start();

  // 等待服务器启动
  await new Promise(resolve => setTimeout(resolve, 100));

  // 创建客户端
  const client1 = new UDPClient();
  const client2 = new UDPClient();

  try {
    await client1.connect('localhost', 9999);
    await client2.connect('localhost', 9999);

    // 发送一些测试消息
    await client1.send({
      type: 'ping',
      timestamp: Date.now()
    });

    // 显示统计信息
    setTimeout(() => {
      console.log('📊 服务器统计:', server.getStats());
    }, 1000);

    // 进行性能测试
    setTimeout(async () => {
      const benchmark = new UDPBenchmark('localhost', 9999);

      await benchmark.measureLatency(50);
      await benchmark.measureThroughput(5000, 512);

      // 清理
      client1.disconnect();
      client2.disconnect();
      server.stop();
    }, 2000);

  } catch (error) {
    console.error('演示失败:', error);
  }
}

// 运行演示
if (require.main === module) {
  demonstrateUDP();
}
```

### 🚀 QUIC - 新一代传输协议

QUIC (Quick UDP Internet Connections) 是Google开发的基于UDP的新协议，HTTP/3的基础：

#### 💡 QUIC 的优势

```
传统 HTTPS (HTTP/2 over TLS over TCP):
应用层     │ HTTP/2
安全层     │ TLS 1.3
传输层     │ TCP
网络层     │ IP

现代 HTTPS (HTTP/3 over QUIC):
应用层     │ HTTP/3
传输+安全层 │ QUIC (集成加密)
网络层     │ UDP + IP
```

**QUIC 核心特性**：
- ✅ **0-RTT连接**：缓存握手信息，实现零往返连接
- ✅ **多路复用无阻塞**：避免TCP的队头阻塞问题
- ✅ **内置加密**：默认端到端加密
- ✅ **连接迁移**：支持IP地址变化（WiFi切换到4G）
- ✅ **拥塞控制**：改进的拥塞控制算法

---

## 🌐 网络层协议详解

网络层负责跨网络的数据路由，是实现全球互联的关键。

### 🎯 IP协议 - 网络层核心

IP (Internet Protocol) 是互联网的基础协议，负责数据包的路由和传递。

#### 📊 IPv4 vs IPv6 对比

| 特性 | IPv4 | IPv6 |
|------|------|------|
| **地址长度** | 32位 (4字节) | 128位 (16字节) |
| **地址数量** | 约43亿 | 3.4×10³⁸ |
| **地址表示** | 192.168.1.1 | 2001:db8::1 |
| **分片** | 路由器分片 | 仅源端分片 |
| **头部大小** | 20-60字节 | 40字节固定 |
| **配置** | 手动/DHCP | 自动配置 |

#### 🔍 IP地址分类与子网划分

```javascript
// IP 地址工具类
class IPAddressCalculator {
  constructor() {
    this.ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    this.ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  }

  // IPv4 地址分析
  analyzeIPv4(ip, cidr = null) {
    if (!this.isValidIPv4(ip)) {
      throw new Error('无效的IPv4地址');
    }

    const octets = ip.split('.').map(Number);
    const binaryIP = this.ipToBinary(octets);

    let analysis = {
      ip: ip,
      octets: octets,
      binary: binaryIP,
      class: this.getIPClass(octets[0]),
      isPrivate: this.isPrivateIP(octets),
      isLoopback: this.isLoopback(octets),
      isMulticast: this.isMulticast(octets[0])
    };

    if (cidr) {
      const subnetInfo = this.calculateSubnet(ip, cidr);
      analysis.subnet = subnetInfo;
    }

    return analysis;
  }

  isValidIPv4(ip) {
    const match = ip.match(this.ipv4Regex);
    if (!match) return false;

    return match.slice(1).every(octet => {
      const num = parseInt(octet);
      return num >= 0 && num <= 255;
    });
  }

  ipToBinary(octets) {
    return octets.map(octet =>
      octet.toString(2).padStart(8, '0')
    ).join('.');
  }

  getIPClass(firstOctet) {
    if (firstOctet >= 1 && firstOctet <= 126) return 'A';
    if (firstOctet >= 128 && firstOctet <= 191) return 'B';
    if (firstOctet >= 192 && firstOctet <= 223) return 'C';
    if (firstOctet >= 224 && firstOctet <= 239) return 'D (组播)';
    if (firstOctet >= 240 && firstOctet <= 255) return 'E (实验)';
    return '未知';
  }

  isPrivateIP(octets) {
    const [a, b] = octets;

    // 10.0.0.0/8
    if (a === 10) return true;

    // 172.16.0.0/12
    if (a === 172 && b >= 16 && b <= 31) return true;

    // 192.168.0.0/16
    if (a === 192 && b === 168) return true;

    return false;
  }

  isLoopback(octets) {
    return octets[0] === 127;
  }

  isMulticast(firstOctet) {
    return firstOctet >= 224 && firstOctet <= 239;
  }

  calculateSubnet(ip, cidr) {
    const octets = ip.split('.').map(Number);
    const ipInt = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3];

    // 子网掩码计算
    const subnetMask = (0xFFFFFFFF << (32 - cidr)) >>> 0;
    const subnetMaskOctets = [
      (subnetMask >>> 24) & 0xFF,
      (subnetMask >>> 16) & 0xFF,
      (subnetMask >>> 8) & 0xFF,
      subnetMask & 0xFF
    ];

    // 网络地址
    const networkInt = (ipInt & subnetMask) >>> 0;
    const networkOctets = [
      (networkInt >>> 24) & 0xFF,
      (networkInt >>> 16) & 0xFF,
      (networkInt >>> 8) & 0xFF,
      networkInt & 0xFF
    ];

    // 广播地址
    const broadcastInt = (networkInt | (0xFFFFFFFF >>> cidr)) >>> 0;
    const broadcastOctets = [
      (broadcastInt >>> 24) & 0xFF,
      (broadcastInt >>> 16) & 0xFF,
      (broadcastInt >>> 8) & 0xFF,
      broadcastInt & 0xFF
    ];

    // 可用主机数
    const hostBits = 32 - cidr;
    const totalHosts = Math.pow(2, hostBits);
    const usableHosts = totalHosts - 2; // 减去网络地址和广播地址

    return {
      cidr: `/${cidr}`,
      subnetMask: subnetMaskOctets.join('.'),
      subnetMaskBinary: this.ipToBinary(subnetMaskOctets),
      network: networkOctets.join('.'),
      broadcast: broadcastOctets.join('.'),
      firstHost: this.addToIP(networkOctets, 1),
      lastHost: this.addToIP(broadcastOctets, -1),
      totalHosts: totalHosts,
      usableHosts: usableHosts > 0 ? usableHosts : 0
    };
  }

  addToIP(octets, value) {
    let ipInt = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3];
    ipInt += value;

    return [
      (ipInt >>> 24) & 0xFF,
      (ipInt >>> 16) & 0xFF,
      (ipInt >>> 8) & 0xFF,
      ipInt & 0xFF
    ].join('.');
  }

  // IPv6 地址分析
  analyzeIPv6(ip) {
    const expanded = this.expandIPv6(ip);
    const compressed = this.compressIPv6(expanded);

    return {
      original: ip,
      expanded: expanded,
      compressed: compressed,
      type: this.getIPv6Type(expanded),
      isValid: this.isValidIPv6(ip)
    };
  }

  expandIPv6(ip) {
    // 处理 :: 简写
    if (ip.includes('::')) {
      const parts = ip.split('::');
      const leftParts = parts[0] ? parts[0].split(':') : [];
      const rightParts = parts[1] ? parts[1].split(':') : [];

      const missingGroups = 8 - leftParts.length - rightParts.length;
      const middleParts = new Array(missingGroups).fill('0000');

      const allParts = [...leftParts, ...middleParts, ...rightParts];
      ip = allParts.join(':');
    }

    return ip.split(':').map(group =>
      group.padStart(4, '0')
    ).join(':');
  }

  compressIPv6(ip) {
    // 移除前导零
    let compressed = ip.split(':').map(group =>
      group.replace(/^0+/, '') || '0'
    ).join(':');

    // 寻找最长的连续0序列并替换为::
    const zeroGroups = compressed.match(/(^|:)(0:)*0(:|$)/g);
    if (zeroGroups) {
      const longest = zeroGroups.reduce((a, b) => a.length > b.length ? a : b);
      compressed = compressed.replace(longest, '::');
    }

    return compressed;
  }

  getIPv6Type(ip) {
    if (ip.startsWith('::1')) return '回环地址';
    if (ip.startsWith('fe80:')) return '链路本地地址';
    if (ip.startsWith('fc00:') || ip.startsWith('fd00:')) return '唯一本地地址';
    if (ip.startsWith('2001:db8:')) return '文档用地址';
    if (ip.match(/^2[0-3]/)) return '全局单播地址';
    if (ip.startsWith('ff')) return '组播地址';
    return '未知类型';
  }

  isValidIPv6(ip) {
    try {
      const expanded = this.expandIPv6(ip);
      return this.ipv6Regex.test(expanded) || ip === '::';
    } catch {
      return false;
    }
  }
}

// 路由表分析工具
class RouteAnalyzer {
  constructor() {
    this.routeTable = [];
  }

  addRoute(network, mask, gateway, interface_, metric = 1) {
    this.routeTable.push({
      network,
      mask,
      gateway,
      interface: interface_,
      metric,
      cidr: this.maskToCIDR(mask)
    });
  }

  maskToCIDR(mask) {
    const octets = mask.split('.').map(Number);
    let cidr = 0;

    for (const octet of octets) {
      cidr += (octet.toString(2).match(/1/g) || []).length;
    }

    return cidr;
  }

  findRoute(destIP) {
    const calc = new IPAddressCalculator();
    const matches = [];

    for (const route of this.routeTable) {
      if (this.isInSubnet(destIP, route.network, route.cidr)) {
        matches.push({
          ...route,
          specificity: route.cidr // CIDR越大，路由越具体
        });
      }
    }

    // 按具体度排序（最长匹配）
    matches.sort((a, b) => b.specificity - a.specificity);

    return matches.length > 0 ? matches[0] : null;
  }

  isInSubnet(ip, network, cidr) {
    const calc = new IPAddressCalculator();

    try {
      const ipOctets = ip.split('.').map(Number);
      const netOctets = network.split('.').map(Number);

      const ipInt = (ipOctets[0] << 24) + (ipOctets[1] << 16) +
                   (ipOctets[2] << 8) + ipOctets[3];
      const netInt = (netOctets[0] << 24) + (netOctets[1] << 16) +
                    (netOctets[2] << 8) + netOctets[3];

      const mask = (0xFFFFFFFF << (32 - cidr)) >>> 0;

      return ((ipInt & mask) >>> 0) === ((netInt & mask) >>> 0);
    } catch {
      return false;
    }
  }

  displayRouteTable() {
    console.log('\n📋 路由表:');
    console.log('网络地址'.padEnd(18) + 'CIDR'.padEnd(6) + '网关'.padEnd(16) + '接口'.padEnd(12) + '跳数');
    console.log('-'.repeat(70));

    this.routeTable.forEach(route => {
      console.log(
        route.network.padEnd(18) +
        `/${route.cidr}`.padEnd(6) +
        route.gateway.padEnd(16) +
        route.interface.padEnd(12) +
        route.metric
      );
    });
  }
}

// 使用示例
function demonstrateIPAnalysis() {
  const calc = new IPAddressCalculator();

  console.log('🔍 IPv4 地址分析示例:');

  const testIPs = [
    { ip: '192.168.1.100', cidr: 24 },
    { ip: '10.0.0.50', cidr: 8 },
    { ip: '172.16.5.10', cidr: 16 },
    { ip: '8.8.8.8', cidr: null }
  ];

  testIPs.forEach(({ ip, cidr }) => {
    console.log(`\n📊 分析 ${ip}${cidr ? '/' + cidr : ''}:`);

    const analysis = calc.analyzeIPv4(ip, cidr);

    console.log(`  IP地址: ${analysis.ip}`);
    console.log(`  二进制: ${analysis.binary}`);
    console.log(`  地址类型: Class ${analysis.class}`);
    console.log(`  私有地址: ${analysis.isPrivate ? '是' : '否'}`);
    console.log(`  回环地址: ${analysis.isLoopback ? '是' : '否'}`);

    if (analysis.subnet) {
      const subnet = analysis.subnet;
      console.log(`  子网掩码: ${subnet.subnetMask}`);
      console.log(`  网络地址: ${subnet.network}`);
      console.log(`  广播地址: ${subnet.broadcast}`);
      console.log(`  主机范围: ${subnet.firstHost} - ${subnet.lastHost}`);
      console.log(`  可用主机: ${subnet.usableHosts}`);
    }
  });

  // IPv6 示例
  console.log('\n🔍 IPv6 地址分析示例:');

  const ipv6Addresses = [
    '2001:db8:85a3::8a2e:370:7334',
    'fe80::1%lo0',
    '::1',
    '2001:db8::1'
  ];

  ipv6Addresses.forEach(ip => {
    try {
      const analysis = calc.analyzeIPv6(ip.split('%')[0]); // 移除接口标识符
      console.log(`\n📊 ${ip}:`);
      console.log(`  完整格式: ${analysis.expanded}`);
      console.log(`  压缩格式: ${analysis.compressed}`);
      console.log(`  地址类型: ${analysis.type}`);
    } catch (error) {
      console.log(`\n❌ ${ip}: 分析失败`);
    }
  });

  // 路由表示例
  console.log('\n🛣️ 路由表分析示例:');

  const routeAnalyzer = new RouteAnalyzer();

  // 添加路由条目
  routeAnalyzer.addRoute('0.0.0.0', '0.0.0.0', '192.168.1.1', 'eth0', 1); // 默认路由
  routeAnalyzer.addRoute('192.168.1.0', '255.255.255.0', '0.0.0.0', 'eth0', 0); // 本地网络
  routeAnalyzer.addRoute('10.0.0.0', '255.0.0.0', '192.168.1.254', 'eth0', 2); // 公司网络
  routeAnalyzer.addRoute('172.16.0.0', '255.240.0.0', '192.168.1.254', 'eth0', 2);

  routeAnalyzer.displayRouteTable();

  // 测试路由查找
  const testDestinations = ['192.168.1.50', '10.5.5.5', '8.8.8.8', '172.20.1.1'];

  console.log('\n🎯 路由查找测试:');
  testDestinations.forEach(dest => {
    const route = routeAnalyzer.findRoute(dest);
    if (route) {
      console.log(`  ${dest} → 网关: ${route.gateway}, 接口: ${route.interface}`);
    } else {
      console.log(`  ${dest} → 无匹配路由`);
    }
  });
}

// 运行IP分析示例
if (require.main === module) {
  demonstrateIPAnalysis();
}
```

### 📡 ICMP - Internet控制消息协议

ICMP 协议用于在网络中传递控制和错误信息，是网络诊断的重要工具。

#### 🔍 ICMP 消息类型

```javascript
// ICMP 分析和测试工具
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

class ICMPAnalyzer {
  constructor() {
    this.messageTypes = {
      0: 'Echo Reply (Ping回复)',
      3: 'Destination Unreachable (目标不可达)',
      4: 'Source Quench (源抑制)',
      5: 'Redirect (重定向)',
      8: 'Echo Request (Ping请求)',
      11: 'Time Exceeded (超时)',
      12: 'Parameter Problem (参数错误)',
      13: 'Timestamp Request (时间戳请求)',
      14: 'Timestamp Reply (时间戳回复)'
    };

    this.unreachableCodes = {
      0: '网络不可达',
      1: '主机不可达',
      2: '协议不可达',
      3: '端口不可达',
      4: '需要分片但设置了DF标志',
      5: '源路由失败'
    };
  }

  async ping(host, count = 4, timeout = 5000) {
    console.log(`🏓 Ping ${host} (${count} 次):`);

    const results = [];
    const startTime = Date.now();

    try {
      // 构造ping命令
      const pingCmd = process.platform === 'win32'
        ? `ping -n ${count} ${host}`
        : `ping -c ${count} -W ${timeout / 1000} ${host}`;

      const { stdout, stderr } = await execAsync(pingCmd);

      // 解析ping结果
      const lines = stdout.split('\n');

      for (const line of lines) {
        const timeMatch = line.match(/time[<=](\d+\.?\d*)/i);
        const seqMatch = line.match(/icmp_seq=(\d+)/i) || line.match(/序列号?=(\d+)/i);

        if (timeMatch && seqMatch) {
          results.push({
            sequence: parseInt(seqMatch[1]),
            time: parseFloat(timeMatch[1]),
            raw: line.trim()
          });
          console.log(`  ${line.trim()}`);
        }
      }

      // 统计信息
      if (results.length > 0) {
        const times = results.map(r => r.time);
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const lossRate = ((count - results.length) / count * 100);

        console.log(`\n📊 Ping 统计:`);
        console.log(`  发送: ${count}, 接收: ${results.length}, 丢失: ${count - results.length} (${lossRate.toFixed(1)}%)`);
        console.log(`  往返时间: 最小=${minTime}ms, 最大=${maxTime}ms, 平均=${avgTime.toFixed(2)}ms`);

        return {
          host,
          count,
          received: results.length,
          lost: count - results.length,
          lossRate: lossRate.toFixed(1),
          minTime,
          maxTime,
          avgTime: avgTime.toFixed(2),
          results
        };
      }

    } catch (error) {
      console.error(`❌ Ping 失败: ${error.message}`);
      return null;
    }
  }

  async traceroute(host, maxHops = 30) {
    console.log(`🛣️ 追踪到 ${host} 的路由:`);

    try {
      const traceCmd = process.platform === 'win32'
        ? `tracert -h ${maxHops} ${host}`
        : `traceroute -m ${maxHops} ${host}`;

      const { stdout } = await execAsync(traceCmd);
      const lines = stdout.split('\n').filter(line => line.trim());

      const hops = [];

      for (const line of lines) {
        // 解析跟踪路由输出
        const hopMatch = line.match(/^\s*(\d+)\s+(.+)/);
        if (hopMatch) {
          const hopNum = parseInt(hopMatch[1]);
          const hopInfo = hopMatch[2];

          // 提取IP地址和时间
          const ipMatch = hopInfo.match(/(\d+\.\d+\.\d+\.\d+)/);
          const timeMatches = hopInfo.match(/(\d+\.?\d*)\s*ms/g);

          if (ipMatch) {
            const times = timeMatches ? timeMatches.map(t => parseFloat(t)) : [];
            const avgTime = times.length > 0 ? times.reduce((a, b) => a + b, 0) / times.length : null;

            hops.push({
              hop: hopNum,
              ip: ipMatch[1],
              times: times,
              avgTime: avgTime ? avgTime.toFixed(2) : 'timeout',
              raw: line.trim()
            });

            console.log(`  ${hopNum.toString().padStart(2, ' ')}. ${ipMatch[1].padEnd(15, ' ')} ${avgTime ? avgTime.toFixed(2) + 'ms' : 'timeout'}`);
          }
        }
      }

      return {
        host,
        maxHops,
        totalHops: hops.length,
        hops
      };

    } catch (error) {
      console.error(`❌ Traceroute 失败: ${error.message}`);
      return null;
    }
  }

  async performNetworkDiagnosis(host) {
    console.log(`🔧 网络诊断: ${host}`);
    console.log('='.repeat(50));

    const diagnosis = {
      host: host,
      timestamp: new Date().toISOString(),
      tests: {}
    };

    // 1. Ping 测试
    console.log('\n1️⃣ 连通性测试:');
    diagnosis.tests.ping = await this.ping(host, 4);

    // 2. Traceroute 测试
    console.log('\n2️⃣ 路由追踪:');
    diagnosis.tests.traceroute = await this.traceroute(host, 15);

    // 3. DNS 解析测试
    console.log('\n3️⃣ DNS 解析测试:');
    try {
      const dns = require('dns').promises;
      const startTime = Date.now();
      const addresses = await dns.resolve4(host);
      const dnsTime = Date.now() - startTime;

      diagnosis.tests.dns = {
        success: true,
        addresses: addresses,
        time: dnsTime,
        primary: addresses[0]
      };

      console.log(`  ✅ DNS解析成功: ${addresses.join(', ')} (${dnsTime}ms)`);
    } catch (error) {
      diagnosis.tests.dns = {
        success: false,
        error: error.message
      };
      console.log(`  ❌ DNS解析失败: ${error.message}`);
    }

    // 4. 端口扫描（常见端口）
    console.log('\n4️⃣ 常见端口检测:');
    const commonPorts = [22, 25, 53, 80, 110, 143, 443, 993, 995];
    diagnosis.tests.ports = await this.scanPorts(host, commonPorts);

    // 5. 生成诊断报告
    this.generateDiagnosisReport(diagnosis);

    return diagnosis;
  }

  async scanPorts(host, ports) {
    const net = require('net');
    const results = [];

    console.log(`  扫描端口: ${ports.join(', ')}`);

    for (const port of ports) {
      try {
        await new Promise((resolve, reject) => {
          const socket = net.createConnection({ host, port, timeout: 3000 });

          socket.on('connect', () => {
            socket.end();
            results.push({ port, status: 'open', service: this.getServiceName(port) });
            resolve();
          });

          socket.on('timeout', () => {
            socket.destroy();
            results.push({ port, status: 'timeout', service: this.getServiceName(port) });
            resolve();
          });

          socket.on('error', (error) => {
            results.push({ port, status: 'closed', service: this.getServiceName(port) });
            resolve();
          });
        });
      } catch (error) {
        results.push({ port, status: 'error', service: this.getServiceName(port) });
      }
    }

    // 显示开放的端口
    const openPorts = results.filter(r => r.status === 'open');
    if (openPorts.length > 0) {
      console.log(`  🟢 开放端口:`);
      openPorts.forEach(p => {
        console.log(`    ${p.port}/tcp (${p.service})`);
      });
    } else {
      console.log(`  🔒 没有发现开放的端口`);
    }

    return results;
  }

  getServiceName(port) {
    const services = {
      22: 'SSH',
      25: 'SMTP',
      53: 'DNS',
      80: 'HTTP',
      110: 'POP3',
      143: 'IMAP',
      443: 'HTTPS',
      993: 'IMAPS',
      995: 'POP3S'
    };
    return services[port] || 'Unknown';
  }

  generateDiagnosisReport(diagnosis) {
    console.log('\n📋 网络诊断报告:');
    console.log('='.repeat(50));

    const { ping, dns, traceroute, ports } = diagnosis.tests;

    // 连通性评估
    let connectivity = '未知';
    if (ping) {
      const lossRate = parseFloat(ping.lossRate);
      if (lossRate === 0) connectivity = '✅ 优秀';
      else if (lossRate < 10) connectivity = '🟡 良好';
      else if (lossRate < 50) connectivity = '🟠 一般';
      else connectivity = '❌ 差';
    }

    console.log(`🌐 目标主机: ${diagnosis.host}`);
    console.log(`⏰ 检测时间: ${new Date(diagnosis.timestamp).toLocaleString()}`);
    console.log(`🔗 连通性: ${connectivity}`);

    if (ping) {
      console.log(`📊 延迟: 平均 ${ping.avgTime}ms (${ping.minTime}-${ping.maxTime}ms)`);
      console.log(`📦 丢包率: ${ping.lossRate}%`);
    }

    if (dns && dns.success) {
      console.log(`🔍 DNS: ${dns.addresses[0]} (${dns.time}ms)`);
    }

    if (traceroute) {
      console.log(`🛣️ 路由跳数: ${traceroute.totalHops}`);
    }

    const openPorts = ports.filter(p => p.status === 'open');
    if (openPorts.length > 0) {
      console.log(`🔓 开放服务: ${openPorts.map(p => p.service).join(', ')}`);
    }

    // 问题诊断
    console.log('\n🔧 问题诊断:');
    if (ping && parseFloat(ping.lossRate) > 0) {
      console.log('  ⚠️ 检测到丢包，可能的原因:');
      console.log('     - 网络拥塞');
      console.log('     - 防火墙过滤');
      console.log('     - 路由器配置问题');
    }

    if (ping && parseFloat(ping.avgTime) > 100) {
      console.log('  ⚠️ 延迟较高，可能的原因:');
      console.log('     - 物理距离较远');
      console.log('     - 网络拥塞');
      console.log('     - 路由路径不优');
    }

    if (dns && !dns.success) {
      console.log('  ❌ DNS解析失败，可能的原因:');
      console.log('     - DNS服务器问题');
      console.log('     - 域名不存在');
      console.log('     - 网络连接问题');
    }
  }
}

// 使用示例
async function demonstrateICMP() {
  const icmp = new ICMPAnalyzer();

  // 快速连通性测试
  console.log('🧪 ICMP 协议测试:');
  await icmp.ping('8.8.8.8', 4);

  // 完整网络诊断
  console.log('\n' + '='.repeat(60));
  await icmp.performNetworkDiagnosis('github.com');
}

// 运行ICMP演示
if (require.main === module) {
  demonstrateICMP().catch(console.error);
}
```

---

## 🔐 现代网络协议和安全协议

### 💡 现代应用层协议

现代网络协议针对特定场景进行了优化，提供更高效的通信解决方案。

#### 🚀 gRPC - 高性能RPC框架

gRPC 是Google开发的现代RPC框架，基于HTTP/2构建：

```javascript
// gRPC 概念演示（简化版）
class gRPCConcept {
  constructor() {
    this.services = new Map();
    this.clients = new Map();
  }

  // 定义服务
  defineService(serviceName, methods) {
    this.services.set(serviceName, {
      name: serviceName,
      methods: methods
    });

    console.log(`📋 定义服务: ${serviceName}`);
    Object.keys(methods).forEach(method => {
      console.log(`  - ${method}(${methods[method].input}) → ${methods[method].output}`);
    });
  }

  // 服务器端实现
  implementService(serviceName, implementations) {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`服务 ${serviceName} 不存在`);
    }

    service.implementations = implementations;
    console.log(`✅ 实现服务: ${serviceName}`);
  }

  // 客户端调用（模拟）
  async call(serviceName, methodName, request) {
    const service = this.services.get(serviceName);
    if (!service || !service.implementations) {
      throw new Error(`服务 ${serviceName} 未实现`);
    }

    const implementation = service.implementations[methodName];
    if (!implementation) {
      throw new Error(`方法 ${methodName} 不存在`);
    }

    console.log(`🔄 gRPC 调用: ${serviceName}.${methodName}`);
    console.log(`📤 请求:`, request);

    try {
      const response = await implementation(request);
      console.log(`📥 响应:`, response);
      return response;
    } catch (error) {
      console.error(`❌ 调用失败:`, error.message);
      throw error;
    }
  }

  // 流式调用模拟
  createStream(serviceName, methodName) {
    console.log(`🌊 创建流: ${serviceName}.${methodName}`);

    return {
      write: (data) => {
        console.log(`📤 流数据:`, data);
      },
      onData: (callback) => {
        console.log(`📥 监听流数据`);
        // 模拟接收数据
        setTimeout(() => {
          callback({ message: '流式数据', timestamp: Date.now() });
        }, 1000);
      },
      end: () => {
        console.log(`🔚 流结束`);
      }
    };
  }
}

// 使用示例
function demonstrateGRPC() {
  const grpc = new gRPCConcept();

  // 定义用户服务
  grpc.defineService('UserService', {
    GetUser: { input: 'UserId', output: 'User' },
    ListUsers: { input: 'ListUsersRequest', output: 'User[]' },
    CreateUser: { input: 'CreateUserRequest', output: 'User' }
  });

  // 实现服务
  grpc.implementService('UserService', {
    GetUser: async (request) => {
      return {
        id: request.id,
        name: `用户${request.id}`,
        email: `user${request.id}@example.com`
      };
    },

    ListUsers: async (request) => {
      return {
        users: [
          { id: 1, name: '张三', email: 'zhang@example.com' },
          { id: 2, name: '李四', email: 'li@example.com' }
        ],
        total: 2
      };
    },

    CreateUser: async (request) => {
      return {
        id: Date.now(),
        name: request.name,
        email: request.email,
        created_at: new Date().toISOString()
      };
    }
  });

  return grpc;
}
```

#### 📊 GraphQL - 查询语言

GraphQL 提供了灵活的数据查询接口：

```javascript
// GraphQL 概念演示
class GraphQLEngine {
  constructor() {
    this.schema = {};
    this.resolvers = {};
    this.dataSource = this.createMockData();
  }

  createMockData() {
    return {
      users: [
        { id: '1', name: '张三', email: 'zhang@example.com', posts: ['1', '2'] },
        { id: '2', name: '李四', email: 'li@example.com', posts: ['3'] }
      ],
      posts: [
        { id: '1', title: '第一篇文章', content: '内容...', authorId: '1' },
        { id: '2', title: '第二篇文章', content: '内容...', authorId: '1' },
        { id: '3', title: '第三篇文章', content: '内容...', authorId: '2' }
      ]
    };
  }

  // 定义 schema
  defineSchema(schema) {
    this.schema = schema;
    console.log('📋 定义 GraphQL Schema:');
    console.log(JSON.stringify(schema, null, 2));
  }

  // 设置解析器
  setResolvers(resolvers) {
    this.resolvers = resolvers;
    console.log('⚙️ 设置解析器');
  }

  // 执行查询
  async execute(query) {
    console.log('🔍 执行 GraphQL 查询:');
    console.log(query);

    // 简化的查询解析（实际GraphQL引擎要复杂得多）
    try {
      const result = await this.parseAndExecute(query);
      console.log('📥 查询结果:');
      console.log(JSON.stringify(result, null, 2));
      return result;
    } catch (error) {
      console.error('❌ 查询失败:', error.message);
      throw error;
    }
  }

  async parseAndExecute(query) {
    // 这是一个极简化的查询解析器
    const queryMatch = query.match(/query\s*{([\s\S]*)}/);
    if (!queryMatch) {
      throw new Error('无效的查询格式');
    }

    const queryBody = queryMatch[1].trim();
    const result = {};

    // 解析字段请求
    if (queryBody.includes('users')) {
      const userFields = this.extractFields(queryBody, 'users');
      result.users = await this.resolveUsers(userFields);
    }

    if (queryBody.includes('posts')) {
      const postFields = this.extractFields(queryBody, 'posts');
      result.posts = await this.resolvePosts(postFields);
    }

    return result;
  }

  extractFields(queryBody, typeName) {
    const regex = new RegExp(`${typeName}\\s*{([^}]*)}`, 'g');
    const match = regex.exec(queryBody);

    if (match) {
      return match[1]
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
    }

    return [];
  }

  async resolveUsers(fields) {
    return this.dataSource.users.map(user => {
      const resolved = {};

      fields.forEach(field => {
        if (field === 'id') resolved.id = user.id;
        if (field === 'name') resolved.name = user.name;
        if (field === 'email') resolved.email = user.email;
        if (field === 'postsCount') {
          resolved.postsCount = user.posts.length;
        }
      });

      return resolved;
    });
  }

  async resolvePosts(fields) {
    return this.dataSource.posts.map(post => {
      const resolved = {};

      fields.forEach(field => {
        if (field === 'id') resolved.id = post.id;
        if (field === 'title') resolved.title = post.title;
        if (field === 'content') resolved.content = post.content;
        if (field === 'author') {
          resolved.author = this.dataSource.users.find(
            user => user.id === post.authorId
          );
        }
      });

      return resolved;
    });
  }
}

// 使用示例
async function demonstrateGraphQL() {
  const graphql = new GraphQLEngine();

  // 定义 schema
  graphql.defineSchema({
    Query: {
      users: '[User!]!',
      posts: '[Post!]!',
      user: 'User'
    },
    User: {
      id: 'ID!',
      name: 'String!',
      email: 'String!',
      posts: '[Post!]!',
      postsCount: 'Int!'
    },
    Post: {
      id: 'ID!',
      title: 'String!',
      content: 'String!',
      author: 'User!'
    }
  });

  // 执行不同的查询
  console.log('\n1️⃣ 查询所有用户基本信息:');
  await graphql.execute(`
    query {
      users {
        id
        name
        email
        postsCount
      }
    }
  `);

  console.log('\n2️⃣ 查询文章及作者信息:');
  await graphql.execute(`
    query {
      posts {
        id
        title
        author {
          name
          email
        }
      }
    }
  `);
}
```

### 🛡️ 网络安全协议

现代网络安全协议确保数据传输的机密性、完整性和可用性。

#### 🔐 TLS/SSL - 传输层安全

```javascript
// TLS/SSL 概念演示
class TLSConcept {
  constructor() {
    this.supportedCiphers = [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-GCM-SHA384',
      'AES128-GCM-SHA256'
    ];

    this.supportedVersions = ['TLS 1.2', 'TLS 1.3'];
  }

  // 模拟 TLS 握手过程
  async performHandshake(clientHello, serverConfig) {
    console.log('🤝 开始 TLS 握手:');

    // 1. Client Hello
    console.log('\n1️⃣ Client Hello:');
    console.log(`  TLS版本: ${clientHello.version}`);
    console.log(`  支持的密码套件: ${clientHello.cipherSuites.slice(0, 3).join(', ')}...`);
    console.log(`  随机数: ${clientHello.random.slice(0, 16)}...`);

    // 2. Server Hello
    const selectedCipher = this.selectCipherSuite(clientHello.cipherSuites);
    const selectedVersion = this.selectTLSVersion(clientHello.version);

    console.log('\n2️⃣ Server Hello:');
    console.log(`  选择的TLS版本: ${selectedVersion}`);
    console.log(`  选择的密码套件: ${selectedCipher}`);
    console.log(`  会话ID: ${this.generateSessionId()}`);

    // 3. Certificate
    console.log('\n3️⃣ Server Certificate:');
    const cert = this.generateMockCertificate(serverConfig.domain);
    console.log(`  证书主体: ${cert.subject}`);
    console.log(`  颁发者: ${cert.issuer}`);
    console.log(`  有效期: ${cert.validFrom} - ${cert.validTo}`);

    // 4. Key Exchange
    console.log('\n4️⃣ Key Exchange:');
    const keyExchange = this.performKeyExchange(selectedCipher);
    console.log(`  密钥交换算法: ${keyExchange.algorithm}`);
    console.log(`  预主密钥长度: ${keyExchange.preMasterSecretLength} bits`);

    // 5. 密钥推导
    console.log('\n5️⃣ 密钥推导:');
    const keys = this.deriveKeys(keyExchange.preMasterSecret);
    console.log(`  客户端加密密钥: ${keys.clientEncKey.slice(0, 16)}...`);
    console.log(`  服务器加密密钥: ${keys.serverEncKey.slice(0, 16)}...`);

    // 6. Finished 消息
    console.log('\n6️⃣ Finished Messages:');
    console.log('  客户端: Finished ✅');
    console.log('  服务器: Finished ✅');

    console.log('\n✅ TLS 握手完成！安全通道建立。');

    return {
      version: selectedVersion,
      cipherSuite: selectedCipher,
      sessionId: this.generateSessionId(),
      keys: keys,
      certificate: cert
    };
  }

  selectCipherSuite(clientSuites) {
    // 选择服务器和客户端都支持的最强密码套件
    for (const serverSuite of this.supportedCiphers) {
      if (clientSuites.includes(serverSuite)) {
        return serverSuite;
      }
    }
    throw new Error('没有共同支持的密码套件');
  }

  selectTLSVersion(clientVersion) {
    if (clientVersion === 'TLS 1.3' && this.supportedVersions.includes('TLS 1.3')) {
      return 'TLS 1.3';
    }
    return 'TLS 1.2';
  }

  generateMockCertificate(domain) {
    return {
      subject: `CN=${domain}`,
      issuer: 'CN=Let\'s Encrypt Authority X3',
      validFrom: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      validTo: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      algorithm: 'RSA-SHA256',
      keySize: 2048,
      fingerprint: this.generateRandomHex(32)
    };
  }

  performKeyExchange(cipherSuite) {
    if (cipherSuite.includes('ECDHE')) {
      return {
        algorithm: 'ECDHE (椭圆曲线 Diffie-Hellman 临时)',
        curve: 'P-256',
        preMasterSecret: this.generateRandomHex(64),
        preMasterSecretLength: 256
      };
    } else {
      return {
        algorithm: 'RSA',
        preMasterSecret: this.generateRandomHex(48),
        preMasterSecretLength: 384
      };
    }
  }

  deriveKeys(preMasterSecret) {
    // 简化的密钥推导（实际使用 PRF - 伪随机函数）
    return {
      clientEncKey: this.generateRandomHex(32),
      serverEncKey: this.generateRandomHex(32),
      clientMacKey: this.generateRandomHex(32),
      serverMacKey: this.generateRandomHex(32),
      clientIV: this.generateRandomHex(16),
      serverIV: this.generateRandomHex(16)
    };
  }

  generateSessionId() {
    return this.generateRandomHex(32);
  }

  generateRandomHex(length) {
    const chars = '0123456789abcdef';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  // TLS 记录层模拟
  encryptData(data, keys) {
    console.log(`🔐 加密数据 (${data.length} 字节):`);
    console.log(`  使用密钥: ${keys.clientEncKey.slice(0, 16)}...`);

    // 模拟加密过程
    const encrypted = Buffer.from(data).toString('base64');
    console.log(`  加密结果: ${encrypted.slice(0, 32)}...`);

    return {
      type: 'application_data',
      version: 'TLS 1.2',
      length: encrypted.length,
      data: encrypted
    };
  }

  decryptData(encryptedRecord, keys) {
    console.log('🔓 解密数据:');
    console.log(`  使用密钥: ${keys.serverEncKey.slice(0, 16)}...`);

    // 模拟解密过程
    const decrypted = Buffer.from(encryptedRecord.data, 'base64').toString();
    console.log(`  解密结果: ${decrypted}`);

    return decrypted;
  }
}

// SSL/TLS 安全检查工具
class TLSSecurityChecker {
  constructor() {
    this.securityLevels = {
      'TLS 1.0': '❌ 不安全 (已废弃)',
      'TLS 1.1': '⚠️ 不推荐 (已废弃)',
      'TLS 1.2': '✅ 安全',
      'TLS 1.3': '🔒 最安全'
    };

    this.cipherStrengths = {
      'AES256-GCM': '🔒 强',
      'AES128-GCM': '✅ 中等',
      'AES256-CBC': '⚠️ 中等 (CBC模式)',
      'AES128-CBC': '⚠️ 较弱 (CBC模式)',
      'RC4': '❌ 不安全 (已废弃)',
      'DES': '❌ 不安全 (已废弃)'
    };
  }

  analyzeTLSConfiguration(config) {
    console.log('🔍 TLS 配置安全分析:');
    console.log('='.repeat(40));

    const report = {
      domain: config.domain,
      overall: 'unknown',
      issues: [],
      recommendations: []
    };

    // 检查 TLS 版本
    console.log('\n📋 TLS 版本检查:');
    config.supportedVersions.forEach(version => {
      const security = this.securityLevels[version];
      console.log(`  ${version}: ${security}`);

      if (version === 'TLS 1.0' || version === 'TLS 1.1') {
        report.issues.push(`支持已废弃的 ${version}`);
        report.recommendations.push(`禁用 ${version} 支持`);
      }
    });

    // 检查密码套件
    console.log('\n🔐 密码套件检查:');
    config.cipherSuites.forEach(suite => {
      const algorithm = this.extractEncryptionAlgorithm(suite);
      const strength = this.cipherStrengths[algorithm] || '❓ 未知';
      console.log(`  ${suite}: ${strength}`);

      if (suite.includes('RC4') || suite.includes('DES')) {
        report.issues.push(`使用不安全的加密算法: ${algorithm}`);
        report.recommendations.push(`移除包含 ${algorithm} 的密码套件`);
      }
    });

    // 检查证书
    console.log('\n📜 证书检查:');
    if (config.certificate) {
      const cert = config.certificate;
      const validFrom = new Date(cert.validFrom);
      const validTo = new Date(cert.validTo);
      const now = new Date();

      console.log(`  颁发者: ${cert.issuer}`);
      console.log(`  有效期: ${cert.validFrom} - ${cert.validTo}`);
      console.log(`  密钥长度: ${cert.keySize} bits`);

      if (now < validFrom || now > validTo) {
        report.issues.push('证书已过期或尚未生效');
        report.recommendations.push('更新SSL证书');
      }

      if (cert.keySize < 2048) {
        report.issues.push('RSA密钥长度过短');
        report.recommendations.push('使用至少2048位RSA密钥');
      }
    }

    // 生成总体评分
    if (report.issues.length === 0) {
      report.overall = '🔒 优秀';
    } else if (report.issues.length <= 2) {
      report.overall = '✅ 良好';
    } else if (report.issues.length <= 4) {
      report.overall = '⚠️ 需要改进';
    } else {
      report.overall = '❌ 不安全';
    }

    console.log(`\n📊 总体安全评级: ${report.overall}`);

    if (report.issues.length > 0) {
      console.log('\n⚠️ 发现的问题:');
      report.issues.forEach((issue, index) => {
        console.log(`  ${index + 1}. ${issue}`);
      });

      console.log('\n💡 建议改进:');
      report.recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec}`);
      });
    }

    return report;
  }

  extractEncryptionAlgorithm(cipherSuite) {
    if (cipherSuite.includes('AES256-GCM')) return 'AES256-GCM';
    if (cipherSuite.includes('AES128-GCM')) return 'AES128-GCM';
    if (cipherSuite.includes('AES256-CBC')) return 'AES256-CBC';
    if (cipherSuite.includes('AES128-CBC')) return 'AES128-CBC';
    if (cipherSuite.includes('RC4')) return 'RC4';
    if (cipherSuite.includes('DES')) return 'DES';
    return 'Unknown';
  }
}

// 使用示例
async function demonstrateTLS() {
  const tls = new TLSConcept();
  const checker = new TLSSecurityChecker();

  // 模拟客户端Hello
  const clientHello = {
    version: 'TLS 1.3',
    cipherSuites: [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-GCM-SHA384'
    ],
    random: tls.generateRandomHex(64)
  };

  const serverConfig = {
    domain: 'secure.example.com'
  };

  // 执行握手
  const handshakeResult = await tls.performHandshake(clientHello, serverConfig);

  // 演示数据加密传输
  console.log('\n' + '='.repeat(50));
  console.log('🔐 安全数据传输演示:');

  const originalData = 'Hello, this is secure data!';
  const encryptedRecord = tls.encryptData(originalData, handshakeResult.keys);
  const decryptedData = tls.decryptData(encryptedRecord, handshakeResult.keys);

  // TLS 配置安全检查
  console.log('\n' + '='.repeat(50));
  const tlsConfig = {
    domain: 'example.com',
    supportedVersions: ['TLS 1.2', 'TLS 1.3'],
    cipherSuites: [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-CBC-SHA256' // 较弱的密码套件
    ],
    certificate: {
      issuer: 'CN=DigiCert SHA2 Secure Server CA',
      validFrom: '2023-01-01',
      validTo: '2024-01-01',
      keySize: 2048,
      algorithm: 'RSA-SHA256'
    }
  };

  checker.analyzeTLSConfiguration(tlsConfig);
}
```

---

## 🛠️ 网络调试与监控实践

### 🔧 网络问题诊断工具集

```javascript
// 综合网络诊断工具
class NetworkDiagnostics {
  constructor() {
    this.tools = {
      ping: new PingTool(),
      traceroute: new TracerouteTool(),
      portScan: new PortScanTool(),
      dnsCheck: new DNSChecker(),
      sslCheck: new SSLChecker(),
      performance: new NetworkPerformanceTool()
    };
  }

  async runFullDiagnosis(target) {
    console.log(`🔧 对 ${target} 进行全面网络诊断`);
    console.log('='.repeat(60));

    const results = {
      target: target,
      timestamp: new Date().toISOString(),
      tests: {}
    };

    try {
      // 1. 基础连通性测试
      console.log('\n1️⃣ 基础连通性测试');
      results.tests.connectivity = await this.tools.ping.test(target);

      // 2. 路由追踪
      console.log('\n2️⃣ 路由路径分析');
      results.tests.routing = await this.tools.traceroute.trace(target);

      // 3. DNS解析检查
      console.log('\n3️⃣ DNS解析检查');
      results.tests.dns = await this.tools.dnsCheck.resolve(target);

      // 4. 端口扫描
      console.log('\n4️⃣ 服务端口检测');
      results.tests.ports = await this.tools.portScan.scan(target);

      // 5. SSL/TLS检查（如果是HTTPS）
      if (target.includes('https://') || results.tests.ports.some(p => p.port === 443 && p.status === 'open')) {
        console.log('\n5️⃣ SSL/TLS安全检查');
        results.tests.ssl = await this.tools.sslCheck.check(target);
      }

      // 6. 性能测试
      console.log('\n6️⃣ 网络性能测试');
      results.tests.performance = await this.tools.performance.measure(target);

      // 7. 生成诊断报告
      this.generateReport(results);

      return results;

    } catch (error) {
      console.error('❌ 诊断过程中出现错误:', error.message);
      return null;
    }
  }

  generateReport(results) {
    console.log('\n📊 网络诊断报告');
    console.log('='.repeat(50));

    const { target, tests } = results;
    const issues = [];
    const recommendations = [];

    console.log(`🎯 目标: ${target}`);
    console.log(`⏰ 检测时间: ${new Date(results.timestamp).toLocaleString()}`);

    // 分析连通性
    if (tests.connectivity) {
      const { lossRate, avgTime } = tests.connectivity;
      console.log(`\n🌐 连通性:`);
      console.log(`  丢包率: ${lossRate}%`);
      console.log(`  平均延迟: ${avgTime}ms`);

      if (parseFloat(lossRate) > 5) {
        issues.push('检测到明显丢包');
        recommendations.push('检查网络链路质量');
      }

      if (parseFloat(avgTime) > 200) {
        issues.push('网络延迟较高');
        recommendations.push('考虑使用CDN或优化路由');
      }
    }

    // 分析DNS
    if (tests.dns) {
      console.log(`\n🔍 DNS解析:`);
      if (tests.dns.success) {
        console.log(`  解析成功: ${tests.dns.addresses[0]} (${tests.dns.time}ms)`);

        if (tests.dns.time > 100) {
          issues.push('DNS解析时间较长');
          recommendations.push('考虑更换更快的DNS服务器');
        }
      } else {
        console.log(`  解析失败: ${tests.dns.error}`);
        issues.push('DNS解析失败');
        recommendations.push('检查DNS配置');
      }
    }

    // 分析SSL
    if (tests.ssl) {
      console.log(`\n🔒 SSL/TLS:`);
      console.log(`  协议版本: ${tests.ssl.version}`);
      console.log(`  证书状态: ${tests.ssl.certificateValid ? '✅ 有效' : '❌ 无效'}`);

      if (!tests.ssl.certificateValid) {
        issues.push('SSL证书无效或过期');
        recommendations.push('更新SSL证书');
      }

      if (tests.ssl.version === 'TLS 1.0' || tests.ssl.version === 'TLS 1.1') {
        issues.push('使用过时的TLS版本');
        recommendations.push('升级到TLS 1.2或1.3');
      }
    }

    // 分析性能
    if (tests.performance) {
      console.log(`\n⚡ 性能指标:`);
      console.log(`  带宽利用率: ${tests.performance.bandwidth} Mbps`);
      console.log(`  连接建立时间: ${tests.performance.connectTime}ms`);

      if (tests.performance.connectTime > 1000) {
        issues.push('连接建立时间过长');
        recommendations.push('优化服务器响应时间');
      }
    }

    // 总体评估
    let overallStatus;
    if (issues.length === 0) {
      overallStatus = '✅ 优秀';
    } else if (issues.length <= 2) {
      overallStatus = '🟡 良好';
    } else if (issues.length <= 4) {
      overallStatus = '🟠 需要优化';
    } else {
      overallStatus = '❌ 存在问题';
    }

    console.log(`\n📊 总体状态: ${overallStatus}`);

    if (issues.length > 0) {
      console.log('\n⚠️ 发现的问题:');
      issues.forEach((issue, index) => {
        console.log(`  ${index + 1}. ${issue}`);
      });

      console.log('\n💡 优化建议:');
      recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec}`);
      });
    }
  }
}

// 网络性能监控工具
class NetworkMonitor {
  constructor() {
    this.isMonitoring = false;
    this.metrics = [];
    this.alertThresholds = {
      latency: 500, // ms
      packetLoss: 5, // %
      bandwidth: 1 // Mbps minimum
    };
  }

  startMonitoring(targets, interval = 60000) {
    if (this.isMonitoring) {
      console.log('⚠️ 监控已在运行');
      return;
    }

    this.isMonitoring = true;
    console.log(`📊 开始网络监控 (${targets.length} 个目标, ${interval/1000}s 间隔)`);

    this.monitoringInterval = setInterval(async () => {
      for (const target of targets) {
        try {
          const metrics = await this.collectMetrics(target);
          this.metrics.push({
            target: target,
            timestamp: Date.now(),
            ...metrics
          });

          // 检查告警条件
          this.checkAlerts(target, metrics);

          // 保持最近1000条记录
          if (this.metrics.length > 1000) {
            this.metrics = this.metrics.slice(-1000);
          }

        } catch (error) {
          console.error(`❌ 监控 ${target} 时出错:`, error.message);
        }
      }
    }, interval);

    return this;
  }

  async collectMetrics(target) {
    // 简化的指标收集
    const ping = await this.measureLatency(target);
    const bandwidth = await this.measureBandwidth(target);

    return {
      latency: ping.avgTime,
      packetLoss: ping.lossRate,
      jitter: ping.jitter || 0,
      bandwidth: bandwidth
    };
  }

  async measureLatency(target, samples = 3) {
    // 这里应该调用实际的ping工具
    // 模拟数据
    const latencies = Array.from({length: samples}, () =>
      Math.random() * 200 + 50
    );

    const avgTime = latencies.reduce((a, b) => a + b, 0) / latencies.length;
    const lossRate = Math.random() * 10; // 模拟丢包率

    return {
      avgTime: avgTime.toFixed(2),
      lossRate: lossRate.toFixed(2),
      jitter: Math.random() * 20 // 模拟抖动
    };
  }

  async measureBandwidth(target) {
    // 模拟带宽测试
    return (Math.random() * 100 + 10).toFixed(2);
  }

  checkAlerts(target, metrics) {
    const alerts = [];

    if (parseFloat(metrics.latency) > this.alertThresholds.latency) {
      alerts.push(`高延迟: ${metrics.latency}ms > ${this.alertThresholds.latency}ms`);
    }

    if (parseFloat(metrics.packetLoss) > this.alertThresholds.packetLoss) {
      alerts.push(`高丢包率: ${metrics.packetLoss}% > ${this.alertThresholds.packetLoss}%`);
    }

    if (parseFloat(metrics.bandwidth) < this.alertThresholds.bandwidth) {
      alerts.push(`低带宽: ${metrics.bandwidth}Mbps < ${this.alertThresholds.bandwidth}Mbps`);
    }

    if (alerts.length > 0) {
      console.log(`🚨 ${target} 告警:`);
      alerts.forEach(alert => console.log(`  - ${alert}`));
    }
  }

  getStatistics(target = null, timeRange = 3600000) { // 1小时
    const now = Date.now();
    const startTime = now - timeRange;

    let filteredMetrics = this.metrics.filter(m => m.timestamp >= startTime);

    if (target) {
      filteredMetrics = filteredMetrics.filter(m => m.target === target);
    }

    if (filteredMetrics.length === 0) {
      return null;
    }

    const latencies = filteredMetrics.map(m => parseFloat(m.latency));
    const packetLosses = filteredMetrics.map(m => parseFloat(m.packetLoss));
    const bandwidths = filteredMetrics.map(m => parseFloat(m.bandwidth));

    return {
      target: target || 'all',
      timeRange: `${timeRange / 60000} 分钟`,
      samples: filteredMetrics.length,
      latency: {
        avg: (latencies.reduce((a, b) => a + b, 0) / latencies.length).toFixed(2),
        min: Math.min(...latencies).toFixed(2),
        max: Math.max(...latencies).toFixed(2)
      },
      packetLoss: {
        avg: (packetLosses.reduce((a, b) => a + b, 0) / packetLosses.length).toFixed(2),
        max: Math.max(...packetLosses).toFixed(2)
      },
      bandwidth: {
        avg: (bandwidths.reduce((a, b) => a + b, 0) / bandwidths.length).toFixed(2),
        min: Math.min(...bandwidths).toFixed(2),
        max: Math.max(...bandwidths).toFixed(2)
      }
    };
  }

  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.isMonitoring = false;
      console.log('📊 网络监控已停止');
    }
  }
}

// 使用示例
async function demonstrateNetworkTools() {
  // 网络诊断示例
  const diagnostics = new NetworkDiagnostics();
  await diagnostics.runFullDiagnosis('github.com');

  // 网络监控示例
  console.log('\n' + '='.repeat(60));
  console.log('📊 网络监控演示:');

  const monitor = new NetworkMonitor();

  // 设置告警阈值
  monitor.alertThresholds = {
    latency: 200,
    packetLoss: 3,
    bandwidth: 5
  };

  // 开始监控
  monitor.startMonitoring(['github.com', 'google.com'], 10000);

  // 5分钟后显示统计信息并停止监控
  setTimeout(() => {
    const stats = monitor.getStatistics('github.com', 300000);
    if (stats) {
      console.log('\n📈 监控统计 (最近5分钟):');
      console.log(`目标: ${stats.target}`);
      console.log(`样本数: ${stats.samples}`);
      console.log(`延迟: 平均${stats.latency.avg}ms, 范围${stats.latency.min}-${stats.latency.max}ms`);
      console.log(`丢包率: 平均${stats.packetLoss.avg}%, 最高${stats.packetLoss.max}%`);
      console.log(`带宽: 平均${stats.bandwidth.avg}Mbps, 范围${stats.bandwidth.min}-${stats.bandwidth.max}Mbps`);
    }

    monitor.stopMonitoring();
  }, 300000);
}

// 运行演示
if (require.main === module) {
  Promise.all([
    demonstrateGraphQL(),
    demonstrateTLS(),
    demonstrateNetworkTools()
  ]).catch(console.error);
}
```

---

## 📚 学习总结与进阶指南

### 🎯 核心要点回顾

通过本文档的学习，你应该已经掌握了：

1. **🌐 协议分层架构**：理解OSI和TCP/IP模型的设计理念
2. **📱 应用层协议**：HTTP/HTTPS、WebSocket、DNS的工作原理
3. **🚀 传输层协议**：TCP、UDP的特性和应用场景
4. **🌐 网络层协议**：IP地址、路由、ICMP的核心概念
5. **🔐 安全协议**：TLS/SSL、现代加密技术的实现
6. **🛠️ 实践技能**：网络诊断、监控和优化的方法

### 💡 实践项目建议

#### 🚀 初级项目
1. **HTTP客户端工具**：实现支持多种HTTP方法的客户端
2. **简单聊天室**：使用WebSocket构建实时通信应用
3. **DNS查询工具**：创建可视化的DNS解析工具
4. **网络延迟监控**：开发ping和traceroute工具

#### 🌟 中级项目
1. **负载均衡器**：实现简单的HTTP负载均衡
2. **代理服务器**：构建HTTP/HTTPS代理
3. **网络性能分析仪**：集成多种网络测试功能
4. **SSL证书监控系统**：自动检查证书过期状态

#### 🔥 高级项目
1. **自定义协议设计**：设计并实现专用通信协议
2. **网络流量分析器**：类似Wireshark的数据包分析工具
3. **分布式网络监控**：多节点网络健康监控系统
4. **网络安全扫描器**：自动化安全漏洞检测工具

### 🔍 深入学习方向

#### 📖 推荐书籍
- 《TCP/IP详解》- Richard Stevens
- 《计算机网络：自顶向下方法》- James Kurose
- 《HTTP权威指南》- David Gourley
- 《网络安全与密码学》- William Stallings

#### 🌐 在线资源
- RFC文档：互联网标准的权威来源
- Wireshark官方教程：数据包分析实战
- Mozilla开发者网络：Web协议参考
- OWASP：Web安全最佳实践

#### 🎓 认证建议
- **Cisco CCNA**：网络基础认证
- **CompTIA Network+**：网络技术综合认证
- **Certified Ethical Hacker**：网络安全认证

### ⚡ 性能优化指南

#### 🚀 网络优化策略
```
1. 延迟优化
   ├── 使用CDN
   ├── 选择最优服务器位置
   ├── 启用HTTP/2
   └── 压缩传输内容

2. 带宽优化
   ├── 图片压缩与格式优化
   ├── 代码压缩与混淆
   ├── 启用Gzip压缩
   └── 缓存策略优化

3. 连接优化
   ├── 连接复用
   ├── Keep-Alive设置
   ├── 减少DNS查询
   └── 预连接关键资源
```

#### 🔧 监控指标
- **延迟指标**：RTT、TTFB、页面加载时间
- **可靠性指标**：丢包率、错误率、可用性
- **吞吐量指标**：带宽利用率、并发连接数
- **安全指标**：SSL握手时间、证书有效性

### 🎪 故障排查清单

#### 🔍 网络问题诊断流程
```
1. 确认问题范围
   ├── 影响范围：单用户 vs 全部用户
   ├── 故障类型：连通性 vs 性能 vs 安全
   └── 时间模式：间歇性 vs 持续性

2. 基础连通性检查
   ├── ping 目标主机
   ├── traceroute 路径分析
   ├── DNS 解析验证
   └── 端口连通性测试

3. 协议层分析
   ├── 应用层：HTTP状态码、API响应
   ├── 传输层：TCP连接状态、端口监听
   ├── 网络层：路由表、IP配置
   └── 链路层：网卡状态、交换机日志

4. 性能分析
   ├── 带宽测试
   ├── 延迟测量
   ├── 并发连接测试
   └── 资源利用率检查

5. 安全检查
   ├── SSL/TLS 配置验证
   ├── 防火墙规则检查
   ├── 入侵检测日志
   └── 证书有效性验证
```

### 🚀 下一步学习建议

1. **🔧 动手实践**：完成至少3个不同复杂度的网络项目
2. **📊 深入分析**：使用Wireshark分析真实网络流量
3. **🛡️ 安全意识**：学习常见网络攻击和防护方法
4. **☁️ 云网络**：了解现代云计算网络架构
5. **📱 移动网络**：研究5G、WiFi 6等新技术

记住：网络协议是一个实践性很强的领域。理论学习要与实际动手相结合，通过搭建实验环境、分析网络流量、解决实际问题来深化理解。

---

📝 **最后的话**：
网络协议是计算机科学的基石，掌握这些知识不仅能让你成为更好的开发者，还能让你理解现代数字世界的运作方式。继续保持好奇心，持续学习和实践！

🎉 **恭喜你完成了这份详尽的网络协议学习之旅！**

有任何问题或想要深入探讨某个特定协议，随时来问我！让我们一起在网络技术的海洋中继续探索！🌊🚀