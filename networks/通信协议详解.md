# ğŸŒ è®¡ç®—æœºç½‘ç»œé€šä¿¡åè®®è¯¦è§£

æ¬¢è¿è¿›å…¥ç½‘ç»œé€šä¿¡åè®®çš„å¥‡å¦™ä¸–ç•Œï¼è¿™ä»½æ–‡æ¡£å°†å¸¦ä½ ç³»ç»Ÿæ€§åœ°ç†è§£ç°ä»£ç½‘ç»œé€šä¿¡çš„æ ¸å¿ƒæœºåˆ¶ã€‚

## ğŸ“š å­¦ä¹ ç›®æ ‡

æŒæ¡æœ¬æ–‡æ¡£åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- ğŸ¯ æ·±å…¥ç†è§£ç½‘ç»œåè®®çš„åˆ†å±‚æ¶æ„
- ğŸ’¡ æŒæ¡ä¸»æµé€šä¿¡åè®®çš„å·¥ä½œåŸç†
- ğŸ› ï¸ å…·å¤‡ç½‘ç»œé—®é¢˜çš„è¯Šæ–­å’Œè°ƒè¯•èƒ½åŠ›
- ğŸ” ç†è§£ç½‘ç»œå®‰å…¨åè®®çš„é‡è¦æ€§
- âš¡ ä¼˜åŒ–åº”ç”¨çš„ç½‘ç»œæ€§èƒ½

---

## ğŸ¯ åè®®åŸºç¡€æ¦‚å¿µ

### ğŸ¤” ä»€ä¹ˆæ˜¯ç½‘ç»œé€šä¿¡åè®®ï¼Ÿ

**ç½‘ç»œé€šä¿¡åè®®**å°±åƒæ˜¯ä¸åŒè®¾å¤‡ä¹‹é—´äº¤æµçš„"è¯­è¨€è§„åˆ™"ã€‚æƒ³è±¡ä¸€ä¸‹ä¸¤ä¸ªäººè¦é€šä¿¡ï¼š
- ä»–ä»¬éœ€è¦ä½¿ç”¨ç›¸åŒçš„è¯­è¨€ï¼ˆåè®®æ ‡å‡†ï¼‰
- è¦éµå¾ªä¸€å®šçš„å¯¹è¯è§„åˆ™ï¼ˆæ¶ˆæ¯æ ¼å¼ï¼‰
- ç¡®ä¿ä¿¡æ¯å‡†ç¡®ä¼ è¾¾ï¼ˆé”™è¯¯æ£€æµ‹ä¸æ¢å¤ï¼‰

```
å‘é€æ–¹                    æ¥æ”¶æ–¹
  ğŸ“±  â†’  [ç½‘ç»œåè®®]  â†’      ğŸ–¥ï¸
 "Hello"   æŒ‰è§„åˆ™ç¼–ç      è§£ç æ˜¾ç¤º
```

### ğŸ—ï¸ åè®®åˆ†å±‚æ¶æ„

è®¡ç®—æœºç½‘ç»œé‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼Œæ¯å±‚åªå…³å¿ƒè‡ªå·±çš„èŒè´£ï¼Œè¿™æ ·çš„è®¾è®¡è®©ç½‘ç»œç³»ç»Ÿï¼š
- âœ… **æ¨¡å—åŒ–**ï¼šå„å±‚ç‹¬ç«‹å¼€å‘å’Œç»´æŠ¤
- âœ… **å¯æ‰©å±•**ï¼šæ–°åè®®å¯ä»¥åœ¨ç‰¹å®šå±‚æ·»åŠ 
- âœ… **æ˜“è°ƒè¯•**ï¼šé—®é¢˜å®šä½æ›´åŠ ç²¾ç¡®

#### OSI ä¸ƒå±‚æ¨¡å‹ vs TCP/IP å››å±‚æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OSI ä¸ƒå±‚æ¨¡å‹    â”‚   TCP/IP å››å±‚     â”‚    å¸¸è§åè®®          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åº”ç”¨å±‚(Application) â”‚                  â”‚ HTTP, HTTPS, FTP,   â”‚
â”‚ è¡¨ç¤ºå±‚(Presentation)â”‚   åº”ç”¨å±‚          â”‚ DNS, SMTP, SSH,     â”‚
â”‚ ä¼šè¯å±‚(Session)     â”‚                  â”‚ WebSocket, gRPC     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä¼ è¾“å±‚(Transport)  â”‚   ä¼ è¾“å±‚          â”‚ TCP, UDP, QUIC      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç½‘ç»œå±‚(Network)    â”‚   ç½‘ç»œå±‚          â”‚ IP, ICMP, ARP       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ•°æ®é“¾è·¯å±‚(Data Link)â”‚   ç½‘ç»œæ¥å£å±‚      â”‚ Ethernet, WiFi      â”‚
â”‚ ç‰©ç†å±‚(Physical)   â”‚                  â”‚ å…‰çº¤, åŒç»çº¿         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ”„ åè®®æ ˆå·¥ä½œæµç¨‹

å½“ä½ åœ¨æµè§ˆå™¨è¾“å…¥ `https://www.example.com` æ—¶ï¼š

```
æµè§ˆå™¨å‘é€è¯·æ±‚ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åº”ç”¨å±‚: HTTP GET /                        â”‚ â† ç”¨æˆ·çœ‹åˆ°çš„
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä¼ è¾“å±‚: TCP 443ç«¯å£ï¼Œåˆ†ç‰‡ï¼Œé”™è¯¯æ£€æµ‹        â”‚ â† å¯é ä¼ è¾“
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç½‘ç»œå±‚: IP è·¯ç”±å¯»å€ï¼Œè·¨ç½‘ç»œä¼ è¾“           â”‚ â† è·¯å¾„é€‰æ‹©
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é“¾è·¯å±‚: ä»¥å¤ªç½‘å¸§ï¼Œæœ¬åœ°ç½‘ç»œä¼ è¾“           â”‚ â† ç‰©ç†ä¼ è¾“
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’­ ç†è§£åè®®è®¾è®¡å“²å­¦

æ¯ä¸ªåè®®éƒ½æœ‰å…¶è®¾è®¡ç›®æ ‡å’Œæƒè¡¡ï¼š

| è®¾è®¡ç›®æ ‡ | ä¼˜åŠ¿ | ä»£ä»· | å…¸å‹åè®® |
|---------|-----|-----|----------|
| **å¯é æ€§** | æ•°æ®å®Œæ•´å‡†ç¡® | æ€§èƒ½å¼€é”€ | TCP |
| **é€Ÿåº¦** | ä½å»¶è¿Ÿä¼ è¾“ | å¯èƒ½ä¸¢å¤± | UDP |
| **å®‰å…¨æ€§** | æ•°æ®åŠ å¯†ä¿æŠ¤ | è®¡ç®—å¼€é”€ | HTTPS, TLS |
| **ç®€å•æ€§** | æ˜“å®ç°ç»´æŠ¤ | åŠŸèƒ½é™åˆ¶ | HTTP/1.1 |
| **æ‰©å±•æ€§** | åŠŸèƒ½ä¸°å¯Œ | å¤æ‚åº¦é«˜ | HTTP/2 |

---

## ğŸ“± åº”ç”¨å±‚åè®®è¯¦è§£

åº”ç”¨å±‚åè®®ç›´æ¥ä¸ºç”¨æˆ·æä¾›ç½‘ç»œæœåŠ¡ï¼Œæ˜¯å¼€å‘è€…æœ€å¸¸æ¥è§¦çš„åè®®å±‚ã€‚

### ğŸŒ HTTP/HTTPS - Webé€šä¿¡åŸºçŸ³

HTTP(è¶…æ–‡æœ¬ä¼ è¾“åè®®)æ˜¯äº’è”ç½‘çš„åŸºç¡€ï¼Œè®©æˆ‘ä»¬æ·±å…¥ç†è§£å®ƒï¼š

#### ğŸ” HTTP è¯·æ±‚-å“åº”æ¨¡å‹

```
å®¢æˆ·ç«¯                     æœåŠ¡å™¨
   â”‚                        â”‚
   â”œâ”€â”€ HTTP Request â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
   â”‚   GET /api/users        â”‚
   â”‚   Host: api.example.com â”‚
   â”‚   Accept: application/json â”‚
   â”‚                        â”‚
   â”‚â†â”€â”€â”€ HTTP Response â”€â”€â”€â”€â”€â”€â”¤
   â”‚   200 OK                â”‚
   â”‚   Content-Type: json    â”‚
   â”‚   {"users": [...]}      â”‚
```

#### ğŸ“Š HTTP ç‰ˆæœ¬æ¼”è¿›

**HTTP/1.1** (1997å¹´):
- âœ… æŒä¹…è¿æ¥ï¼šä¸€ä¸ªTCPè¿æ¥å¤šä¸ªè¯·æ±‚
- âœ… ç®¡é“åŒ–ï¼šå¹¶è¡Œå‘é€è¯·æ±‚
- âŒ é˜Ÿå¤´é˜»å¡ï¼šå‰é¢è¯·æ±‚é˜»å¡åç»­è¯·æ±‚

```javascript
// HTTP/1.1 çš„é—®é¢˜æ¼”ç¤º
async function http1Problem() {
  // è¿™äº›è¯·æ±‚ä¼šæŒ‰é¡ºåºæ‰§è¡Œï¼Œæ…¢è¯·æ±‚é˜»å¡åç»­è¯·æ±‚
  const responses = [];

  responses[0] = await fetch('/slow-api');      // è€—æ—¶2ç§’
  responses[1] = await fetch('/fast-api-1');   // è¢«é˜»å¡
  responses[2] = await fetch('/fast-api-2');   // è¢«é˜»å¡

  return responses;
}
```

**HTTP/2** (2015å¹´):
- âœ… å¤šè·¯å¤ç”¨ï¼šå•è¿æ¥å¹¶è¡Œå¤šä¸ªè¯·æ±‚
- âœ… æœåŠ¡å™¨æ¨é€ï¼šä¸»åŠ¨æ¨é€èµ„æº
- âœ… å¤´éƒ¨å‹ç¼©ï¼šå‡å°‘é‡å¤å¤´ä¿¡æ¯

```javascript
// HTTP/2 çš„ä¼˜åŠ¿
async function http2Advantage() {
  // è¿™äº›è¯·æ±‚å¯ä»¥çœŸæ­£å¹¶è¡Œæ‰§è¡Œ
  const responses = await Promise.all([
    fetch('/slow-api'),      // 2ç§’ï¼Œä¸é˜»å¡å…¶ä»–
    fetch('/fast-api-1'),   // 100msï¼Œç«‹å³è¿”å›
    fetch('/fast-api-2')    // 100msï¼Œç«‹å³è¿”å›
  ]);

  return responses; // æ€»è€—æ—¶çº¦2ç§’ï¼Œä¸æ˜¯2.2ç§’
}
```

**HTTP/3** (åŸºäºQUIC):
- âœ… åŸºäºUDPï¼šé¿å…TCPçš„é˜Ÿå¤´é˜»å¡
- âœ… 0-RTTè¿æ¥ï¼šæ›´å¿«çš„è¿æ¥å»ºç«‹
- âœ… è¿æ¥è¿ç§»ï¼šç½‘ç»œåˆ‡æ¢æ— éœ€é‡è¿

#### ğŸ› ï¸ HTTP å®è·µä»£ç 

```javascript
// ç°ä»£ HTTP å®¢æˆ·ç«¯å®ç°
class ModernHTTPClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'User-Agent': 'ModernClient/1.0',
      ...options.headers
    };
  }

  async request(method, url, options = {}) {
    const fullURL = new URL(url, this.baseURL);

    const config = {
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    };

    // è¯·æ±‚æ‹¦æˆªå™¨
    console.log(`ğŸš€ ${method.toUpperCase()} ${fullURL}`);
    const startTime = Date.now();

    try {
      const response = await fetch(fullURL, config);
      const duration = Date.now() - startTime;

      // å“åº”æ‹¦æˆªå™¨
      console.log(`âœ… ${response.status} (${duration}ms)`);

      if (!response.ok) {
        throw new HTTPError(response.status, response.statusText);
      }

      return this.parseResponse(response);
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`âŒ è¯·æ±‚å¤±è´¥ (${duration}ms):`, error.message);
      throw error;
    }
  }

  async parseResponse(response) {
    const contentType = response.headers.get('content-type');

    if (contentType?.includes('application/json')) {
      return { data: await response.json(), headers: response.headers };
    } else if (contentType?.includes('text/')) {
      return { data: await response.text(), headers: response.headers };
    } else {
      return { data: await response.blob(), headers: response.headers };
    }
  }

  // ä¾¿æ·æ–¹æ³•
  get(url, options) { return this.request('GET', url, options); }
  post(url, data, options) {
    return this.request('POST', url, {
      ...options,
      body: JSON.stringify(data)
    });
  }
  put(url, data, options) {
    return this.request('PUT', url, {
      ...options,
      body: JSON.stringify(data)
    });
  }
  delete(url, options) { return this.request('DELETE', url, options); }
}

class HTTPError extends Error {
  constructor(status, statusText) {
    super(`HTTP ${status}: ${statusText}`);
    this.status = status;
    this.statusText = statusText;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const client = new ModernHTTPClient('https://api.github.com');

async function demonstrateHTTP() {
  try {
    // GET è¯·æ±‚
    const { data: user } = await client.get('/users/octocat');
    console.log('ç”¨æˆ·ä¿¡æ¯:', user.name);

    // POST è¯·æ±‚ï¼ˆç¤ºä¾‹ï¼‰
    const { data: created } = await client.post('/user/repos', {
      name: 'test-repo',
      description: 'HTTP åè®®å­¦ä¹ é¡¹ç›®'
    });

  } catch (error) {
    if (error instanceof HTTPError) {
      console.error('HTTPé”™è¯¯:', error.status, error.statusText);
    } else {
      console.error('ç½‘ç»œé”™è¯¯:', error.message);
    }
  }
}
```

#### ğŸ” HTTPS - å®‰å…¨çš„HTTP

HTTPS = HTTP + TLS/SSLï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å®‰å…¨å±‚å¦‚ä½•å·¥ä½œï¼š

```
HTTPS æ¡æ‰‹è¿‡ç¨‹ï¼š
å®¢æˆ·ç«¯                          æœåŠ¡å™¨
  â”‚                             â”‚
  â”œâ”€ 1. Client Hello â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (æ”¯æŒçš„åŠ å¯†ç®—æ³•)
  â”‚â†â”€ 2. Server Hello â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (é€‰æ‹©çš„ç®—æ³• + è¯ä¹¦)
  â”‚â†â”€ 3. Certificate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ (å…¬é’¥è¯ä¹¦)
  â”œâ”€ 4. Key Exchange â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (åŠ å¯†çš„é¢„ä¸»å¯†é’¥)
  â”‚â†â”€ 5. Server Finished â”€â”€â”€â”€â”€â”€â”¤
  â”œâ”€ 6. Client Finished â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                             â”‚
  â”œâ”€â”€â”€ åŠ å¯†çš„HTTPé€šä¿¡ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
```

```javascript
// TLS/SSL è¯ä¹¦éªŒè¯å·¥å…·
const https = require('https');
const tls = require('tls');

class CertificateChecker {
  async checkCertificate(hostname, port = 443) {
    return new Promise((resolve, reject) => {
      const socket = tls.connect(port, hostname, {
        servername: hostname // SNI support
      }, () => {
        const cert = socket.getPeerCertificate(true);
        const result = this.analyzeCertificate(cert);
        socket.end();
        resolve(result);
      });

      socket.on('error', reject);
    });
  }

  analyzeCertificate(cert) {
    const now = new Date();
    const validFrom = new Date(cert.valid_from);
    const validTo = new Date(cert.valid_to);

    return {
      subject: cert.subject.CN,
      issuer: cert.issuer.CN,
      valid_from: validFrom.toISOString(),
      valid_to: validTo.toISOString(),
      days_until_expiry: Math.ceil((validTo - now) / (1000 * 60 * 60 * 24)),
      fingerprint: cert.fingerprint,
      is_valid: now >= validFrom && now <= validTo,
      algorithm: cert.sigalg
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function checkWebsiteSecurity() {
  const checker = new CertificateChecker();

  try {
    const cert = await checker.checkCertificate('github.com');

    console.log('ğŸ”’ è¯ä¹¦ä¿¡æ¯:');
    console.log(`  åŸŸå: ${cert.subject}`);
    console.log(`  é¢å‘è€…: ${cert.issuer}`);
    console.log(`  æœ‰æ•ˆæœŸ: ${cert.valid_from} - ${cert.valid_to}`);
    console.log(`  å‰©ä½™å¤©æ•°: ${cert.days_until_expiry}`);
    console.log(`  çŠ¶æ€: ${cert.is_valid ? 'âœ… æœ‰æ•ˆ' : 'âŒ æ— æ•ˆ'}`);
    console.log(`  æŒ‡çº¹: ${cert.fingerprint}`);

  } catch (error) {
    console.error('âŒ è¯ä¹¦æ£€æŸ¥å¤±è´¥:', error.message);
  }
}
```

### ğŸ”„ WebSocket - å…¨åŒå·¥å®æ—¶é€šä¿¡

WebSocket åè®®è§£å†³äº† HTTP è¯·æ±‚-å“åº”æ¨¡å¼çš„é™åˆ¶ï¼Œå®ç°çœŸæ­£çš„åŒå‘é€šä¿¡ï¼š

#### ğŸ“Š WebSocket vs HTTP å¯¹æ¯”

```
HTTP é€šä¿¡æ¨¡å¼:
å®¢æˆ·ç«¯ â”€â”€requestâ”€â”€â†’ æœåŠ¡å™¨
      â†â”€responseâ”€â”˜

WebSocket é€šä¿¡æ¨¡å¼:
å®¢æˆ·ç«¯ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ æœåŠ¡å™¨
      åŒå‘å®æ—¶é€šä¿¡
```

#### ğŸ” WebSocket æ¡æ‰‹è¿‡ç¨‹

```
HTTP å‡çº§æ¡æ‰‹:
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

#### ğŸ› ï¸ WebSocket å®è·µå®ç°

```javascript
// é«˜çº§ WebSocket å®¢æˆ·ç«¯
class AdvancedWebSocket extends EventTarget {
  constructor(url, options = {}) {
    super();
    this.url = url;
    this.options = {
      reconnectDelay: 1000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      ...options
    };

    this.reconnectAttempts = 0;
    this.isReconnecting = false;
    this.heartbeatTimer = null;

    this.connect();
  }

  connect() {
    console.log(`ğŸ”Œ è¿æ¥åˆ° WebSocket: ${this.url}`);

    this.ws = new WebSocket(this.url);

    this.ws.onopen = (event) => {
      console.log('âœ… WebSocket è¿æ¥å»ºç«‹');
      this.reconnectAttempts = 0;
      this.isReconnecting = false;
      this.startHeartbeat();
      this.dispatchEvent(new CustomEvent('connected', { detail: event }));
    };

    this.ws.onmessage = (event) => {
      const data = this.parseMessage(event.data);
      console.log('ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯:', data);
      this.dispatchEvent(new CustomEvent('message', { detail: data }));
    };

    this.ws.onclose = (event) => {
      console.log('ğŸ”Œ WebSocket è¿æ¥å…³é—­:', event.code, event.reason);
      this.stopHeartbeat();

      if (!event.wasClean && !this.isReconnecting) {
        this.attemptReconnect();
      }

      this.dispatchEvent(new CustomEvent('disconnected', { detail: event }));
    };

    this.ws.onerror = (event) => {
      console.error('âŒ WebSocket é”™è¯¯:', event);
      this.dispatchEvent(new CustomEvent('error', { detail: event }));
    };
  }

  parseMessage(data) {
    try {
      return JSON.parse(data);
    } catch {
      return data; // è¿”å›åŸå§‹æ•°æ®
    }
  }

  send(data) {
    if (this.ws.readyState === WebSocket.OPEN) {
      const message = typeof data === 'object' ? JSON.stringify(data) : data;
      this.ws.send(message);
      console.log('ğŸ“¤ å‘é€æ¶ˆæ¯:', data);
    } else {
      console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œæ¶ˆæ¯æœªå‘é€');
    }
  }

  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.send({ type: 'ping', timestamp: Date.now() });
      }
    }, this.options.heartbeatInterval);
  }

  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  attemptReconnect() {
    if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {
      console.error('âŒ é‡è¿æ¬¡æ•°è¶…é™ï¼Œåœæ­¢é‡è¿');
      return;
    }

    this.isReconnecting = true;
    this.reconnectAttempts++;

    console.log(`ğŸ”„ å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);

    setTimeout(() => {
      this.connect();
    }, this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)); // æŒ‡æ•°é€€é¿
  }

  close() {
    this.isReconnecting = false;
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close();
    }
  }
}

// WebSocket æœåŠ¡å™¨ç«¯å®ç° (Node.js)
const WebSocket = require('ws');

class ChatServer {
  constructor(port = 8080) {
    this.wss = new WebSocket.Server({ port });
    this.rooms = new Map();
    this.clients = new Map();

    this.setupServer();
    console.log(`ğŸš€ WebSocket æœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£ ${port}`);
  }

  setupServer() {
    this.wss.on('connection', (ws, req) => {
      const clientId = this.generateClientId();
      console.log(`ğŸ‘¤ å®¢æˆ·ç«¯è¿æ¥: ${clientId}`);

      // å­˜å‚¨å®¢æˆ·ç«¯ä¿¡æ¯
      this.clients.set(ws, {
        id: clientId,
        ip: req.socket.remoteAddress,
        connectTime: new Date()
      });

      ws.on('message', (data) => {
        try {
          const message = JSON.parse(data);
          this.handleMessage(ws, message);
        } catch (error) {
          console.error('æ¶ˆæ¯è§£æé”™è¯¯:', error);
          this.sendError(ws, 'æ— æ•ˆçš„æ¶ˆæ¯æ ¼å¼');
        }
      });

      ws.on('close', () => {
        this.handleDisconnect(ws);
      });

      ws.on('error', (error) => {
        console.error('WebSocket é”™è¯¯:', error);
      });

      // å‘é€æ¬¢è¿æ¶ˆæ¯
      this.send(ws, {
        type: 'welcome',
        clientId: clientId,
        timestamp: Date.now()
      });
    });
  }

  handleMessage(ws, message) {
    const { type, ...payload } = message;

    switch (type) {
      case 'ping':
        this.send(ws, { type: 'pong', timestamp: Date.now() });
        break;

      case 'join-room':
        this.joinRoom(ws, payload.roomId);
        break;

      case 'leave-room':
        this.leaveRoom(ws, payload.roomId);
        break;

      case 'chat-message':
        this.broadcastMessage(ws, payload);
        break;

      default:
        console.log('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', type);
    }
  }

  joinRoom(ws, roomId) {
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }

    const room = this.rooms.get(roomId);
    room.add(ws);

    const client = this.clients.get(ws);
    client.currentRoom = roomId;

    // é€šçŸ¥æˆ¿é—´å†…å…¶ä»–äºº
    this.broadcastToRoom(roomId, {
      type: 'user-joined',
      clientId: client.id,
      roomId: roomId,
      timestamp: Date.now()
    }, ws);

    console.log(`ğŸ“¥ å®¢æˆ·ç«¯ ${client.id} åŠ å…¥æˆ¿é—´ ${roomId}`);
  }

  broadcastMessage(ws, payload) {
    const client = this.clients.get(ws);
    const { currentRoom } = client;

    if (currentRoom) {
      this.broadcastToRoom(currentRoom, {
        type: 'chat-message',
        clientId: client.id,
        message: payload.message,
        timestamp: Date.now()
      });
    }
  }

  broadcastToRoom(roomId, data, excludeWs = null) {
    const room = this.rooms.get(roomId);
    if (!room) return;

    room.forEach(ws => {
      if (ws !== excludeWs && ws.readyState === WebSocket.OPEN) {
        this.send(ws, data);
      }
    });
  }

  send(ws, data) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(data));
    }
  }

  sendError(ws, message) {
    this.send(ws, {
      type: 'error',
      message: message,
      timestamp: Date.now()
    });
  }

  generateClientId() {
    return Math.random().toString(36).substr(2, 9);
  }

  handleDisconnect(ws) {
    const client = this.clients.get(ws);
    if (client) {
      console.log(`ğŸ‘‹ å®¢æˆ·ç«¯æ–­å¼€: ${client.id}`);

      // ä»æˆ¿é—´ç§»é™¤
      if (client.currentRoom) {
        const room = this.rooms.get(client.currentRoom);
        if (room) {
          room.delete(ws);
          if (room.size === 0) {
            this.rooms.delete(client.currentRoom);
          }
        }
      }

      this.clients.delete(ws);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const chatClient = new AdvancedWebSocket('ws://localhost:8080');

chatClient.addEventListener('connected', () => {
  console.log('ğŸ‰ è¿æ¥æˆåŠŸ!');

  // åŠ å…¥èŠå¤©å®¤
  chatClient.send({
    type: 'join-room',
    roomId: 'general'
  });
});

chatClient.addEventListener('message', (event) => {
  const { type, ...data } = event.detail;

  switch (type) {
    case 'welcome':
      console.log(`ğŸ¯ å®¢æˆ·ç«¯ID: ${data.clientId}`);
      break;

    case 'chat-message':
      console.log(`ğŸ’¬ ${data.clientId}: ${data.message}`);
      break;

    case 'user-joined':
      console.log(`ğŸ‘¤ ${data.clientId} åŠ å…¥äº†æˆ¿é—´`);
      break;
  }
});

// å‘é€æ¶ˆæ¯ç¤ºä¾‹
function sendMessage(text) {
  chatClient.send({
    type: 'chat-message',
    message: text
  });
}
```

### ğŸ” DNS - åŸŸåè§£æç³»ç»Ÿ

DNS æ˜¯äº’è”ç½‘çš„"ç”µè¯ç°¿"ï¼Œå°†äººç±»å¯è¯»çš„åŸŸåè½¬æ¢ä¸ºæœºå™¨å¯ç†è§£çš„IPåœ°å€ï¼š

#### ğŸŒ DNS æŸ¥è¯¢è¿‡ç¨‹

```
DNS é€’å½’æŸ¥è¯¢è¿‡ç¨‹:
1. æµè§ˆå™¨ â”€â”€â†’ æœ¬åœ°DNSç¼“å­˜
2. æœ¬åœ°DNS â”€â”€â†’ æ ¹åŸŸåæœåŠ¡å™¨ (.)
3. æ ¹æœåŠ¡å™¨ â”€â”€â†’ é¡¶çº§åŸŸæœåŠ¡å™¨ (.com)
4. é¡¶çº§åŸŸæœåŠ¡å™¨ â”€â”€â†’ æƒå¨åŸŸåæœåŠ¡å™¨ (example.com)
5. æƒå¨æœåŠ¡å™¨ â”€â”€â†’ è¿”å›IPåœ°å€
6. é€çº§è¿”å› â”€â”€â†’ æµè§ˆå™¨è·å¾—IP

ç¤ºä¾‹: www.github.com æŸ¥è¯¢
. (æ ¹) â†’ .com â†’ github.com â†’ www.github.com â†’ 140.82.112.4
```

#### ğŸ› ï¸ DNS å·¥å…·å®ç°

```javascript
// DNS æŸ¥è¯¢å·¥å…·
const dns = require('dns').promises;

class DNSAnalyzer {
  constructor() {
    this.recordTypes = {
      A: 'åœ°å€è®°å½• (IPv4)',
      AAAA: 'åœ°å€è®°å½• (IPv6)',
      CNAME: 'åˆ«åè®°å½•',
      MX: 'é‚®ä»¶äº¤æ¢è®°å½•',
      NS: 'åŸŸåæœåŠ¡å™¨è®°å½•',
      TXT: 'æ–‡æœ¬è®°å½•',
      SOA: 'æˆæƒå¼€å§‹è®°å½•'
    };
  }

  async analyzeHost(hostname) {
    console.log(`ğŸ” åˆ†æåŸŸå: ${hostname}`);
    const results = {};

    // æŸ¥è¯¢å„ç§DNSè®°å½•
    for (const [type, description] of Object.entries(this.recordTypes)) {
      try {
        const records = await this.queryRecord(hostname, type);
        if (records && records.length > 0) {
          results[type] = { description, records };
        }
      } catch (error) {
        // æŸäº›è®°å½•ç±»å‹å¯èƒ½ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
        if (error.code !== 'ENOTFOUND' && error.code !== 'ENODATA') {
          console.warn(`${type} æŸ¥è¯¢è­¦å‘Š:`, error.message);
        }
      }
    }

    // æµ‹é‡è§£ææ—¶é—´
    results.performance = await this.measureResolutionTime(hostname);

    return results;
  }

  async queryRecord(hostname, type) {
    switch (type) {
      case 'A':
        return await dns.resolve4(hostname);
      case 'AAAA':
        return await dns.resolve6(hostname);
      case 'CNAME':
        return await dns.resolveCname(hostname);
      case 'MX':
        return await dns.resolveMx(hostname);
      case 'NS':
        return await dns.resolveNs(hostname);
      case 'TXT':
        return await dns.resolveTxt(hostname);
      case 'SOA':
        return await dns.resolveSoa(hostname);
      default:
        throw new Error(`ä¸æ”¯æŒçš„è®°å½•ç±»å‹: ${type}`);
    }
  }

  async measureResolutionTime(hostname, samples = 5) {
    const times = [];

    for (let i = 0; i < samples; i++) {
      const start = Date.now();
      try {
        await dns.resolve4(hostname);
        times.push(Date.now() - start);
      } catch (error) {
        // è§£æå¤±è´¥æ—¶ä¹Ÿè®°å½•æ—¶é—´
        times.push(Date.now() - start);
      }

      // é—´éš”100msé¿å…è¿‡äºé¢‘ç¹
      if (i < samples - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);

    return { avgTime, minTime, maxTime, samples: times };
  }

  formatResults(hostname, results) {
    console.log(`\nğŸ“Š ${hostname} DNSåˆ†ææŠ¥å‘Š:`);
    console.log('â•'.repeat(50));

    // DNSè®°å½•
    for (const [type, data] of Object.entries(results)) {
      if (type === 'performance') continue;

      console.log(`\n${type} - ${data.description}:`);
      data.records.forEach((record, index) => {
        if (typeof record === 'object') {
          console.log(`  ${index + 1}. ${JSON.stringify(record)}`);
        } else {
          console.log(`  ${index + 1}. ${record}`);
        }
      });
    }

    // æ€§èƒ½æ•°æ®
    if (results.performance) {
      const perf = results.performance;
      console.log(`\nâš¡ è§£ææ€§èƒ½:`);
      console.log(`  å¹³å‡æ—¶é—´: ${perf.avgTime.toFixed(2)}ms`);
      console.log(`  æœ€å¿«æ—¶é—´: ${perf.minTime}ms`);
      console.log(`  æœ€æ…¢æ—¶é—´: ${perf.maxTime}ms`);
    }
  }
}

// DNSç¼“å­˜å®ç°
class DNSCache {
  constructor(ttl = 300000) { // 5åˆ†é’ŸTTL
    this.cache = new Map();
    this.defaultTTL = ttl;
  }

  set(hostname, result, ttl = this.defaultTTL) {
    this.cache.set(hostname, {
      result,
      expires: Date.now() + ttl
    });
  }

  get(hostname) {
    const cached = this.cache.get(hostname);

    if (!cached) return null;

    if (Date.now() > cached.expires) {
      this.cache.delete(hostname);
      return null;
    }

    return cached.result;
  }

  clear() {
    this.cache.clear();
  }

  size() {
    return this.cache.size;
  }
}

// å¸¦ç¼“å­˜çš„DNSè§£æå™¨
class CachedDNSResolver {
  constructor() {
    this.cache = new DNSCache();
    this.stats = {
      hits: 0,
      misses: 0,
      errors: 0
    };
  }

  async resolve(hostname) {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(hostname);
    if (cached) {
      this.stats.hits++;
      console.log(`ğŸ’¾ ç¼“å­˜å‘½ä¸­: ${hostname}`);
      return cached;
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿›è¡ŒDNSæŸ¥è¯¢
    this.stats.misses++;
    console.log(`ğŸ” DNSæŸ¥è¯¢: ${hostname}`);

    try {
      const start = Date.now();
      const addresses = await dns.resolve4(hostname);
      const duration = Date.now() - start;

      const result = {
        hostname,
        addresses,
        queryTime: duration,
        timestamp: Date.now()
      };

      // å­˜å…¥ç¼“å­˜
      this.cache.set(hostname, result);

      return result;

    } catch (error) {
      this.stats.errors++;
      console.error(`âŒ DNSè§£æå¤±è´¥: ${hostname}`, error.message);
      throw error;
    }
  }

  getStats() {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? (this.stats.hits / total * 100).toFixed(2) : 0;

    return {
      ...this.stats,
      total,
      hitRate: `${hitRate}%`,
      cacheSize: this.cache.size()
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateDNS() {
  const analyzer = new DNSAnalyzer();
  const resolver = new CachedDNSResolver();

  // åˆ†æåŸŸåçš„å®Œæ•´DNSè®°å½•
  try {
    const results = await analyzer.analyzeHost('github.com');
    analyzer.formatResults('github.com', results);
  } catch (error) {
    console.error('DNSåˆ†æå¤±è´¥:', error);
  }

  // æµ‹è¯•ç¼“å­˜è§£æå™¨
  console.log('\nğŸ§ª æµ‹è¯•DNSç¼“å­˜è§£æå™¨:');
  const hosts = ['github.com', 'stackoverflow.com', 'github.com']; // github.comé‡å¤æµ‹è¯•ç¼“å­˜

  for (const host of hosts) {
    try {
      const result = await resolver.resolve(host);
      console.log(`âœ… ${host} â†’ ${result.addresses[0]} (${result.queryTime}ms)`);
    } catch (error) {
      console.error(`âŒ ${host} è§£æå¤±è´¥`);
    }
  }

  console.log('\nğŸ“Š ç¼“å­˜ç»Ÿè®¡:', resolver.getStats());
}

// è¿è¡Œæ¼”ç¤º
if (require.main === module) {
  demonstrateDNS().catch(console.error);
}
```

---

## ğŸš€ ä¼ è¾“å±‚åè®®è¯¦è§£

ä¼ è¾“å±‚è´Ÿè´£ç«¯åˆ°ç«¯çš„å¯é æ•°æ®ä¼ è¾“ï¼Œæ˜¯ç½‘ç»œé€šä¿¡çš„é‡è¦æ¢çº½ã€‚

### ğŸ”„ TCP - ä¼ è¾“æ§åˆ¶åè®®

TCP æä¾›å¯é çš„ã€é¢å‘è¿æ¥çš„æ•°æ®ä¼ è¾“æœåŠ¡ï¼Œæ˜¯äº’è”ç½‘æœ€é‡è¦çš„åè®®ä¹‹ä¸€ã€‚

#### ğŸ¤ TCP ä¸‰æ¬¡æ¡æ‰‹

```
å»ºç«‹è¿æ¥çš„ä¸‰æ¬¡æ¡æ‰‹:
å®¢æˆ·ç«¯                    æœåŠ¡å™¨
   â”‚                        â”‚
   â”œâ”€ 1. SYN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (è¯·æ±‚è¿æ¥, seq=x)
   â”‚â†â”€ 2. SYN-ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (ç¡®è®¤è¿æ¥, seq=y, ack=x+1)
   â”œâ”€ 3. ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (ç¡®è®¤å»ºç«‹, ack=y+1)
   â”‚                        â”‚
   â”œâ”€â”€â”€â”€ æ•°æ®ä¼ è¾“ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
```

ä¸ºä»€ä¹ˆéœ€è¦ä¸‰æ¬¡æ¡æ‰‹ï¼Ÿ
- âœ… **é˜²æ­¢é‡å¤è¿æ¥**ï¼šé¿å…æ—§çš„è¿æ¥è¯·æ±‚çªç„¶åˆ°è¾¾
- âœ… **åŒæ­¥åºåˆ—å·**ï¼šç¡®ä¿åŒæ–¹çš„åºåˆ—å·æ­£ç¡®åˆå§‹åŒ–
- âœ… **ç¡®è®¤åŒæ–¹èƒ½åŠ›**ï¼šéªŒè¯åŒæ–¹çš„å‘é€å’Œæ¥æ”¶èƒ½åŠ›

#### ğŸ‘‹ TCP å››æ¬¡æŒ¥æ‰‹

```
å…³é—­è¿æ¥çš„å››æ¬¡æŒ¥æ‰‹:
å®¢æˆ·ç«¯                    æœåŠ¡å™¨
   â”‚                        â”‚
   â”œâ”€ 1. FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (è¯·æ±‚å…³é—­, seq=x)
   â”‚â†â”€ 2. ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (ç¡®è®¤æ”¶åˆ°, ack=x+1)
   â”‚â†â”€ 3. FIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (æœåŠ¡å™¨å…³é—­, seq=y)
   â”œâ”€ 4. ACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ (æœ€ç»ˆç¡®è®¤, ack=y+1)
   â”‚                        â”‚
  ç­‰å¾…2MSLæ—¶é—´åå®Œå…¨å…³é—­
```

ä¸ºä»€ä¹ˆéœ€è¦å››æ¬¡æŒ¥æ‰‹ï¼Ÿ
- ğŸ“¡ **åŠå…³é—­çŠ¶æ€**ï¼šTCPæ”¯æŒå•å‘å…³é—­
- â³ **æ•°æ®å¤„ç†æ—¶é—´**ï¼šæœåŠ¡å™¨å¯èƒ½è¿˜æœ‰æ•°æ®éœ€è¦å‘é€
- ğŸ”’ **å¯é å…³é—­**ï¼šç¡®ä¿æ‰€æœ‰æ•°æ®éƒ½å·²ä¼ è¾“å®Œæˆ

#### ğŸ› ï¸ TCP å®è·µå®ç°

```javascript
// TCP æœåŠ¡å™¨å®ç°
const net = require('net');

class TCPServer {
  constructor(port, host = 'localhost') {
    this.port = port;
    this.host = host;
    this.clients = new Map();
    this.server = null;

    this.messageHandlers = new Map();
    this.setupDefaultHandlers();
  }

  setupDefaultHandlers() {
    // é»˜è®¤æ¶ˆæ¯å¤„ç†å™¨
    this.onMessage('ping', (client, data) => {
      this.send(client, { type: 'pong', timestamp: Date.now() });
    });

    this.onMessage('echo', (client, data) => {
      this.send(client, { type: 'echo', data: data.message });
    });
  }

  start() {
    return new Promise((resolve, reject) => {
      this.server = net.createServer((socket) => {
        this.handleConnection(socket);
      });

      this.server.listen(this.port, this.host, () => {
        console.log(`ğŸš€ TCPæœåŠ¡å™¨å¯åŠ¨åœ¨ ${this.host}:${this.port}`);
        resolve();
      });

      this.server.on('error', reject);
    });
  }

  handleConnection(socket) {
    const clientId = this.generateClientId();
    const clientInfo = {
      id: clientId,
      socket: socket,
      address: `${socket.remoteAddress}:${socket.remotePort}`,
      connectTime: new Date(),
      lastActivity: new Date()
    };

    this.clients.set(socket, clientInfo);
    console.log(`ğŸ‘¤ å®¢æˆ·ç«¯è¿æ¥: ${clientId} (${clientInfo.address})`);

    // å‘é€æ¬¢è¿æ¶ˆæ¯
    this.send(socket, {
      type: 'welcome',
      clientId: clientId,
      message: 'æ¬¢è¿è¿æ¥åˆ°TCPæœåŠ¡å™¨'
    });

    // è®¾ç½®socketé€‰é¡¹
    socket.setKeepAlive(true, 60000); // 60ç§’å¿ƒè·³
    socket.setTimeout(300000); // 5åˆ†é’Ÿè¶…æ—¶

    // äº‹ä»¶å¤„ç†
    socket.on('data', (data) => this.handleData(socket, data));
    socket.on('close', () => this.handleDisconnect(socket));
    socket.on('error', (error) => this.handleError(socket, error));
    socket.on('timeout', () => this.handleTimeout(socket));
  }

  handleData(socket, data) {
    const client = this.clients.get(socket);
    if (!client) return;

    client.lastActivity = new Date();

    try {
      // å¤„ç†å¯èƒ½çš„å¤šä¸ªJSONæ¶ˆæ¯ï¼ˆTCPæµçš„ç‰¹æ€§ï¼‰
      const messages = this.parseMessages(data.toString());

      messages.forEach(message => {
        console.log(`ğŸ“¨ ${client.id} å‘é€:`, message);

        if (message.type && this.messageHandlers.has(message.type)) {
          this.messageHandlers.get(message.type)(client, message);
        } else {
          console.warn(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`);
        }
      });

    } catch (error) {
      console.error('æ•°æ®å¤„ç†é”™è¯¯:', error);
      this.send(socket, {
        type: 'error',
        message: 'æ¶ˆæ¯æ ¼å¼æ— æ•ˆ'
      });
    }
  }

  parseMessages(data) {
    // å¤„ç†TCPæµå¯èƒ½åŒ…å«å¤šä¸ªJSONå¯¹è±¡çš„æƒ…å†µ
    const messages = [];
    const lines = data.split('\n').filter(line => line.trim());

    for (const line of lines) {
      try {
        const message = JSON.parse(line);
        messages.push(message);
      } catch (error) {
        console.warn('JSONè§£æå¤±è´¥:', line);
      }
    }

    return messages;
  }

  send(socket, data) {
    if (socket.destroyed) return false;

    const message = JSON.stringify(data) + '\n';

    return new Promise((resolve) => {
      socket.write(message, (error) => {
        if (error) {
          console.error('å‘é€å¤±è´¥:', error);
          resolve(false);
        } else {
          resolve(true);
        }
      });
    });
  }

  broadcast(data, excludeSocket = null) {
    let sent = 0;

    this.clients.forEach((client, socket) => {
      if (socket !== excludeSocket) {
        this.send(socket, data).then(success => {
          if (success) sent++;
        });
      }
    });

    console.log(`ğŸ“¡ å¹¿æ’­æ¶ˆæ¯ç»™ ${sent} ä¸ªå®¢æˆ·ç«¯`);
    return sent;
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  handleDisconnect(socket) {
    const client = this.clients.get(socket);
    if (client) {
      console.log(`ğŸ‘‹ å®¢æˆ·ç«¯æ–­å¼€: ${client.id}`);
      this.clients.delete(socket);
    }
  }

  handleError(socket, error) {
    const client = this.clients.get(socket);
    console.error(`âŒ å®¢æˆ·ç«¯é”™è¯¯ ${client?.id}:`, error.message);
  }

  handleTimeout(socket) {
    const client = this.clients.get(socket);
    console.log(`â° å®¢æˆ·ç«¯è¶…æ—¶: ${client?.id}`);
    socket.destroy();
  }

  generateClientId() {
    return Math.random().toString(36).substr(2, 9);
  }

  getStats() {
    return {
      totalClients: this.clients.size,
      clients: Array.from(this.clients.values()).map(client => ({
        id: client.id,
        address: client.address,
        connectTime: client.connectTime,
        lastActivity: client.lastActivity
      }))
    };
  }

  stop() {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          console.log('ğŸ›‘ TCPæœåŠ¡å™¨å·²å…³é—­');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}

// TCP å®¢æˆ·ç«¯å®ç°
class TCPClient {
  constructor() {
    this.socket = null;
    this.connected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;

    this.messageHandlers = new Map();
  }

  connect(host, port) {
    return new Promise((resolve, reject) => {
      this.socket = net.createConnection({ port, host });

      this.socket.on('connect', () => {
        console.log(`âœ… è¿æ¥åˆ°æœåŠ¡å™¨ ${host}:${port}`);
        this.connected = true;
        this.reconnectAttempts = 0;
        resolve();
      });

      this.socket.on('data', (data) => this.handleData(data));
      this.socket.on('close', () => this.handleDisconnect());
      this.socket.on('error', (error) => this.handleError(error, reject));

      this.socket.setTimeout(10000); // 10ç§’è¿æ¥è¶…æ—¶
    });
  }

  handleData(data) {
    try {
      const messages = this.parseMessages(data.toString());

      messages.forEach(message => {
        console.log('ğŸ“¨ æœåŠ¡å™¨æ¶ˆæ¯:', message);

        if (message.type && this.messageHandlers.has(message.type)) {
          this.messageHandlers.get(message.type)(message);
        }
      });

    } catch (error) {
      console.error('æ•°æ®å¤„ç†é”™è¯¯:', error);
    }
  }

  parseMessages(data) {
    const messages = [];
    const lines = data.split('\n').filter(line => line.trim());

    for (const line of lines) {
      try {
        const message = JSON.parse(line);
        messages.push(message);
      } catch (error) {
        console.warn('JSONè§£æå¤±è´¥:', line);
      }
    }

    return messages;
  }

  send(data) {
    if (!this.connected) {
      console.warn('âš ï¸ æœªè¿æ¥åˆ°æœåŠ¡å™¨');
      return false;
    }

    const message = JSON.stringify(data) + '\n';

    return new Promise((resolve) => {
      this.socket.write(message, (error) => {
        if (error) {
          console.error('å‘é€å¤±è´¥:', error);
          resolve(false);
        } else {
          console.log('ğŸ“¤ å‘é€æ¶ˆæ¯:', data);
          resolve(true);
        }
      });
    });
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  handleDisconnect() {
    console.log('ğŸ”Œ ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
    this.connected = false;
  }

  handleError(error, reject = null) {
    console.error('âŒ è¿æ¥é”™è¯¯:', error.message);
    if (reject) reject(error);
  }

  disconnect() {
    if (this.socket) {
      this.socket.end();
      this.socket = null;
      this.connected = false;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateTCP() {
  // å¯åŠ¨æœåŠ¡å™¨
  const server = new TCPServer(8888);

  // æ·»åŠ è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨
  server.onMessage('chat', (client, data) => {
    console.log(`ğŸ’¬ ${client.id}: ${data.message}`);
    // å¹¿æ’­ç»™å…¶ä»–å®¢æˆ·ç«¯
    server.broadcast({
      type: 'chat',
      from: client.id,
      message: data.message,
      timestamp: Date.now()
    }, client.socket);
  });

  await server.start();

  // åˆ›å»ºå®¢æˆ·ç«¯
  const client1 = new TCPClient();
  const client2 = new TCPClient();

  // è®¾ç½®å®¢æˆ·ç«¯æ¶ˆæ¯å¤„ç†
  client1.onMessage('welcome', (message) => {
    console.log(`ğŸ‰ å®¢æˆ·ç«¯1æ”¶åˆ°æ¬¢è¿: ${message.message}`);
  });

  client2.onMessage('chat', (message) => {
    console.log(`ğŸ’¬ å®¢æˆ·ç«¯2æ”¶åˆ°èŠå¤©: ${message.from} è¯´ "${message.message}"`);
  });

  try {
    // è¿æ¥å®¢æˆ·ç«¯
    await client1.connect('localhost', 8888);
    await client2.connect('localhost', 8888);

    // å‘é€æ¶ˆæ¯
    await client1.send({
      type: 'chat',
      message: 'Hello from client 1!'
    });

    await client2.send({
      type: 'ping'
    });

    // æ˜¾ç¤ºæœåŠ¡å™¨ç»Ÿè®¡
    setTimeout(() => {
      console.log('ğŸ“Š æœåŠ¡å™¨ç»Ÿè®¡:', server.getStats());
    }, 1000);

    // 5ç§’åæ¸…ç†
    setTimeout(() => {
      client1.disconnect();
      client2.disconnect();
      server.stop();
    }, 5000);

  } catch (error) {
    console.error('æ¼”ç¤ºå¤±è´¥:', error);
  }
}

// è¿è¡Œæ¼”ç¤º
if (require.main === module) {
  demonstrateTCP();
}
```

### âš¡ UDP - ç”¨æˆ·æ•°æ®æŠ¥åè®®

UDP æ˜¯æ— è¿æ¥çš„ä¼ è¾“åè®®ï¼Œæä¾›å¿«é€Ÿä½†ä¸å¯é çš„æ•°æ®ä¼ è¾“ï¼š

#### ğŸ“Š TCP vs UDP å¯¹æ¯”

| ç‰¹æ€§ | TCP | UDP |
|------|-----|-----|
| **è¿æ¥æ€§** | é¢å‘è¿æ¥ | æ— è¿æ¥ |
| **å¯é æ€§** | å¯é ä¼ è¾“ | ä¸ä¿è¯å¯é  |
| **é€Ÿåº¦** | ç›¸å¯¹è¾ƒæ…¢ | å¿«é€Ÿ |
| **å¼€é”€** | è¾ƒå¤§ | è¾ƒå° |
| **æµé‡æ§åˆ¶** | æœ‰ | æ—  |
| **æ‹¥å¡æ§åˆ¶** | æœ‰ | æ—  |
| **é€‚ç”¨åœºæ™¯** | Webã€é‚®ä»¶ã€æ–‡ä»¶ä¼ è¾“ | è§†é¢‘æµã€æ¸¸æˆã€DNS |

#### ğŸ› ï¸ UDP å®è·µå®ç°

```javascript
// UDP æœåŠ¡å™¨å®ç°
const dgram = require('dgram');

class UDPServer {
  constructor(port, host = 'localhost') {
    this.port = port;
    this.host = host;
    this.socket = dgram.createSocket('udp4');
    this.clients = new Map(); // è·Ÿè¸ªå®¢æˆ·ç«¯

    this.messageHandlers = new Map();
    this.setupDefaultHandlers();
    this.setupSocket();
  }

  setupDefaultHandlers() {
    this.onMessage('ping', (client, data) => {
      this.send(client.address, client.port, {
        type: 'pong',
        timestamp: Date.now(),
        originalTimestamp: data.timestamp
      });
    });

    this.onMessage('register', (client, data) => {
      client.username = data.username;
      console.log(`ğŸ‘¤ å®¢æˆ·ç«¯æ³¨å†Œ: ${data.username} (${client.address}:${client.port})`);
    });
  }

  setupSocket() {
    this.socket.on('message', (msg, rinfo) => {
      this.handleMessage(msg, rinfo);
    });

    this.socket.on('error', (err) => {
      console.error('âŒ UDPæœåŠ¡å™¨é”™è¯¯:', err);
    });

    this.socket.on('listening', () => {
      const address = this.socket.address();
      console.log(`ğŸš€ UDPæœåŠ¡å™¨å¯åŠ¨åœ¨ ${address.address}:${address.port}`);
    });
  }

  start() {
    return new Promise((resolve, reject) => {
      this.socket.bind({
        port: this.port,
        address: this.host
      }, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  handleMessage(msg, rinfo) {
    const clientKey = `${rinfo.address}:${rinfo.port}`;

    // æ›´æ–°å®¢æˆ·ç«¯ä¿¡æ¯
    if (!this.clients.has(clientKey)) {
      this.clients.set(clientKey, {
        address: rinfo.address,
        port: rinfo.port,
        firstSeen: new Date(),
        messageCount: 0
      });
    }

    const client = this.clients.get(clientKey);
    client.lastSeen = new Date();
    client.messageCount++;

    try {
      const data = JSON.parse(msg.toString());
      console.log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯ from ${clientKey}:`, data);

      if (data.type && this.messageHandlers.has(data.type)) {
        this.messageHandlers.get(data.type)(client, data);
      } else {
        console.warn(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${data.type}`);
      }

    } catch (error) {
      console.error('æ¶ˆæ¯è§£æé”™è¯¯:', error);
      this.send(rinfo.address, rinfo.port, {
        type: 'error',
        message: 'æ¶ˆæ¯æ ¼å¼æ— æ•ˆ'
      });
    }
  }

  send(address, port, data) {
    const message = Buffer.from(JSON.stringify(data));

    return new Promise((resolve) => {
      this.socket.send(message, port, address, (error) => {
        if (error) {
          console.error(`å‘é€å¤±è´¥ to ${address}:${port}:`, error);
          resolve(false);
        } else {
          console.log(`ğŸ“¤ å‘é€æ¶ˆæ¯ to ${address}:${port}:`, data);
          resolve(true);
        }
      });
    });
  }

  broadcast(data, excludeClient = null) {
    let sent = 0;

    this.clients.forEach((client, key) => {
      if (!excludeClient || key !== `${excludeClient.address}:${excludeClient.port}`) {
        this.send(client.address, client.port, data).then(success => {
          if (success) sent++;
        });
      }
    });

    console.log(`ğŸ“¡ å¹¿æ’­æ¶ˆæ¯ç»™ ${sent} ä¸ªå®¢æˆ·ç«¯`);
    return sent;
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  getStats() {
    return {
      totalClients: this.clients.size,
      clients: Array.from(this.clients.entries()).map(([key, client]) => ({
        address: key,
        username: client.username || 'unknown',
        firstSeen: client.firstSeen,
        lastSeen: client.lastSeen,
        messageCount: client.messageCount
      }))
    };
  }

  stop() {
    return new Promise((resolve) => {
      this.socket.close(() => {
        console.log('ğŸ›‘ UDPæœåŠ¡å™¨å·²å…³é—­');
        resolve();
      });
    });
  }
}

// UDP å®¢æˆ·ç«¯å®ç°
class UDPClient {
  constructor() {
    this.socket = dgram.createSocket('udp4');
    this.serverAddress = null;
    this.serverPort = null;
    this.connected = false;

    this.messageHandlers = new Map();
    this.setupSocket();
  }

  setupSocket() {
    this.socket.on('message', (msg, rinfo) => {
      this.handleMessage(msg, rinfo);
    });

    this.socket.on('error', (err) => {
      console.error('âŒ UDPå®¢æˆ·ç«¯é”™è¯¯:', err);
    });
  }

  connect(host, port) {
    this.serverAddress = host;
    this.serverPort = port;
    this.connected = true;

    console.log(`ğŸ”Œ è¿æ¥åˆ°UDPæœåŠ¡å™¨ ${host}:${port}`);

    // UDPæ˜¯æ— è¿æ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å‘é€ä¸€ä¸ªæ³¨å†Œæ¶ˆæ¯æ¥"è¿æ¥"
    return this.send({
      type: 'register',
      username: `client_${Date.now()}`,
      timestamp: Date.now()
    });
  }

  handleMessage(msg, rinfo) {
    try {
      const data = JSON.parse(msg.toString());
      console.log(`ğŸ“¨ æœåŠ¡å™¨æ¶ˆæ¯ from ${rinfo.address}:${rinfo.port}:`, data);

      if (data.type && this.messageHandlers.has(data.type)) {
        this.messageHandlers.get(data.type)(data, rinfo);
      }

    } catch (error) {
      console.error('æ¶ˆæ¯è§£æé”™è¯¯:', error);
    }
  }

  send(data) {
    if (!this.connected) {
      console.warn('âš ï¸ æœªè¿æ¥åˆ°æœåŠ¡å™¨');
      return Promise.resolve(false);
    }

    const message = Buffer.from(JSON.stringify(data));

    return new Promise((resolve) => {
      this.socket.send(message, this.serverPort, this.serverAddress, (error) => {
        if (error) {
          console.error('å‘é€å¤±è´¥:', error);
          resolve(false);
        } else {
          console.log('ğŸ“¤ å‘é€æ¶ˆæ¯:', data);
          resolve(true);
        }
      });
    });
  }

  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }

  disconnect() {
    this.connected = false;
    this.socket.close();
    console.log('ğŸ”Œ æ–­å¼€UDPè¿æ¥');
  }
}

// UDP æ€§èƒ½æµ‹è¯•å·¥å…·
class UDPBenchmark {
  constructor(serverHost = 'localhost', serverPort = 9999) {
    this.serverHost = serverHost;
    this.serverPort = serverPort;
    this.results = [];
  }

  async measureLatency(samples = 100) {
    const client = new UDPClient();
    const latencies = [];

    client.onMessage('pong', (data) => {
      const latency = Date.now() - data.originalTimestamp;
      latencies.push(latency);
    });

    await client.connect(this.serverHost, this.serverPort);

    console.log(`ğŸ§ª å¼€å§‹å»¶è¿Ÿæµ‹è¯•ï¼Œæ ·æœ¬æ•°: ${samples}`);

    for (let i = 0; i < samples; i++) {
      await client.send({
        type: 'ping',
        timestamp: Date.now(),
        sequence: i
      });

      // ç­‰å¾…10msé¿å…è¿‡äºé¢‘ç¹
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    // ç­‰å¾…æ‰€æœ‰å“åº”
    await new Promise(resolve => setTimeout(resolve, 1000));
    client.disconnect();

    if (latencies.length > 0) {
      const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
      const min = Math.min(...latencies);
      const max = Math.max(...latencies);
      const median = latencies.sort((a, b) => a - b)[Math.floor(latencies.length / 2)];

      const result = {
        samples: latencies.length,
        average: avg.toFixed(2),
        median: median,
        min: min,
        max: max,
        lossRate: ((samples - latencies.length) / samples * 100).toFixed(2)
      };

      console.log('ğŸ“Š å»¶è¿Ÿæµ‹è¯•ç»“æœ:');
      console.log(`  æ ·æœ¬æ•°: ${result.samples}/${samples}`);
      console.log(`  å¹³å‡å»¶è¿Ÿ: ${result.average}ms`);
      console.log(`  ä¸­ä½æ•°å»¶è¿Ÿ: ${result.median}ms`);
      console.log(`  æœ€å°å»¶è¿Ÿ: ${result.min}ms`);
      console.log(`  æœ€å¤§å»¶è¿Ÿ: ${result.max}ms`);
      console.log(`  ä¸¢åŒ…ç‡: ${result.lossRate}%`);

      return result;
    } else {
      console.error('âŒ æ²¡æœ‰æ”¶åˆ°ä»»ä½•å“åº”');
      return null;
    }
  }

  async measureThroughput(duration = 10000, packetSize = 1024) {
    const client = new UDPClient();
    let packetsSent = 0;
    let packetsReceived = 0;
    let bytesSent = 0;
    let bytesReceived = 0;

    client.onMessage('echo', (data) => {
      packetsReceived++;
      bytesReceived += JSON.stringify(data).length;
    });

    await client.connect(this.serverHost, this.serverPort);

    console.log(`ğŸ§ª å¼€å§‹ååé‡æµ‹è¯•ï¼ŒæŒç»­æ—¶é—´: ${duration}msï¼ŒåŒ…å¤§å°: ${packetSize}å­—èŠ‚`);

    const startTime = Date.now();
    const endTime = startTime + duration;

    // ç”Ÿæˆæµ‹è¯•æ•°æ®
    const testData = 'x'.repeat(packetSize - 100); // é¢„ç•™JSONæ ¼å¼ç©ºé—´

    while (Date.now() < endTime) {
      await client.send({
        type: 'echo',
        data: testData,
        timestamp: Date.now(),
        sequence: packetsSent
      });

      packetsSent++;
      bytesSent += JSON.stringify({ type: 'echo', data: testData }).length;

      // æ§åˆ¶å‘é€é¢‘ç‡ï¼Œé¿å…è¿‡è½½
      if (packetsSent % 100 === 0) {
        await new Promise(resolve => setTimeout(resolve, 1));
      }
    }

    // ç­‰å¾…å‰©ä½™å“åº”
    await new Promise(resolve => setTimeout(resolve, 1000));
    client.disconnect();

    const actualDuration = Date.now() - startTime;
    const sendThroughput = (bytesSent / 1024 / 1024) / (actualDuration / 1000); // MB/s
    const receiveThroughput = (bytesReceived / 1024 / 1024) / (actualDuration / 1000); // MB/s

    const result = {
      duration: actualDuration,
      packetsSent,
      packetsReceived,
      bytesSent,
      bytesReceived,
      sendThroughput: sendThroughput.toFixed(2),
      receiveThroughput: receiveThroughput.toFixed(2),
      lossRate: ((packetsSent - packetsReceived) / packetsSent * 100).toFixed(2)
    };

    console.log('ğŸ“Š ååé‡æµ‹è¯•ç»“æœ:');
    console.log(`  æµ‹è¯•æ—¶é•¿: ${result.duration}ms`);
    console.log(`  å‘é€åŒ…æ•°: ${result.packetsSent}`);
    console.log(`  æ¥æ”¶åŒ…æ•°: ${result.packetsReceived}`);
    console.log(`  å‘é€ååé‡: ${result.sendThroughput} MB/s`);
    console.log(`  æ¥æ”¶ååé‡: ${result.receiveThroughput} MB/s`);
    console.log(`  ä¸¢åŒ…ç‡: ${result.lossRate}%`);

    return result;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateUDP() {
  // å¯åŠ¨æœåŠ¡å™¨
  const server = new UDPServer(9999);

  // æ·»åŠ echoå¤„ç†å™¨ç”¨äºæ€§èƒ½æµ‹è¯•
  server.onMessage('echo', (client, data) => {
    server.send(client.address, client.port, {
      type: 'echo',
      data: data.data,
      originalTimestamp: data.timestamp,
      serverTimestamp: Date.now()
    });
  });

  await server.start();

  // ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨
  await new Promise(resolve => setTimeout(resolve, 100));

  // åˆ›å»ºå®¢æˆ·ç«¯
  const client1 = new UDPClient();
  const client2 = new UDPClient();

  try {
    await client1.connect('localhost', 9999);
    await client2.connect('localhost', 9999);

    // å‘é€ä¸€äº›æµ‹è¯•æ¶ˆæ¯
    await client1.send({
      type: 'ping',
      timestamp: Date.now()
    });

    // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    setTimeout(() => {
      console.log('ğŸ“Š æœåŠ¡å™¨ç»Ÿè®¡:', server.getStats());
    }, 1000);

    // è¿›è¡Œæ€§èƒ½æµ‹è¯•
    setTimeout(async () => {
      const benchmark = new UDPBenchmark('localhost', 9999);

      await benchmark.measureLatency(50);
      await benchmark.measureThroughput(5000, 512);

      // æ¸…ç†
      client1.disconnect();
      client2.disconnect();
      server.stop();
    }, 2000);

  } catch (error) {
    console.error('æ¼”ç¤ºå¤±è´¥:', error);
  }
}

// è¿è¡Œæ¼”ç¤º
if (require.main === module) {
  demonstrateUDP();
}
```

### ğŸš€ QUIC - æ–°ä¸€ä»£ä¼ è¾“åè®®

QUIC (Quick UDP Internet Connections) æ˜¯Googleå¼€å‘çš„åŸºäºUDPçš„æ–°åè®®ï¼ŒHTTP/3çš„åŸºç¡€ï¼š

#### ğŸ’¡ QUIC çš„ä¼˜åŠ¿

```
ä¼ ç»Ÿ HTTPS (HTTP/2 over TLS over TCP):
åº”ç”¨å±‚     â”‚ HTTP/2
å®‰å…¨å±‚     â”‚ TLS 1.3
ä¼ è¾“å±‚     â”‚ TCP
ç½‘ç»œå±‚     â”‚ IP

ç°ä»£ HTTPS (HTTP/3 over QUIC):
åº”ç”¨å±‚     â”‚ HTTP/3
ä¼ è¾“+å®‰å…¨å±‚ â”‚ QUIC (é›†æˆåŠ å¯†)
ç½‘ç»œå±‚     â”‚ UDP + IP
```

**QUIC æ ¸å¿ƒç‰¹æ€§**ï¼š
- âœ… **0-RTTè¿æ¥**ï¼šç¼“å­˜æ¡æ‰‹ä¿¡æ¯ï¼Œå®ç°é›¶å¾€è¿”è¿æ¥
- âœ… **å¤šè·¯å¤ç”¨æ— é˜»å¡**ï¼šé¿å…TCPçš„é˜Ÿå¤´é˜»å¡é—®é¢˜
- âœ… **å†…ç½®åŠ å¯†**ï¼šé»˜è®¤ç«¯åˆ°ç«¯åŠ å¯†
- âœ… **è¿æ¥è¿ç§»**ï¼šæ”¯æŒIPåœ°å€å˜åŒ–ï¼ˆWiFiåˆ‡æ¢åˆ°4Gï¼‰
- âœ… **æ‹¥å¡æ§åˆ¶**ï¼šæ”¹è¿›çš„æ‹¥å¡æ§åˆ¶ç®—æ³•

---

## ğŸŒ ç½‘ç»œå±‚åè®®è¯¦è§£

ç½‘ç»œå±‚è´Ÿè´£è·¨ç½‘ç»œçš„æ•°æ®è·¯ç”±ï¼Œæ˜¯å®ç°å…¨çƒäº’è”çš„å…³é”®ã€‚

### ğŸ¯ IPåè®® - ç½‘ç»œå±‚æ ¸å¿ƒ

IP (Internet Protocol) æ˜¯äº’è”ç½‘çš„åŸºç¡€åè®®ï¼Œè´Ÿè´£æ•°æ®åŒ…çš„è·¯ç”±å’Œä¼ é€’ã€‚

#### ğŸ“Š IPv4 vs IPv6 å¯¹æ¯”

| ç‰¹æ€§ | IPv4 | IPv6 |
|------|------|------|
| **åœ°å€é•¿åº¦** | 32ä½ (4å­—èŠ‚) | 128ä½ (16å­—èŠ‚) |
| **åœ°å€æ•°é‡** | çº¦43äº¿ | 3.4Ã—10Â³â¸ |
| **åœ°å€è¡¨ç¤º** | 192.168.1.1 | 2001:db8::1 |
| **åˆ†ç‰‡** | è·¯ç”±å™¨åˆ†ç‰‡ | ä»…æºç«¯åˆ†ç‰‡ |
| **å¤´éƒ¨å¤§å°** | 20-60å­—èŠ‚ | 40å­—èŠ‚å›ºå®š |
| **é…ç½®** | æ‰‹åŠ¨/DHCP | è‡ªåŠ¨é…ç½® |

#### ğŸ” IPåœ°å€åˆ†ç±»ä¸å­ç½‘åˆ’åˆ†

```javascript
// IP åœ°å€å·¥å…·ç±»
class IPAddressCalculator {
  constructor() {
    this.ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    this.ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  }

  // IPv4 åœ°å€åˆ†æ
  analyzeIPv4(ip, cidr = null) {
    if (!this.isValidIPv4(ip)) {
      throw new Error('æ— æ•ˆçš„IPv4åœ°å€');
    }

    const octets = ip.split('.').map(Number);
    const binaryIP = this.ipToBinary(octets);

    let analysis = {
      ip: ip,
      octets: octets,
      binary: binaryIP,
      class: this.getIPClass(octets[0]),
      isPrivate: this.isPrivateIP(octets),
      isLoopback: this.isLoopback(octets),
      isMulticast: this.isMulticast(octets[0])
    };

    if (cidr) {
      const subnetInfo = this.calculateSubnet(ip, cidr);
      analysis.subnet = subnetInfo;
    }

    return analysis;
  }

  isValidIPv4(ip) {
    const match = ip.match(this.ipv4Regex);
    if (!match) return false;

    return match.slice(1).every(octet => {
      const num = parseInt(octet);
      return num >= 0 && num <= 255;
    });
  }

  ipToBinary(octets) {
    return octets.map(octet =>
      octet.toString(2).padStart(8, '0')
    ).join('.');
  }

  getIPClass(firstOctet) {
    if (firstOctet >= 1 && firstOctet <= 126) return 'A';
    if (firstOctet >= 128 && firstOctet <= 191) return 'B';
    if (firstOctet >= 192 && firstOctet <= 223) return 'C';
    if (firstOctet >= 224 && firstOctet <= 239) return 'D (ç»„æ’­)';
    if (firstOctet >= 240 && firstOctet <= 255) return 'E (å®éªŒ)';
    return 'æœªçŸ¥';
  }

  isPrivateIP(octets) {
    const [a, b] = octets;

    // 10.0.0.0/8
    if (a === 10) return true;

    // 172.16.0.0/12
    if (a === 172 && b >= 16 && b <= 31) return true;

    // 192.168.0.0/16
    if (a === 192 && b === 168) return true;

    return false;
  }

  isLoopback(octets) {
    return octets[0] === 127;
  }

  isMulticast(firstOctet) {
    return firstOctet >= 224 && firstOctet <= 239;
  }

  calculateSubnet(ip, cidr) {
    const octets = ip.split('.').map(Number);
    const ipInt = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3];

    // å­ç½‘æ©ç è®¡ç®—
    const subnetMask = (0xFFFFFFFF << (32 - cidr)) >>> 0;
    const subnetMaskOctets = [
      (subnetMask >>> 24) & 0xFF,
      (subnetMask >>> 16) & 0xFF,
      (subnetMask >>> 8) & 0xFF,
      subnetMask & 0xFF
    ];

    // ç½‘ç»œåœ°å€
    const networkInt = (ipInt & subnetMask) >>> 0;
    const networkOctets = [
      (networkInt >>> 24) & 0xFF,
      (networkInt >>> 16) & 0xFF,
      (networkInt >>> 8) & 0xFF,
      networkInt & 0xFF
    ];

    // å¹¿æ’­åœ°å€
    const broadcastInt = (networkInt | (0xFFFFFFFF >>> cidr)) >>> 0;
    const broadcastOctets = [
      (broadcastInt >>> 24) & 0xFF,
      (broadcastInt >>> 16) & 0xFF,
      (broadcastInt >>> 8) & 0xFF,
      broadcastInt & 0xFF
    ];

    // å¯ç”¨ä¸»æœºæ•°
    const hostBits = 32 - cidr;
    const totalHosts = Math.pow(2, hostBits);
    const usableHosts = totalHosts - 2; // å‡å»ç½‘ç»œåœ°å€å’Œå¹¿æ’­åœ°å€

    return {
      cidr: `/${cidr}`,
      subnetMask: subnetMaskOctets.join('.'),
      subnetMaskBinary: this.ipToBinary(subnetMaskOctets),
      network: networkOctets.join('.'),
      broadcast: broadcastOctets.join('.'),
      firstHost: this.addToIP(networkOctets, 1),
      lastHost: this.addToIP(broadcastOctets, -1),
      totalHosts: totalHosts,
      usableHosts: usableHosts > 0 ? usableHosts : 0
    };
  }

  addToIP(octets, value) {
    let ipInt = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3];
    ipInt += value;

    return [
      (ipInt >>> 24) & 0xFF,
      (ipInt >>> 16) & 0xFF,
      (ipInt >>> 8) & 0xFF,
      ipInt & 0xFF
    ].join('.');
  }

  // IPv6 åœ°å€åˆ†æ
  analyzeIPv6(ip) {
    const expanded = this.expandIPv6(ip);
    const compressed = this.compressIPv6(expanded);

    return {
      original: ip,
      expanded: expanded,
      compressed: compressed,
      type: this.getIPv6Type(expanded),
      isValid: this.isValidIPv6(ip)
    };
  }

  expandIPv6(ip) {
    // å¤„ç† :: ç®€å†™
    if (ip.includes('::')) {
      const parts = ip.split('::');
      const leftParts = parts[0] ? parts[0].split(':') : [];
      const rightParts = parts[1] ? parts[1].split(':') : [];

      const missingGroups = 8 - leftParts.length - rightParts.length;
      const middleParts = new Array(missingGroups).fill('0000');

      const allParts = [...leftParts, ...middleParts, ...rightParts];
      ip = allParts.join(':');
    }

    return ip.split(':').map(group =>
      group.padStart(4, '0')
    ).join(':');
  }

  compressIPv6(ip) {
    // ç§»é™¤å‰å¯¼é›¶
    let compressed = ip.split(':').map(group =>
      group.replace(/^0+/, '') || '0'
    ).join(':');

    // å¯»æ‰¾æœ€é•¿çš„è¿ç»­0åºåˆ—å¹¶æ›¿æ¢ä¸º::
    const zeroGroups = compressed.match(/(^|:)(0:)*0(:|$)/g);
    if (zeroGroups) {
      const longest = zeroGroups.reduce((a, b) => a.length > b.length ? a : b);
      compressed = compressed.replace(longest, '::');
    }

    return compressed;
  }

  getIPv6Type(ip) {
    if (ip.startsWith('::1')) return 'å›ç¯åœ°å€';
    if (ip.startsWith('fe80:')) return 'é“¾è·¯æœ¬åœ°åœ°å€';
    if (ip.startsWith('fc00:') || ip.startsWith('fd00:')) return 'å”¯ä¸€æœ¬åœ°åœ°å€';
    if (ip.startsWith('2001:db8:')) return 'æ–‡æ¡£ç”¨åœ°å€';
    if (ip.match(/^2[0-3]/)) return 'å…¨å±€å•æ’­åœ°å€';
    if (ip.startsWith('ff')) return 'ç»„æ’­åœ°å€';
    return 'æœªçŸ¥ç±»å‹';
  }

  isValidIPv6(ip) {
    try {
      const expanded = this.expandIPv6(ip);
      return this.ipv6Regex.test(expanded) || ip === '::';
    } catch {
      return false;
    }
  }
}

// è·¯ç”±è¡¨åˆ†æå·¥å…·
class RouteAnalyzer {
  constructor() {
    this.routeTable = [];
  }

  addRoute(network, mask, gateway, interface_, metric = 1) {
    this.routeTable.push({
      network,
      mask,
      gateway,
      interface: interface_,
      metric,
      cidr: this.maskToCIDR(mask)
    });
  }

  maskToCIDR(mask) {
    const octets = mask.split('.').map(Number);
    let cidr = 0;

    for (const octet of octets) {
      cidr += (octet.toString(2).match(/1/g) || []).length;
    }

    return cidr;
  }

  findRoute(destIP) {
    const calc = new IPAddressCalculator();
    const matches = [];

    for (const route of this.routeTable) {
      if (this.isInSubnet(destIP, route.network, route.cidr)) {
        matches.push({
          ...route,
          specificity: route.cidr // CIDRè¶Šå¤§ï¼Œè·¯ç”±è¶Šå…·ä½“
        });
      }
    }

    // æŒ‰å…·ä½“åº¦æ’åºï¼ˆæœ€é•¿åŒ¹é…ï¼‰
    matches.sort((a, b) => b.specificity - a.specificity);

    return matches.length > 0 ? matches[0] : null;
  }

  isInSubnet(ip, network, cidr) {
    const calc = new IPAddressCalculator();

    try {
      const ipOctets = ip.split('.').map(Number);
      const netOctets = network.split('.').map(Number);

      const ipInt = (ipOctets[0] << 24) + (ipOctets[1] << 16) +
                   (ipOctets[2] << 8) + ipOctets[3];
      const netInt = (netOctets[0] << 24) + (netOctets[1] << 16) +
                    (netOctets[2] << 8) + netOctets[3];

      const mask = (0xFFFFFFFF << (32 - cidr)) >>> 0;

      return ((ipInt & mask) >>> 0) === ((netInt & mask) >>> 0);
    } catch {
      return false;
    }
  }

  displayRouteTable() {
    console.log('\nğŸ“‹ è·¯ç”±è¡¨:');
    console.log('ç½‘ç»œåœ°å€'.padEnd(18) + 'CIDR'.padEnd(6) + 'ç½‘å…³'.padEnd(16) + 'æ¥å£'.padEnd(12) + 'è·³æ•°');
    console.log('-'.repeat(70));

    this.routeTable.forEach(route => {
      console.log(
        route.network.padEnd(18) +
        `/${route.cidr}`.padEnd(6) +
        route.gateway.padEnd(16) +
        route.interface.padEnd(12) +
        route.metric
      );
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function demonstrateIPAnalysis() {
  const calc = new IPAddressCalculator();

  console.log('ğŸ” IPv4 åœ°å€åˆ†æç¤ºä¾‹:');

  const testIPs = [
    { ip: '192.168.1.100', cidr: 24 },
    { ip: '10.0.0.50', cidr: 8 },
    { ip: '172.16.5.10', cidr: 16 },
    { ip: '8.8.8.8', cidr: null }
  ];

  testIPs.forEach(({ ip, cidr }) => {
    console.log(`\nğŸ“Š åˆ†æ ${ip}${cidr ? '/' + cidr : ''}:`);

    const analysis = calc.analyzeIPv4(ip, cidr);

    console.log(`  IPåœ°å€: ${analysis.ip}`);
    console.log(`  äºŒè¿›åˆ¶: ${analysis.binary}`);
    console.log(`  åœ°å€ç±»å‹: Class ${analysis.class}`);
    console.log(`  ç§æœ‰åœ°å€: ${analysis.isPrivate ? 'æ˜¯' : 'å¦'}`);
    console.log(`  å›ç¯åœ°å€: ${analysis.isLoopback ? 'æ˜¯' : 'å¦'}`);

    if (analysis.subnet) {
      const subnet = analysis.subnet;
      console.log(`  å­ç½‘æ©ç : ${subnet.subnetMask}`);
      console.log(`  ç½‘ç»œåœ°å€: ${subnet.network}`);
      console.log(`  å¹¿æ’­åœ°å€: ${subnet.broadcast}`);
      console.log(`  ä¸»æœºèŒƒå›´: ${subnet.firstHost} - ${subnet.lastHost}`);
      console.log(`  å¯ç”¨ä¸»æœº: ${subnet.usableHosts}`);
    }
  });

  // IPv6 ç¤ºä¾‹
  console.log('\nğŸ” IPv6 åœ°å€åˆ†æç¤ºä¾‹:');

  const ipv6Addresses = [
    '2001:db8:85a3::8a2e:370:7334',
    'fe80::1%lo0',
    '::1',
    '2001:db8::1'
  ];

  ipv6Addresses.forEach(ip => {
    try {
      const analysis = calc.analyzeIPv6(ip.split('%')[0]); // ç§»é™¤æ¥å£æ ‡è¯†ç¬¦
      console.log(`\nğŸ“Š ${ip}:`);
      console.log(`  å®Œæ•´æ ¼å¼: ${analysis.expanded}`);
      console.log(`  å‹ç¼©æ ¼å¼: ${analysis.compressed}`);
      console.log(`  åœ°å€ç±»å‹: ${analysis.type}`);
    } catch (error) {
      console.log(`\nâŒ ${ip}: åˆ†æå¤±è´¥`);
    }
  });

  // è·¯ç”±è¡¨ç¤ºä¾‹
  console.log('\nğŸ›£ï¸ è·¯ç”±è¡¨åˆ†æç¤ºä¾‹:');

  const routeAnalyzer = new RouteAnalyzer();

  // æ·»åŠ è·¯ç”±æ¡ç›®
  routeAnalyzer.addRoute('0.0.0.0', '0.0.0.0', '192.168.1.1', 'eth0', 1); // é»˜è®¤è·¯ç”±
  routeAnalyzer.addRoute('192.168.1.0', '255.255.255.0', '0.0.0.0', 'eth0', 0); // æœ¬åœ°ç½‘ç»œ
  routeAnalyzer.addRoute('10.0.0.0', '255.0.0.0', '192.168.1.254', 'eth0', 2); // å…¬å¸ç½‘ç»œ
  routeAnalyzer.addRoute('172.16.0.0', '255.240.0.0', '192.168.1.254', 'eth0', 2);

  routeAnalyzer.displayRouteTable();

  // æµ‹è¯•è·¯ç”±æŸ¥æ‰¾
  const testDestinations = ['192.168.1.50', '10.5.5.5', '8.8.8.8', '172.20.1.1'];

  console.log('\nğŸ¯ è·¯ç”±æŸ¥æ‰¾æµ‹è¯•:');
  testDestinations.forEach(dest => {
    const route = routeAnalyzer.findRoute(dest);
    if (route) {
      console.log(`  ${dest} â†’ ç½‘å…³: ${route.gateway}, æ¥å£: ${route.interface}`);
    } else {
      console.log(`  ${dest} â†’ æ— åŒ¹é…è·¯ç”±`);
    }
  });
}

// è¿è¡ŒIPåˆ†æç¤ºä¾‹
if (require.main === module) {
  demonstrateIPAnalysis();
}
```

### ğŸ“¡ ICMP - Internetæ§åˆ¶æ¶ˆæ¯åè®®

ICMP åè®®ç”¨äºåœ¨ç½‘ç»œä¸­ä¼ é€’æ§åˆ¶å’Œé”™è¯¯ä¿¡æ¯ï¼Œæ˜¯ç½‘ç»œè¯Šæ–­çš„é‡è¦å·¥å…·ã€‚

#### ğŸ” ICMP æ¶ˆæ¯ç±»å‹

```javascript
// ICMP åˆ†æå’Œæµ‹è¯•å·¥å…·
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

class ICMPAnalyzer {
  constructor() {
    this.messageTypes = {
      0: 'Echo Reply (Pingå›å¤)',
      3: 'Destination Unreachable (ç›®æ ‡ä¸å¯è¾¾)',
      4: 'Source Quench (æºæŠ‘åˆ¶)',
      5: 'Redirect (é‡å®šå‘)',
      8: 'Echo Request (Pingè¯·æ±‚)',
      11: 'Time Exceeded (è¶…æ—¶)',
      12: 'Parameter Problem (å‚æ•°é”™è¯¯)',
      13: 'Timestamp Request (æ—¶é—´æˆ³è¯·æ±‚)',
      14: 'Timestamp Reply (æ—¶é—´æˆ³å›å¤)'
    };

    this.unreachableCodes = {
      0: 'ç½‘ç»œä¸å¯è¾¾',
      1: 'ä¸»æœºä¸å¯è¾¾',
      2: 'åè®®ä¸å¯è¾¾',
      3: 'ç«¯å£ä¸å¯è¾¾',
      4: 'éœ€è¦åˆ†ç‰‡ä½†è®¾ç½®äº†DFæ ‡å¿—',
      5: 'æºè·¯ç”±å¤±è´¥'
    };
  }

  async ping(host, count = 4, timeout = 5000) {
    console.log(`ğŸ“ Ping ${host} (${count} æ¬¡):`);

    const results = [];
    const startTime = Date.now();

    try {
      // æ„é€ pingå‘½ä»¤
      const pingCmd = process.platform === 'win32'
        ? `ping -n ${count} ${host}`
        : `ping -c ${count} -W ${timeout / 1000} ${host}`;

      const { stdout, stderr } = await execAsync(pingCmd);

      // è§£æpingç»“æœ
      const lines = stdout.split('\n');

      for (const line of lines) {
        const timeMatch = line.match(/time[<=](\d+\.?\d*)/i);
        const seqMatch = line.match(/icmp_seq=(\d+)/i) || line.match(/åºåˆ—å·?=(\d+)/i);

        if (timeMatch && seqMatch) {
          results.push({
            sequence: parseInt(seqMatch[1]),
            time: parseFloat(timeMatch[1]),
            raw: line.trim()
          });
          console.log(`  ${line.trim()}`);
        }
      }

      // ç»Ÿè®¡ä¿¡æ¯
      if (results.length > 0) {
        const times = results.map(r => r.time);
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const lossRate = ((count - results.length) / count * 100);

        console.log(`\nğŸ“Š Ping ç»Ÿè®¡:`);
        console.log(`  å‘é€: ${count}, æ¥æ”¶: ${results.length}, ä¸¢å¤±: ${count - results.length} (${lossRate.toFixed(1)}%)`);
        console.log(`  å¾€è¿”æ—¶é—´: æœ€å°=${minTime}ms, æœ€å¤§=${maxTime}ms, å¹³å‡=${avgTime.toFixed(2)}ms`);

        return {
          host,
          count,
          received: results.length,
          lost: count - results.length,
          lossRate: lossRate.toFixed(1),
          minTime,
          maxTime,
          avgTime: avgTime.toFixed(2),
          results
        };
      }

    } catch (error) {
      console.error(`âŒ Ping å¤±è´¥: ${error.message}`);
      return null;
    }
  }

  async traceroute(host, maxHops = 30) {
    console.log(`ğŸ›£ï¸ è¿½è¸ªåˆ° ${host} çš„è·¯ç”±:`);

    try {
      const traceCmd = process.platform === 'win32'
        ? `tracert -h ${maxHops} ${host}`
        : `traceroute -m ${maxHops} ${host}`;

      const { stdout } = await execAsync(traceCmd);
      const lines = stdout.split('\n').filter(line => line.trim());

      const hops = [];

      for (const line of lines) {
        // è§£æè·Ÿè¸ªè·¯ç”±è¾“å‡º
        const hopMatch = line.match(/^\s*(\d+)\s+(.+)/);
        if (hopMatch) {
          const hopNum = parseInt(hopMatch[1]);
          const hopInfo = hopMatch[2];

          // æå–IPåœ°å€å’Œæ—¶é—´
          const ipMatch = hopInfo.match(/(\d+\.\d+\.\d+\.\d+)/);
          const timeMatches = hopInfo.match(/(\d+\.?\d*)\s*ms/g);

          if (ipMatch) {
            const times = timeMatches ? timeMatches.map(t => parseFloat(t)) : [];
            const avgTime = times.length > 0 ? times.reduce((a, b) => a + b, 0) / times.length : null;

            hops.push({
              hop: hopNum,
              ip: ipMatch[1],
              times: times,
              avgTime: avgTime ? avgTime.toFixed(2) : 'timeout',
              raw: line.trim()
            });

            console.log(`  ${hopNum.toString().padStart(2, ' ')}. ${ipMatch[1].padEnd(15, ' ')} ${avgTime ? avgTime.toFixed(2) + 'ms' : 'timeout'}`);
          }
        }
      }

      return {
        host,
        maxHops,
        totalHops: hops.length,
        hops
      };

    } catch (error) {
      console.error(`âŒ Traceroute å¤±è´¥: ${error.message}`);
      return null;
    }
  }

  async performNetworkDiagnosis(host) {
    console.log(`ğŸ”§ ç½‘ç»œè¯Šæ–­: ${host}`);
    console.log('='.repeat(50));

    const diagnosis = {
      host: host,
      timestamp: new Date().toISOString(),
      tests: {}
    };

    // 1. Ping æµ‹è¯•
    console.log('\n1ï¸âƒ£ è¿é€šæ€§æµ‹è¯•:');
    diagnosis.tests.ping = await this.ping(host, 4);

    // 2. Traceroute æµ‹è¯•
    console.log('\n2ï¸âƒ£ è·¯ç”±è¿½è¸ª:');
    diagnosis.tests.traceroute = await this.traceroute(host, 15);

    // 3. DNS è§£ææµ‹è¯•
    console.log('\n3ï¸âƒ£ DNS è§£ææµ‹è¯•:');
    try {
      const dns = require('dns').promises;
      const startTime = Date.now();
      const addresses = await dns.resolve4(host);
      const dnsTime = Date.now() - startTime;

      diagnosis.tests.dns = {
        success: true,
        addresses: addresses,
        time: dnsTime,
        primary: addresses[0]
      };

      console.log(`  âœ… DNSè§£ææˆåŠŸ: ${addresses.join(', ')} (${dnsTime}ms)`);
    } catch (error) {
      diagnosis.tests.dns = {
        success: false,
        error: error.message
      };
      console.log(`  âŒ DNSè§£æå¤±è´¥: ${error.message}`);
    }

    // 4. ç«¯å£æ‰«æï¼ˆå¸¸è§ç«¯å£ï¼‰
    console.log('\n4ï¸âƒ£ å¸¸è§ç«¯å£æ£€æµ‹:');
    const commonPorts = [22, 25, 53, 80, 110, 143, 443, 993, 995];
    diagnosis.tests.ports = await this.scanPorts(host, commonPorts);

    // 5. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
    this.generateDiagnosisReport(diagnosis);

    return diagnosis;
  }

  async scanPorts(host, ports) {
    const net = require('net');
    const results = [];

    console.log(`  æ‰«æç«¯å£: ${ports.join(', ')}`);

    for (const port of ports) {
      try {
        await new Promise((resolve, reject) => {
          const socket = net.createConnection({ host, port, timeout: 3000 });

          socket.on('connect', () => {
            socket.end();
            results.push({ port, status: 'open', service: this.getServiceName(port) });
            resolve();
          });

          socket.on('timeout', () => {
            socket.destroy();
            results.push({ port, status: 'timeout', service: this.getServiceName(port) });
            resolve();
          });

          socket.on('error', (error) => {
            results.push({ port, status: 'closed', service: this.getServiceName(port) });
            resolve();
          });
        });
      } catch (error) {
        results.push({ port, status: 'error', service: this.getServiceName(port) });
      }
    }

    // æ˜¾ç¤ºå¼€æ”¾çš„ç«¯å£
    const openPorts = results.filter(r => r.status === 'open');
    if (openPorts.length > 0) {
      console.log(`  ğŸŸ¢ å¼€æ”¾ç«¯å£:`);
      openPorts.forEach(p => {
        console.log(`    ${p.port}/tcp (${p.service})`);
      });
    } else {
      console.log(`  ğŸ”’ æ²¡æœ‰å‘ç°å¼€æ”¾çš„ç«¯å£`);
    }

    return results;
  }

  getServiceName(port) {
    const services = {
      22: 'SSH',
      25: 'SMTP',
      53: 'DNS',
      80: 'HTTP',
      110: 'POP3',
      143: 'IMAP',
      443: 'HTTPS',
      993: 'IMAPS',
      995: 'POP3S'
    };
    return services[port] || 'Unknown';
  }

  generateDiagnosisReport(diagnosis) {
    console.log('\nğŸ“‹ ç½‘ç»œè¯Šæ–­æŠ¥å‘Š:');
    console.log('='.repeat(50));

    const { ping, dns, traceroute, ports } = diagnosis.tests;

    // è¿é€šæ€§è¯„ä¼°
    let connectivity = 'æœªçŸ¥';
    if (ping) {
      const lossRate = parseFloat(ping.lossRate);
      if (lossRate === 0) connectivity = 'âœ… ä¼˜ç§€';
      else if (lossRate < 10) connectivity = 'ğŸŸ¡ è‰¯å¥½';
      else if (lossRate < 50) connectivity = 'ğŸŸ  ä¸€èˆ¬';
      else connectivity = 'âŒ å·®';
    }

    console.log(`ğŸŒ ç›®æ ‡ä¸»æœº: ${diagnosis.host}`);
    console.log(`â° æ£€æµ‹æ—¶é—´: ${new Date(diagnosis.timestamp).toLocaleString()}`);
    console.log(`ğŸ”— è¿é€šæ€§: ${connectivity}`);

    if (ping) {
      console.log(`ğŸ“Š å»¶è¿Ÿ: å¹³å‡ ${ping.avgTime}ms (${ping.minTime}-${ping.maxTime}ms)`);
      console.log(`ğŸ“¦ ä¸¢åŒ…ç‡: ${ping.lossRate}%`);
    }

    if (dns && dns.success) {
      console.log(`ğŸ” DNS: ${dns.addresses[0]} (${dns.time}ms)`);
    }

    if (traceroute) {
      console.log(`ğŸ›£ï¸ è·¯ç”±è·³æ•°: ${traceroute.totalHops}`);
    }

    const openPorts = ports.filter(p => p.status === 'open');
    if (openPorts.length > 0) {
      console.log(`ğŸ”“ å¼€æ”¾æœåŠ¡: ${openPorts.map(p => p.service).join(', ')}`);
    }

    // é—®é¢˜è¯Šæ–­
    console.log('\nğŸ”§ é—®é¢˜è¯Šæ–­:');
    if (ping && parseFloat(ping.lossRate) > 0) {
      console.log('  âš ï¸ æ£€æµ‹åˆ°ä¸¢åŒ…ï¼Œå¯èƒ½çš„åŸå› :');
      console.log('     - ç½‘ç»œæ‹¥å¡');
      console.log('     - é˜²ç«å¢™è¿‡æ»¤');
      console.log('     - è·¯ç”±å™¨é…ç½®é—®é¢˜');
    }

    if (ping && parseFloat(ping.avgTime) > 100) {
      console.log('  âš ï¸ å»¶è¿Ÿè¾ƒé«˜ï¼Œå¯èƒ½çš„åŸå› :');
      console.log('     - ç‰©ç†è·ç¦»è¾ƒè¿œ');
      console.log('     - ç½‘ç»œæ‹¥å¡');
      console.log('     - è·¯ç”±è·¯å¾„ä¸ä¼˜');
    }

    if (dns && !dns.success) {
      console.log('  âŒ DNSè§£æå¤±è´¥ï¼Œå¯èƒ½çš„åŸå› :');
      console.log('     - DNSæœåŠ¡å™¨é—®é¢˜');
      console.log('     - åŸŸåä¸å­˜åœ¨');
      console.log('     - ç½‘ç»œè¿æ¥é—®é¢˜');
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateICMP() {
  const icmp = new ICMPAnalyzer();

  // å¿«é€Ÿè¿é€šæ€§æµ‹è¯•
  console.log('ğŸ§ª ICMP åè®®æµ‹è¯•:');
  await icmp.ping('8.8.8.8', 4);

  // å®Œæ•´ç½‘ç»œè¯Šæ–­
  console.log('\n' + '='.repeat(60));
  await icmp.performNetworkDiagnosis('github.com');
}

// è¿è¡ŒICMPæ¼”ç¤º
if (require.main === module) {
  demonstrateICMP().catch(console.error);
}
```

---

## ğŸ” ç°ä»£ç½‘ç»œåè®®å’Œå®‰å…¨åè®®

### ğŸ’¡ ç°ä»£åº”ç”¨å±‚åè®®

ç°ä»£ç½‘ç»œåè®®é’ˆå¯¹ç‰¹å®šåœºæ™¯è¿›è¡Œäº†ä¼˜åŒ–ï¼Œæä¾›æ›´é«˜æ•ˆçš„é€šä¿¡è§£å†³æ–¹æ¡ˆã€‚

#### ğŸš€ gRPC - é«˜æ€§èƒ½RPCæ¡†æ¶

gRPC æ˜¯Googleå¼€å‘çš„ç°ä»£RPCæ¡†æ¶ï¼ŒåŸºäºHTTP/2æ„å»ºï¼š

```javascript
// gRPC æ¦‚å¿µæ¼”ç¤ºï¼ˆç®€åŒ–ç‰ˆï¼‰
class gRPCConcept {
  constructor() {
    this.services = new Map();
    this.clients = new Map();
  }

  // å®šä¹‰æœåŠ¡
  defineService(serviceName, methods) {
    this.services.set(serviceName, {
      name: serviceName,
      methods: methods
    });

    console.log(`ğŸ“‹ å®šä¹‰æœåŠ¡: ${serviceName}`);
    Object.keys(methods).forEach(method => {
      console.log(`  - ${method}(${methods[method].input}) â†’ ${methods[method].output}`);
    });
  }

  // æœåŠ¡å™¨ç«¯å®ç°
  implementService(serviceName, implementations) {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`æœåŠ¡ ${serviceName} ä¸å­˜åœ¨`);
    }

    service.implementations = implementations;
    console.log(`âœ… å®ç°æœåŠ¡: ${serviceName}`);
  }

  // å®¢æˆ·ç«¯è°ƒç”¨ï¼ˆæ¨¡æ‹Ÿï¼‰
  async call(serviceName, methodName, request) {
    const service = this.services.get(serviceName);
    if (!service || !service.implementations) {
      throw new Error(`æœåŠ¡ ${serviceName} æœªå®ç°`);
    }

    const implementation = service.implementations[methodName];
    if (!implementation) {
      throw new Error(`æ–¹æ³• ${methodName} ä¸å­˜åœ¨`);
    }

    console.log(`ğŸ”„ gRPC è°ƒç”¨: ${serviceName}.${methodName}`);
    console.log(`ğŸ“¤ è¯·æ±‚:`, request);

    try {
      const response = await implementation(request);
      console.log(`ğŸ“¥ å“åº”:`, response);
      return response;
    } catch (error) {
      console.error(`âŒ è°ƒç”¨å¤±è´¥:`, error.message);
      throw error;
    }
  }

  // æµå¼è°ƒç”¨æ¨¡æ‹Ÿ
  createStream(serviceName, methodName) {
    console.log(`ğŸŒŠ åˆ›å»ºæµ: ${serviceName}.${methodName}`);

    return {
      write: (data) => {
        console.log(`ğŸ“¤ æµæ•°æ®:`, data);
      },
      onData: (callback) => {
        console.log(`ğŸ“¥ ç›‘å¬æµæ•°æ®`);
        // æ¨¡æ‹Ÿæ¥æ”¶æ•°æ®
        setTimeout(() => {
          callback({ message: 'æµå¼æ•°æ®', timestamp: Date.now() });
        }, 1000);
      },
      end: () => {
        console.log(`ğŸ”š æµç»“æŸ`);
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function demonstrateGRPC() {
  const grpc = new gRPCConcept();

  // å®šä¹‰ç”¨æˆ·æœåŠ¡
  grpc.defineService('UserService', {
    GetUser: { input: 'UserId', output: 'User' },
    ListUsers: { input: 'ListUsersRequest', output: 'User[]' },
    CreateUser: { input: 'CreateUserRequest', output: 'User' }
  });

  // å®ç°æœåŠ¡
  grpc.implementService('UserService', {
    GetUser: async (request) => {
      return {
        id: request.id,
        name: `ç”¨æˆ·${request.id}`,
        email: `user${request.id}@example.com`
      };
    },

    ListUsers: async (request) => {
      return {
        users: [
          { id: 1, name: 'å¼ ä¸‰', email: 'zhang@example.com' },
          { id: 2, name: 'æå››', email: 'li@example.com' }
        ],
        total: 2
      };
    },

    CreateUser: async (request) => {
      return {
        id: Date.now(),
        name: request.name,
        email: request.email,
        created_at: new Date().toISOString()
      };
    }
  });

  return grpc;
}
```

#### ğŸ“Š GraphQL - æŸ¥è¯¢è¯­è¨€

GraphQL æä¾›äº†çµæ´»çš„æ•°æ®æŸ¥è¯¢æ¥å£ï¼š

```javascript
// GraphQL æ¦‚å¿µæ¼”ç¤º
class GraphQLEngine {
  constructor() {
    this.schema = {};
    this.resolvers = {};
    this.dataSource = this.createMockData();
  }

  createMockData() {
    return {
      users: [
        { id: '1', name: 'å¼ ä¸‰', email: 'zhang@example.com', posts: ['1', '2'] },
        { id: '2', name: 'æå››', email: 'li@example.com', posts: ['3'] }
      ],
      posts: [
        { id: '1', title: 'ç¬¬ä¸€ç¯‡æ–‡ç« ', content: 'å†…å®¹...', authorId: '1' },
        { id: '2', title: 'ç¬¬äºŒç¯‡æ–‡ç« ', content: 'å†…å®¹...', authorId: '1' },
        { id: '3', title: 'ç¬¬ä¸‰ç¯‡æ–‡ç« ', content: 'å†…å®¹...', authorId: '2' }
      ]
    };
  }

  // å®šä¹‰ schema
  defineSchema(schema) {
    this.schema = schema;
    console.log('ğŸ“‹ å®šä¹‰ GraphQL Schema:');
    console.log(JSON.stringify(schema, null, 2));
  }

  // è®¾ç½®è§£æå™¨
  setResolvers(resolvers) {
    this.resolvers = resolvers;
    console.log('âš™ï¸ è®¾ç½®è§£æå™¨');
  }

  // æ‰§è¡ŒæŸ¥è¯¢
  async execute(query) {
    console.log('ğŸ” æ‰§è¡Œ GraphQL æŸ¥è¯¢:');
    console.log(query);

    // ç®€åŒ–çš„æŸ¥è¯¢è§£æï¼ˆå®é™…GraphQLå¼•æ“è¦å¤æ‚å¾—å¤šï¼‰
    try {
      const result = await this.parseAndExecute(query);
      console.log('ğŸ“¥ æŸ¥è¯¢ç»“æœ:');
      console.log(JSON.stringify(result, null, 2));
      return result;
    } catch (error) {
      console.error('âŒ æŸ¥è¯¢å¤±è´¥:', error.message);
      throw error;
    }
  }

  async parseAndExecute(query) {
    // è¿™æ˜¯ä¸€ä¸ªæç®€åŒ–çš„æŸ¥è¯¢è§£æå™¨
    const queryMatch = query.match(/query\s*{([\s\S]*)}/);
    if (!queryMatch) {
      throw new Error('æ— æ•ˆçš„æŸ¥è¯¢æ ¼å¼');
    }

    const queryBody = queryMatch[1].trim();
    const result = {};

    // è§£æå­—æ®µè¯·æ±‚
    if (queryBody.includes('users')) {
      const userFields = this.extractFields(queryBody, 'users');
      result.users = await this.resolveUsers(userFields);
    }

    if (queryBody.includes('posts')) {
      const postFields = this.extractFields(queryBody, 'posts');
      result.posts = await this.resolvePosts(postFields);
    }

    return result;
  }

  extractFields(queryBody, typeName) {
    const regex = new RegExp(`${typeName}\\s*{([^}]*)}`, 'g');
    const match = regex.exec(queryBody);

    if (match) {
      return match[1]
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
    }

    return [];
  }

  async resolveUsers(fields) {
    return this.dataSource.users.map(user => {
      const resolved = {};

      fields.forEach(field => {
        if (field === 'id') resolved.id = user.id;
        if (field === 'name') resolved.name = user.name;
        if (field === 'email') resolved.email = user.email;
        if (field === 'postsCount') {
          resolved.postsCount = user.posts.length;
        }
      });

      return resolved;
    });
  }

  async resolvePosts(fields) {
    return this.dataSource.posts.map(post => {
      const resolved = {};

      fields.forEach(field => {
        if (field === 'id') resolved.id = post.id;
        if (field === 'title') resolved.title = post.title;
        if (field === 'content') resolved.content = post.content;
        if (field === 'author') {
          resolved.author = this.dataSource.users.find(
            user => user.id === post.authorId
          );
        }
      });

      return resolved;
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateGraphQL() {
  const graphql = new GraphQLEngine();

  // å®šä¹‰ schema
  graphql.defineSchema({
    Query: {
      users: '[User!]!',
      posts: '[Post!]!',
      user: 'User'
    },
    User: {
      id: 'ID!',
      name: 'String!',
      email: 'String!',
      posts: '[Post!]!',
      postsCount: 'Int!'
    },
    Post: {
      id: 'ID!',
      title: 'String!',
      content: 'String!',
      author: 'User!'
    }
  });

  // æ‰§è¡Œä¸åŒçš„æŸ¥è¯¢
  console.log('\n1ï¸âƒ£ æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·åŸºæœ¬ä¿¡æ¯:');
  await graphql.execute(`
    query {
      users {
        id
        name
        email
        postsCount
      }
    }
  `);

  console.log('\n2ï¸âƒ£ æŸ¥è¯¢æ–‡ç« åŠä½œè€…ä¿¡æ¯:');
  await graphql.execute(`
    query {
      posts {
        id
        title
        author {
          name
          email
        }
      }
    }
  `);
}
```

### ğŸ›¡ï¸ ç½‘ç»œå®‰å…¨åè®®

ç°ä»£ç½‘ç»œå®‰å…¨åè®®ç¡®ä¿æ•°æ®ä¼ è¾“çš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§ã€‚

#### ğŸ” TLS/SSL - ä¼ è¾“å±‚å®‰å…¨

```javascript
// TLS/SSL æ¦‚å¿µæ¼”ç¤º
class TLSConcept {
  constructor() {
    this.supportedCiphers = [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-GCM-SHA384',
      'AES128-GCM-SHA256'
    ];

    this.supportedVersions = ['TLS 1.2', 'TLS 1.3'];
  }

  // æ¨¡æ‹Ÿ TLS æ¡æ‰‹è¿‡ç¨‹
  async performHandshake(clientHello, serverConfig) {
    console.log('ğŸ¤ å¼€å§‹ TLS æ¡æ‰‹:');

    // 1. Client Hello
    console.log('\n1ï¸âƒ£ Client Hello:');
    console.log(`  TLSç‰ˆæœ¬: ${clientHello.version}`);
    console.log(`  æ”¯æŒçš„å¯†ç å¥—ä»¶: ${clientHello.cipherSuites.slice(0, 3).join(', ')}...`);
    console.log(`  éšæœºæ•°: ${clientHello.random.slice(0, 16)}...`);

    // 2. Server Hello
    const selectedCipher = this.selectCipherSuite(clientHello.cipherSuites);
    const selectedVersion = this.selectTLSVersion(clientHello.version);

    console.log('\n2ï¸âƒ£ Server Hello:');
    console.log(`  é€‰æ‹©çš„TLSç‰ˆæœ¬: ${selectedVersion}`);
    console.log(`  é€‰æ‹©çš„å¯†ç å¥—ä»¶: ${selectedCipher}`);
    console.log(`  ä¼šè¯ID: ${this.generateSessionId()}`);

    // 3. Certificate
    console.log('\n3ï¸âƒ£ Server Certificate:');
    const cert = this.generateMockCertificate(serverConfig.domain);
    console.log(`  è¯ä¹¦ä¸»ä½“: ${cert.subject}`);
    console.log(`  é¢å‘è€…: ${cert.issuer}`);
    console.log(`  æœ‰æ•ˆæœŸ: ${cert.validFrom} - ${cert.validTo}`);

    // 4. Key Exchange
    console.log('\n4ï¸âƒ£ Key Exchange:');
    const keyExchange = this.performKeyExchange(selectedCipher);
    console.log(`  å¯†é’¥äº¤æ¢ç®—æ³•: ${keyExchange.algorithm}`);
    console.log(`  é¢„ä¸»å¯†é’¥é•¿åº¦: ${keyExchange.preMasterSecretLength} bits`);

    // 5. å¯†é’¥æ¨å¯¼
    console.log('\n5ï¸âƒ£ å¯†é’¥æ¨å¯¼:');
    const keys = this.deriveKeys(keyExchange.preMasterSecret);
    console.log(`  å®¢æˆ·ç«¯åŠ å¯†å¯†é’¥: ${keys.clientEncKey.slice(0, 16)}...`);
    console.log(`  æœåŠ¡å™¨åŠ å¯†å¯†é’¥: ${keys.serverEncKey.slice(0, 16)}...`);

    // 6. Finished æ¶ˆæ¯
    console.log('\n6ï¸âƒ£ Finished Messages:');
    console.log('  å®¢æˆ·ç«¯: Finished âœ…');
    console.log('  æœåŠ¡å™¨: Finished âœ…');

    console.log('\nâœ… TLS æ¡æ‰‹å®Œæˆï¼å®‰å…¨é€šé“å»ºç«‹ã€‚');

    return {
      version: selectedVersion,
      cipherSuite: selectedCipher,
      sessionId: this.generateSessionId(),
      keys: keys,
      certificate: cert
    };
  }

  selectCipherSuite(clientSuites) {
    // é€‰æ‹©æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯éƒ½æ”¯æŒçš„æœ€å¼ºå¯†ç å¥—ä»¶
    for (const serverSuite of this.supportedCiphers) {
      if (clientSuites.includes(serverSuite)) {
        return serverSuite;
      }
    }
    throw new Error('æ²¡æœ‰å…±åŒæ”¯æŒçš„å¯†ç å¥—ä»¶');
  }

  selectTLSVersion(clientVersion) {
    if (clientVersion === 'TLS 1.3' && this.supportedVersions.includes('TLS 1.3')) {
      return 'TLS 1.3';
    }
    return 'TLS 1.2';
  }

  generateMockCertificate(domain) {
    return {
      subject: `CN=${domain}`,
      issuer: 'CN=Let\'s Encrypt Authority X3',
      validFrom: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      validTo: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      algorithm: 'RSA-SHA256',
      keySize: 2048,
      fingerprint: this.generateRandomHex(32)
    };
  }

  performKeyExchange(cipherSuite) {
    if (cipherSuite.includes('ECDHE')) {
      return {
        algorithm: 'ECDHE (æ¤­åœ†æ›²çº¿ Diffie-Hellman ä¸´æ—¶)',
        curve: 'P-256',
        preMasterSecret: this.generateRandomHex(64),
        preMasterSecretLength: 256
      };
    } else {
      return {
        algorithm: 'RSA',
        preMasterSecret: this.generateRandomHex(48),
        preMasterSecretLength: 384
      };
    }
  }

  deriveKeys(preMasterSecret) {
    // ç®€åŒ–çš„å¯†é’¥æ¨å¯¼ï¼ˆå®é™…ä½¿ç”¨ PRF - ä¼ªéšæœºå‡½æ•°ï¼‰
    return {
      clientEncKey: this.generateRandomHex(32),
      serverEncKey: this.generateRandomHex(32),
      clientMacKey: this.generateRandomHex(32),
      serverMacKey: this.generateRandomHex(32),
      clientIV: this.generateRandomHex(16),
      serverIV: this.generateRandomHex(16)
    };
  }

  generateSessionId() {
    return this.generateRandomHex(32);
  }

  generateRandomHex(length) {
    const chars = '0123456789abcdef';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  // TLS è®°å½•å±‚æ¨¡æ‹Ÿ
  encryptData(data, keys) {
    console.log(`ğŸ” åŠ å¯†æ•°æ® (${data.length} å­—èŠ‚):`);
    console.log(`  ä½¿ç”¨å¯†é’¥: ${keys.clientEncKey.slice(0, 16)}...`);

    // æ¨¡æ‹ŸåŠ å¯†è¿‡ç¨‹
    const encrypted = Buffer.from(data).toString('base64');
    console.log(`  åŠ å¯†ç»“æœ: ${encrypted.slice(0, 32)}...`);

    return {
      type: 'application_data',
      version: 'TLS 1.2',
      length: encrypted.length,
      data: encrypted
    };
  }

  decryptData(encryptedRecord, keys) {
    console.log('ğŸ”“ è§£å¯†æ•°æ®:');
    console.log(`  ä½¿ç”¨å¯†é’¥: ${keys.serverEncKey.slice(0, 16)}...`);

    // æ¨¡æ‹Ÿè§£å¯†è¿‡ç¨‹
    const decrypted = Buffer.from(encryptedRecord.data, 'base64').toString();
    console.log(`  è§£å¯†ç»“æœ: ${decrypted}`);

    return decrypted;
  }
}

// SSL/TLS å®‰å…¨æ£€æŸ¥å·¥å…·
class TLSSecurityChecker {
  constructor() {
    this.securityLevels = {
      'TLS 1.0': 'âŒ ä¸å®‰å…¨ (å·²åºŸå¼ƒ)',
      'TLS 1.1': 'âš ï¸ ä¸æ¨è (å·²åºŸå¼ƒ)',
      'TLS 1.2': 'âœ… å®‰å…¨',
      'TLS 1.3': 'ğŸ”’ æœ€å®‰å…¨'
    };

    this.cipherStrengths = {
      'AES256-GCM': 'ğŸ”’ å¼º',
      'AES128-GCM': 'âœ… ä¸­ç­‰',
      'AES256-CBC': 'âš ï¸ ä¸­ç­‰ (CBCæ¨¡å¼)',
      'AES128-CBC': 'âš ï¸ è¾ƒå¼± (CBCæ¨¡å¼)',
      'RC4': 'âŒ ä¸å®‰å…¨ (å·²åºŸå¼ƒ)',
      'DES': 'âŒ ä¸å®‰å…¨ (å·²åºŸå¼ƒ)'
    };
  }

  analyzeTLSConfiguration(config) {
    console.log('ğŸ” TLS é…ç½®å®‰å…¨åˆ†æ:');
    console.log('='.repeat(40));

    const report = {
      domain: config.domain,
      overall: 'unknown',
      issues: [],
      recommendations: []
    };

    // æ£€æŸ¥ TLS ç‰ˆæœ¬
    console.log('\nğŸ“‹ TLS ç‰ˆæœ¬æ£€æŸ¥:');
    config.supportedVersions.forEach(version => {
      const security = this.securityLevels[version];
      console.log(`  ${version}: ${security}`);

      if (version === 'TLS 1.0' || version === 'TLS 1.1') {
        report.issues.push(`æ”¯æŒå·²åºŸå¼ƒçš„ ${version}`);
        report.recommendations.push(`ç¦ç”¨ ${version} æ”¯æŒ`);
      }
    });

    // æ£€æŸ¥å¯†ç å¥—ä»¶
    console.log('\nğŸ” å¯†ç å¥—ä»¶æ£€æŸ¥:');
    config.cipherSuites.forEach(suite => {
      const algorithm = this.extractEncryptionAlgorithm(suite);
      const strength = this.cipherStrengths[algorithm] || 'â“ æœªçŸ¥';
      console.log(`  ${suite}: ${strength}`);

      if (suite.includes('RC4') || suite.includes('DES')) {
        report.issues.push(`ä½¿ç”¨ä¸å®‰å…¨çš„åŠ å¯†ç®—æ³•: ${algorithm}`);
        report.recommendations.push(`ç§»é™¤åŒ…å« ${algorithm} çš„å¯†ç å¥—ä»¶`);
      }
    });

    // æ£€æŸ¥è¯ä¹¦
    console.log('\nğŸ“œ è¯ä¹¦æ£€æŸ¥:');
    if (config.certificate) {
      const cert = config.certificate;
      const validFrom = new Date(cert.validFrom);
      const validTo = new Date(cert.validTo);
      const now = new Date();

      console.log(`  é¢å‘è€…: ${cert.issuer}`);
      console.log(`  æœ‰æ•ˆæœŸ: ${cert.validFrom} - ${cert.validTo}`);
      console.log(`  å¯†é’¥é•¿åº¦: ${cert.keySize} bits`);

      if (now < validFrom || now > validTo) {
        report.issues.push('è¯ä¹¦å·²è¿‡æœŸæˆ–å°šæœªç”Ÿæ•ˆ');
        report.recommendations.push('æ›´æ–°SSLè¯ä¹¦');
      }

      if (cert.keySize < 2048) {
        report.issues.push('RSAå¯†é’¥é•¿åº¦è¿‡çŸ­');
        report.recommendations.push('ä½¿ç”¨è‡³å°‘2048ä½RSAå¯†é’¥');
      }
    }

    // ç”Ÿæˆæ€»ä½“è¯„åˆ†
    if (report.issues.length === 0) {
      report.overall = 'ğŸ”’ ä¼˜ç§€';
    } else if (report.issues.length <= 2) {
      report.overall = 'âœ… è‰¯å¥½';
    } else if (report.issues.length <= 4) {
      report.overall = 'âš ï¸ éœ€è¦æ”¹è¿›';
    } else {
      report.overall = 'âŒ ä¸å®‰å…¨';
    }

    console.log(`\nğŸ“Š æ€»ä½“å®‰å…¨è¯„çº§: ${report.overall}`);

    if (report.issues.length > 0) {
      console.log('\nâš ï¸ å‘ç°çš„é—®é¢˜:');
      report.issues.forEach((issue, index) => {
        console.log(`  ${index + 1}. ${issue}`);
      });

      console.log('\nğŸ’¡ å»ºè®®æ”¹è¿›:');
      report.recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec}`);
      });
    }

    return report;
  }

  extractEncryptionAlgorithm(cipherSuite) {
    if (cipherSuite.includes('AES256-GCM')) return 'AES256-GCM';
    if (cipherSuite.includes('AES128-GCM')) return 'AES128-GCM';
    if (cipherSuite.includes('AES256-CBC')) return 'AES256-CBC';
    if (cipherSuite.includes('AES128-CBC')) return 'AES128-CBC';
    if (cipherSuite.includes('RC4')) return 'RC4';
    if (cipherSuite.includes('DES')) return 'DES';
    return 'Unknown';
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateTLS() {
  const tls = new TLSConcept();
  const checker = new TLSSecurityChecker();

  // æ¨¡æ‹Ÿå®¢æˆ·ç«¯Hello
  const clientHello = {
    version: 'TLS 1.3',
    cipherSuites: [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-GCM-SHA384'
    ],
    random: tls.generateRandomHex(64)
  };

  const serverConfig = {
    domain: 'secure.example.com'
  };

  // æ‰§è¡Œæ¡æ‰‹
  const handshakeResult = await tls.performHandshake(clientHello, serverConfig);

  // æ¼”ç¤ºæ•°æ®åŠ å¯†ä¼ è¾“
  console.log('\n' + '='.repeat(50));
  console.log('ğŸ” å®‰å…¨æ•°æ®ä¼ è¾“æ¼”ç¤º:');

  const originalData = 'Hello, this is secure data!';
  const encryptedRecord = tls.encryptData(originalData, handshakeResult.keys);
  const decryptedData = tls.decryptData(encryptedRecord, handshakeResult.keys);

  // TLS é…ç½®å®‰å…¨æ£€æŸ¥
  console.log('\n' + '='.repeat(50));
  const tlsConfig = {
    domain: 'example.com',
    supportedVersions: ['TLS 1.2', 'TLS 1.3'],
    cipherSuites: [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'AES256-CBC-SHA256' // è¾ƒå¼±çš„å¯†ç å¥—ä»¶
    ],
    certificate: {
      issuer: 'CN=DigiCert SHA2 Secure Server CA',
      validFrom: '2023-01-01',
      validTo: '2024-01-01',
      keySize: 2048,
      algorithm: 'RSA-SHA256'
    }
  };

  checker.analyzeTLSConfiguration(tlsConfig);
}
```

---

## ğŸ› ï¸ ç½‘ç»œè°ƒè¯•ä¸ç›‘æ§å®è·µ

### ğŸ”§ ç½‘ç»œé—®é¢˜è¯Šæ–­å·¥å…·é›†

```javascript
// ç»¼åˆç½‘ç»œè¯Šæ–­å·¥å…·
class NetworkDiagnostics {
  constructor() {
    this.tools = {
      ping: new PingTool(),
      traceroute: new TracerouteTool(),
      portScan: new PortScanTool(),
      dnsCheck: new DNSChecker(),
      sslCheck: new SSLChecker(),
      performance: new NetworkPerformanceTool()
    };
  }

  async runFullDiagnosis(target) {
    console.log(`ğŸ”§ å¯¹ ${target} è¿›è¡Œå…¨é¢ç½‘ç»œè¯Šæ–­`);
    console.log('='.repeat(60));

    const results = {
      target: target,
      timestamp: new Date().toISOString(),
      tests: {}
    };

    try {
      // 1. åŸºç¡€è¿é€šæ€§æµ‹è¯•
      console.log('\n1ï¸âƒ£ åŸºç¡€è¿é€šæ€§æµ‹è¯•');
      results.tests.connectivity = await this.tools.ping.test(target);

      // 2. è·¯ç”±è¿½è¸ª
      console.log('\n2ï¸âƒ£ è·¯ç”±è·¯å¾„åˆ†æ');
      results.tests.routing = await this.tools.traceroute.trace(target);

      // 3. DNSè§£ææ£€æŸ¥
      console.log('\n3ï¸âƒ£ DNSè§£ææ£€æŸ¥');
      results.tests.dns = await this.tools.dnsCheck.resolve(target);

      // 4. ç«¯å£æ‰«æ
      console.log('\n4ï¸âƒ£ æœåŠ¡ç«¯å£æ£€æµ‹');
      results.tests.ports = await this.tools.portScan.scan(target);

      // 5. SSL/TLSæ£€æŸ¥ï¼ˆå¦‚æœæ˜¯HTTPSï¼‰
      if (target.includes('https://') || results.tests.ports.some(p => p.port === 443 && p.status === 'open')) {
        console.log('\n5ï¸âƒ£ SSL/TLSå®‰å…¨æ£€æŸ¥');
        results.tests.ssl = await this.tools.sslCheck.check(target);
      }

      // 6. æ€§èƒ½æµ‹è¯•
      console.log('\n6ï¸âƒ£ ç½‘ç»œæ€§èƒ½æµ‹è¯•');
      results.tests.performance = await this.tools.performance.measure(target);

      // 7. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
      this.generateReport(results);

      return results;

    } catch (error) {
      console.error('âŒ è¯Šæ–­è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error.message);
      return null;
    }
  }

  generateReport(results) {
    console.log('\nğŸ“Š ç½‘ç»œè¯Šæ–­æŠ¥å‘Š');
    console.log('='.repeat(50));

    const { target, tests } = results;
    const issues = [];
    const recommendations = [];

    console.log(`ğŸ¯ ç›®æ ‡: ${target}`);
    console.log(`â° æ£€æµ‹æ—¶é—´: ${new Date(results.timestamp).toLocaleString()}`);

    // åˆ†æè¿é€šæ€§
    if (tests.connectivity) {
      const { lossRate, avgTime } = tests.connectivity;
      console.log(`\nğŸŒ è¿é€šæ€§:`);
      console.log(`  ä¸¢åŒ…ç‡: ${lossRate}%`);
      console.log(`  å¹³å‡å»¶è¿Ÿ: ${avgTime}ms`);

      if (parseFloat(lossRate) > 5) {
        issues.push('æ£€æµ‹åˆ°æ˜æ˜¾ä¸¢åŒ…');
        recommendations.push('æ£€æŸ¥ç½‘ç»œé“¾è·¯è´¨é‡');
      }

      if (parseFloat(avgTime) > 200) {
        issues.push('ç½‘ç»œå»¶è¿Ÿè¾ƒé«˜');
        recommendations.push('è€ƒè™‘ä½¿ç”¨CDNæˆ–ä¼˜åŒ–è·¯ç”±');
      }
    }

    // åˆ†æDNS
    if (tests.dns) {
      console.log(`\nğŸ” DNSè§£æ:`);
      if (tests.dns.success) {
        console.log(`  è§£ææˆåŠŸ: ${tests.dns.addresses[0]} (${tests.dns.time}ms)`);

        if (tests.dns.time > 100) {
          issues.push('DNSè§£ææ—¶é—´è¾ƒé•¿');
          recommendations.push('è€ƒè™‘æ›´æ¢æ›´å¿«çš„DNSæœåŠ¡å™¨');
        }
      } else {
        console.log(`  è§£æå¤±è´¥: ${tests.dns.error}`);
        issues.push('DNSè§£æå¤±è´¥');
        recommendations.push('æ£€æŸ¥DNSé…ç½®');
      }
    }

    // åˆ†æSSL
    if (tests.ssl) {
      console.log(`\nğŸ”’ SSL/TLS:`);
      console.log(`  åè®®ç‰ˆæœ¬: ${tests.ssl.version}`);
      console.log(`  è¯ä¹¦çŠ¶æ€: ${tests.ssl.certificateValid ? 'âœ… æœ‰æ•ˆ' : 'âŒ æ— æ•ˆ'}`);

      if (!tests.ssl.certificateValid) {
        issues.push('SSLè¯ä¹¦æ— æ•ˆæˆ–è¿‡æœŸ');
        recommendations.push('æ›´æ–°SSLè¯ä¹¦');
      }

      if (tests.ssl.version === 'TLS 1.0' || tests.ssl.version === 'TLS 1.1') {
        issues.push('ä½¿ç”¨è¿‡æ—¶çš„TLSç‰ˆæœ¬');
        recommendations.push('å‡çº§åˆ°TLS 1.2æˆ–1.3');
      }
    }

    // åˆ†ææ€§èƒ½
    if (tests.performance) {
      console.log(`\nâš¡ æ€§èƒ½æŒ‡æ ‡:`);
      console.log(`  å¸¦å®½åˆ©ç”¨ç‡: ${tests.performance.bandwidth} Mbps`);
      console.log(`  è¿æ¥å»ºç«‹æ—¶é—´: ${tests.performance.connectTime}ms`);

      if (tests.performance.connectTime > 1000) {
        issues.push('è¿æ¥å»ºç«‹æ—¶é—´è¿‡é•¿');
        recommendations.push('ä¼˜åŒ–æœåŠ¡å™¨å“åº”æ—¶é—´');
      }
    }

    // æ€»ä½“è¯„ä¼°
    let overallStatus;
    if (issues.length === 0) {
      overallStatus = 'âœ… ä¼˜ç§€';
    } else if (issues.length <= 2) {
      overallStatus = 'ğŸŸ¡ è‰¯å¥½';
    } else if (issues.length <= 4) {
      overallStatus = 'ğŸŸ  éœ€è¦ä¼˜åŒ–';
    } else {
      overallStatus = 'âŒ å­˜åœ¨é—®é¢˜';
    }

    console.log(`\nğŸ“Š æ€»ä½“çŠ¶æ€: ${overallStatus}`);

    if (issues.length > 0) {
      console.log('\nâš ï¸ å‘ç°çš„é—®é¢˜:');
      issues.forEach((issue, index) => {
        console.log(`  ${index + 1}. ${issue}`);
      });

      console.log('\nğŸ’¡ ä¼˜åŒ–å»ºè®®:');
      recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec}`);
      });
    }
  }
}

// ç½‘ç»œæ€§èƒ½ç›‘æ§å·¥å…·
class NetworkMonitor {
  constructor() {
    this.isMonitoring = false;
    this.metrics = [];
    this.alertThresholds = {
      latency: 500, // ms
      packetLoss: 5, // %
      bandwidth: 1 // Mbps minimum
    };
  }

  startMonitoring(targets, interval = 60000) {
    if (this.isMonitoring) {
      console.log('âš ï¸ ç›‘æ§å·²åœ¨è¿è¡Œ');
      return;
    }

    this.isMonitoring = true;
    console.log(`ğŸ“Š å¼€å§‹ç½‘ç»œç›‘æ§ (${targets.length} ä¸ªç›®æ ‡, ${interval/1000}s é—´éš”)`);

    this.monitoringInterval = setInterval(async () => {
      for (const target of targets) {
        try {
          const metrics = await this.collectMetrics(target);
          this.metrics.push({
            target: target,
            timestamp: Date.now(),
            ...metrics
          });

          // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
          this.checkAlerts(target, metrics);

          // ä¿æŒæœ€è¿‘1000æ¡è®°å½•
          if (this.metrics.length > 1000) {
            this.metrics = this.metrics.slice(-1000);
          }

        } catch (error) {
          console.error(`âŒ ç›‘æ§ ${target} æ—¶å‡ºé”™:`, error.message);
        }
      }
    }, interval);

    return this;
  }

  async collectMetrics(target) {
    // ç®€åŒ–çš„æŒ‡æ ‡æ”¶é›†
    const ping = await this.measureLatency(target);
    const bandwidth = await this.measureBandwidth(target);

    return {
      latency: ping.avgTime,
      packetLoss: ping.lossRate,
      jitter: ping.jitter || 0,
      bandwidth: bandwidth
    };
  }

  async measureLatency(target, samples = 3) {
    // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„pingå·¥å…·
    // æ¨¡æ‹Ÿæ•°æ®
    const latencies = Array.from({length: samples}, () =>
      Math.random() * 200 + 50
    );

    const avgTime = latencies.reduce((a, b) => a + b, 0) / latencies.length;
    const lossRate = Math.random() * 10; // æ¨¡æ‹Ÿä¸¢åŒ…ç‡

    return {
      avgTime: avgTime.toFixed(2),
      lossRate: lossRate.toFixed(2),
      jitter: Math.random() * 20 // æ¨¡æ‹ŸæŠ–åŠ¨
    };
  }

  async measureBandwidth(target) {
    // æ¨¡æ‹Ÿå¸¦å®½æµ‹è¯•
    return (Math.random() * 100 + 10).toFixed(2);
  }

  checkAlerts(target, metrics) {
    const alerts = [];

    if (parseFloat(metrics.latency) > this.alertThresholds.latency) {
      alerts.push(`é«˜å»¶è¿Ÿ: ${metrics.latency}ms > ${this.alertThresholds.latency}ms`);
    }

    if (parseFloat(metrics.packetLoss) > this.alertThresholds.packetLoss) {
      alerts.push(`é«˜ä¸¢åŒ…ç‡: ${metrics.packetLoss}% > ${this.alertThresholds.packetLoss}%`);
    }

    if (parseFloat(metrics.bandwidth) < this.alertThresholds.bandwidth) {
      alerts.push(`ä½å¸¦å®½: ${metrics.bandwidth}Mbps < ${this.alertThresholds.bandwidth}Mbps`);
    }

    if (alerts.length > 0) {
      console.log(`ğŸš¨ ${target} å‘Šè­¦:`);
      alerts.forEach(alert => console.log(`  - ${alert}`));
    }
  }

  getStatistics(target = null, timeRange = 3600000) { // 1å°æ—¶
    const now = Date.now();
    const startTime = now - timeRange;

    let filteredMetrics = this.metrics.filter(m => m.timestamp >= startTime);

    if (target) {
      filteredMetrics = filteredMetrics.filter(m => m.target === target);
    }

    if (filteredMetrics.length === 0) {
      return null;
    }

    const latencies = filteredMetrics.map(m => parseFloat(m.latency));
    const packetLosses = filteredMetrics.map(m => parseFloat(m.packetLoss));
    const bandwidths = filteredMetrics.map(m => parseFloat(m.bandwidth));

    return {
      target: target || 'all',
      timeRange: `${timeRange / 60000} åˆ†é’Ÿ`,
      samples: filteredMetrics.length,
      latency: {
        avg: (latencies.reduce((a, b) => a + b, 0) / latencies.length).toFixed(2),
        min: Math.min(...latencies).toFixed(2),
        max: Math.max(...latencies).toFixed(2)
      },
      packetLoss: {
        avg: (packetLosses.reduce((a, b) => a + b, 0) / packetLosses.length).toFixed(2),
        max: Math.max(...packetLosses).toFixed(2)
      },
      bandwidth: {
        avg: (bandwidths.reduce((a, b) => a + b, 0) / bandwidths.length).toFixed(2),
        min: Math.min(...bandwidths).toFixed(2),
        max: Math.max(...bandwidths).toFixed(2)
      }
    };
  }

  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.isMonitoring = false;
      console.log('ğŸ“Š ç½‘ç»œç›‘æ§å·²åœæ­¢');
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function demonstrateNetworkTools() {
  // ç½‘ç»œè¯Šæ–­ç¤ºä¾‹
  const diagnostics = new NetworkDiagnostics();
  await diagnostics.runFullDiagnosis('github.com');

  // ç½‘ç»œç›‘æ§ç¤ºä¾‹
  console.log('\n' + '='.repeat(60));
  console.log('ğŸ“Š ç½‘ç»œç›‘æ§æ¼”ç¤º:');

  const monitor = new NetworkMonitor();

  // è®¾ç½®å‘Šè­¦é˜ˆå€¼
  monitor.alertThresholds = {
    latency: 200,
    packetLoss: 3,
    bandwidth: 5
  };

  // å¼€å§‹ç›‘æ§
  monitor.startMonitoring(['github.com', 'google.com'], 10000);

  // 5åˆ†é’Ÿåæ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯å¹¶åœæ­¢ç›‘æ§
  setTimeout(() => {
    const stats = monitor.getStatistics('github.com', 300000);
    if (stats) {
      console.log('\nğŸ“ˆ ç›‘æ§ç»Ÿè®¡ (æœ€è¿‘5åˆ†é’Ÿ):');
      console.log(`ç›®æ ‡: ${stats.target}`);
      console.log(`æ ·æœ¬æ•°: ${stats.samples}`);
      console.log(`å»¶è¿Ÿ: å¹³å‡${stats.latency.avg}ms, èŒƒå›´${stats.latency.min}-${stats.latency.max}ms`);
      console.log(`ä¸¢åŒ…ç‡: å¹³å‡${stats.packetLoss.avg}%, æœ€é«˜${stats.packetLoss.max}%`);
      console.log(`å¸¦å®½: å¹³å‡${stats.bandwidth.avg}Mbps, èŒƒå›´${stats.bandwidth.min}-${stats.bandwidth.max}Mbps`);
    }

    monitor.stopMonitoring();
  }, 300000);
}

// è¿è¡Œæ¼”ç¤º
if (require.main === module) {
  Promise.all([
    demonstrateGraphQL(),
    demonstrateTLS(),
    demonstrateNetworkTools()
  ]).catch(console.error);
}
```

---

## ğŸ“š å­¦ä¹ æ€»ç»“ä¸è¿›é˜¶æŒ‡å—

### ğŸ¯ æ ¸å¿ƒè¦ç‚¹å›é¡¾

é€šè¿‡æœ¬æ–‡æ¡£çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

1. **ğŸŒ åè®®åˆ†å±‚æ¶æ„**ï¼šç†è§£OSIå’ŒTCP/IPæ¨¡å‹çš„è®¾è®¡ç†å¿µ
2. **ğŸ“± åº”ç”¨å±‚åè®®**ï¼šHTTP/HTTPSã€WebSocketã€DNSçš„å·¥ä½œåŸç†
3. **ğŸš€ ä¼ è¾“å±‚åè®®**ï¼šTCPã€UDPçš„ç‰¹æ€§å’Œåº”ç”¨åœºæ™¯
4. **ğŸŒ ç½‘ç»œå±‚åè®®**ï¼šIPåœ°å€ã€è·¯ç”±ã€ICMPçš„æ ¸å¿ƒæ¦‚å¿µ
5. **ğŸ” å®‰å…¨åè®®**ï¼šTLS/SSLã€ç°ä»£åŠ å¯†æŠ€æœ¯çš„å®ç°
6. **ğŸ› ï¸ å®è·µæŠ€èƒ½**ï¼šç½‘ç»œè¯Šæ–­ã€ç›‘æ§å’Œä¼˜åŒ–çš„æ–¹æ³•

### ğŸ’¡ å®è·µé¡¹ç›®å»ºè®®

#### ğŸš€ åˆçº§é¡¹ç›®
1. **HTTPå®¢æˆ·ç«¯å·¥å…·**ï¼šå®ç°æ”¯æŒå¤šç§HTTPæ–¹æ³•çš„å®¢æˆ·ç«¯
2. **ç®€å•èŠå¤©å®¤**ï¼šä½¿ç”¨WebSocketæ„å»ºå®æ—¶é€šä¿¡åº”ç”¨
3. **DNSæŸ¥è¯¢å·¥å…·**ï¼šåˆ›å»ºå¯è§†åŒ–çš„DNSè§£æå·¥å…·
4. **ç½‘ç»œå»¶è¿Ÿç›‘æ§**ï¼šå¼€å‘pingå’Œtracerouteå·¥å…·

#### ğŸŒŸ ä¸­çº§é¡¹ç›®
1. **è´Ÿè½½å‡è¡¡å™¨**ï¼šå®ç°ç®€å•çš„HTTPè´Ÿè½½å‡è¡¡
2. **ä»£ç†æœåŠ¡å™¨**ï¼šæ„å»ºHTTP/HTTPSä»£ç†
3. **ç½‘ç»œæ€§èƒ½åˆ†æä»ª**ï¼šé›†æˆå¤šç§ç½‘ç»œæµ‹è¯•åŠŸèƒ½
4. **SSLè¯ä¹¦ç›‘æ§ç³»ç»Ÿ**ï¼šè‡ªåŠ¨æ£€æŸ¥è¯ä¹¦è¿‡æœŸçŠ¶æ€

#### ğŸ”¥ é«˜çº§é¡¹ç›®
1. **è‡ªå®šä¹‰åè®®è®¾è®¡**ï¼šè®¾è®¡å¹¶å®ç°ä¸“ç”¨é€šä¿¡åè®®
2. **ç½‘ç»œæµé‡åˆ†æå™¨**ï¼šç±»ä¼¼Wiresharkçš„æ•°æ®åŒ…åˆ†æå·¥å…·
3. **åˆ†å¸ƒå¼ç½‘ç»œç›‘æ§**ï¼šå¤šèŠ‚ç‚¹ç½‘ç»œå¥åº·ç›‘æ§ç³»ç»Ÿ
4. **ç½‘ç»œå®‰å…¨æ‰«æå™¨**ï¼šè‡ªåŠ¨åŒ–å®‰å…¨æ¼æ´æ£€æµ‹å·¥å…·

### ğŸ” æ·±å…¥å­¦ä¹ æ–¹å‘

#### ğŸ“– æ¨èä¹¦ç±
- ã€ŠTCP/IPè¯¦è§£ã€‹- Richard Stevens
- ã€Šè®¡ç®—æœºç½‘ç»œï¼šè‡ªé¡¶å‘ä¸‹æ–¹æ³•ã€‹- James Kurose
- ã€ŠHTTPæƒå¨æŒ‡å—ã€‹- David Gourley
- ã€Šç½‘ç»œå®‰å…¨ä¸å¯†ç å­¦ã€‹- William Stallings

#### ğŸŒ åœ¨çº¿èµ„æº
- RFCæ–‡æ¡£ï¼šäº’è”ç½‘æ ‡å‡†çš„æƒå¨æ¥æº
- Wiresharkå®˜æ–¹æ•™ç¨‹ï¼šæ•°æ®åŒ…åˆ†æå®æˆ˜
- Mozillaå¼€å‘è€…ç½‘ç»œï¼šWebåè®®å‚è€ƒ
- OWASPï¼šWebå®‰å…¨æœ€ä½³å®è·µ

#### ğŸ“ è®¤è¯å»ºè®®
- **Cisco CCNA**ï¼šç½‘ç»œåŸºç¡€è®¤è¯
- **CompTIA Network+**ï¼šç½‘ç»œæŠ€æœ¯ç»¼åˆè®¤è¯
- **Certified Ethical Hacker**ï¼šç½‘ç»œå®‰å…¨è®¤è¯

### âš¡ æ€§èƒ½ä¼˜åŒ–æŒ‡å—

#### ğŸš€ ç½‘ç»œä¼˜åŒ–ç­–ç•¥
```
1. å»¶è¿Ÿä¼˜åŒ–
   â”œâ”€â”€ ä½¿ç”¨CDN
   â”œâ”€â”€ é€‰æ‹©æœ€ä¼˜æœåŠ¡å™¨ä½ç½®
   â”œâ”€â”€ å¯ç”¨HTTP/2
   â””â”€â”€ å‹ç¼©ä¼ è¾“å†…å®¹

2. å¸¦å®½ä¼˜åŒ–
   â”œâ”€â”€ å›¾ç‰‡å‹ç¼©ä¸æ ¼å¼ä¼˜åŒ–
   â”œâ”€â”€ ä»£ç å‹ç¼©ä¸æ··æ·†
   â”œâ”€â”€ å¯ç”¨Gzipå‹ç¼©
   â””â”€â”€ ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

3. è¿æ¥ä¼˜åŒ–
   â”œâ”€â”€ è¿æ¥å¤ç”¨
   â”œâ”€â”€ Keep-Aliveè®¾ç½®
   â”œâ”€â”€ å‡å°‘DNSæŸ¥è¯¢
   â””â”€â”€ é¢„è¿æ¥å…³é”®èµ„æº
```

#### ğŸ”§ ç›‘æ§æŒ‡æ ‡
- **å»¶è¿ŸæŒ‡æ ‡**ï¼šRTTã€TTFBã€é¡µé¢åŠ è½½æ—¶é—´
- **å¯é æ€§æŒ‡æ ‡**ï¼šä¸¢åŒ…ç‡ã€é”™è¯¯ç‡ã€å¯ç”¨æ€§
- **ååé‡æŒ‡æ ‡**ï¼šå¸¦å®½åˆ©ç”¨ç‡ã€å¹¶å‘è¿æ¥æ•°
- **å®‰å…¨æŒ‡æ ‡**ï¼šSSLæ¡æ‰‹æ—¶é—´ã€è¯ä¹¦æœ‰æ•ˆæ€§

### ğŸª æ•…éšœæ’æŸ¥æ¸…å•

#### ğŸ” ç½‘ç»œé—®é¢˜è¯Šæ–­æµç¨‹
```
1. ç¡®è®¤é—®é¢˜èŒƒå›´
   â”œâ”€â”€ å½±å“èŒƒå›´ï¼šå•ç”¨æˆ· vs å…¨éƒ¨ç”¨æˆ·
   â”œâ”€â”€ æ•…éšœç±»å‹ï¼šè¿é€šæ€§ vs æ€§èƒ½ vs å®‰å…¨
   â””â”€â”€ æ—¶é—´æ¨¡å¼ï¼šé—´æ­‡æ€§ vs æŒç»­æ€§

2. åŸºç¡€è¿é€šæ€§æ£€æŸ¥
   â”œâ”€â”€ ping ç›®æ ‡ä¸»æœº
   â”œâ”€â”€ traceroute è·¯å¾„åˆ†æ
   â”œâ”€â”€ DNS è§£æéªŒè¯
   â””â”€â”€ ç«¯å£è¿é€šæ€§æµ‹è¯•

3. åè®®å±‚åˆ†æ
   â”œâ”€â”€ åº”ç”¨å±‚ï¼šHTTPçŠ¶æ€ç ã€APIå“åº”
   â”œâ”€â”€ ä¼ è¾“å±‚ï¼šTCPè¿æ¥çŠ¶æ€ã€ç«¯å£ç›‘å¬
   â”œâ”€â”€ ç½‘ç»œå±‚ï¼šè·¯ç”±è¡¨ã€IPé…ç½®
   â””â”€â”€ é“¾è·¯å±‚ï¼šç½‘å¡çŠ¶æ€ã€äº¤æ¢æœºæ—¥å¿—

4. æ€§èƒ½åˆ†æ
   â”œâ”€â”€ å¸¦å®½æµ‹è¯•
   â”œâ”€â”€ å»¶è¿Ÿæµ‹é‡
   â”œâ”€â”€ å¹¶å‘è¿æ¥æµ‹è¯•
   â””â”€â”€ èµ„æºåˆ©ç”¨ç‡æ£€æŸ¥

5. å®‰å…¨æ£€æŸ¥
   â”œâ”€â”€ SSL/TLS é…ç½®éªŒè¯
   â”œâ”€â”€ é˜²ç«å¢™è§„åˆ™æ£€æŸ¥
   â”œâ”€â”€ å…¥ä¾µæ£€æµ‹æ—¥å¿—
   â””â”€â”€ è¯ä¹¦æœ‰æ•ˆæ€§éªŒè¯
```

### ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. **ğŸ”§ åŠ¨æ‰‹å®è·µ**ï¼šå®Œæˆè‡³å°‘3ä¸ªä¸åŒå¤æ‚åº¦çš„ç½‘ç»œé¡¹ç›®
2. **ğŸ“Š æ·±å…¥åˆ†æ**ï¼šä½¿ç”¨Wiresharkåˆ†æçœŸå®ç½‘ç»œæµé‡
3. **ğŸ›¡ï¸ å®‰å…¨æ„è¯†**ï¼šå­¦ä¹ å¸¸è§ç½‘ç»œæ”»å‡»å’Œé˜²æŠ¤æ–¹æ³•
4. **â˜ï¸ äº‘ç½‘ç»œ**ï¼šäº†è§£ç°ä»£äº‘è®¡ç®—ç½‘ç»œæ¶æ„
5. **ğŸ“± ç§»åŠ¨ç½‘ç»œ**ï¼šç ”ç©¶5Gã€WiFi 6ç­‰æ–°æŠ€æœ¯

è®°ä½ï¼šç½‘ç»œåè®®æ˜¯ä¸€ä¸ªå®è·µæ€§å¾ˆå¼ºçš„é¢†åŸŸã€‚ç†è®ºå­¦ä¹ è¦ä¸å®é™…åŠ¨æ‰‹ç›¸ç»“åˆï¼Œé€šè¿‡æ­å»ºå®éªŒç¯å¢ƒã€åˆ†æç½‘ç»œæµé‡ã€è§£å†³å®é™…é—®é¢˜æ¥æ·±åŒ–ç†è§£ã€‚

---

ğŸ“ **æœ€åçš„è¯**ï¼š
ç½‘ç»œåè®®æ˜¯è®¡ç®—æœºç§‘å­¦çš„åŸºçŸ³ï¼ŒæŒæ¡è¿™äº›çŸ¥è¯†ä¸ä»…èƒ½è®©ä½ æˆä¸ºæ›´å¥½çš„å¼€å‘è€…ï¼Œè¿˜èƒ½è®©ä½ ç†è§£ç°ä»£æ•°å­—ä¸–ç•Œçš„è¿ä½œæ–¹å¼ã€‚ç»§ç»­ä¿æŒå¥½å¥‡å¿ƒï¼ŒæŒç»­å­¦ä¹ å’Œå®è·µï¼

ğŸ‰ **æ­å–œä½ å®Œæˆäº†è¿™ä»½è¯¦å°½çš„ç½‘ç»œåè®®å­¦ä¹ ä¹‹æ—…ï¼**

æœ‰ä»»ä½•é—®é¢˜æˆ–æƒ³è¦æ·±å…¥æ¢è®¨æŸä¸ªç‰¹å®šåè®®ï¼Œéšæ—¶æ¥é—®æˆ‘ï¼è®©æˆ‘ä»¬ä¸€èµ·åœ¨ç½‘ç»œæŠ€æœ¯çš„æµ·æ´‹ä¸­ç»§ç»­æ¢ç´¢ï¼ğŸŒŠğŸš€